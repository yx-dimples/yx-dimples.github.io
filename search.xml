<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Flex 布局教程：语法篇</title>
    <url>/2021/08/04/CSS-Flex/</url>
    <content><![CDATA[<p>网页布局（layout）是 CSS 的一个重点应用。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071001.gif" alt="img"></p>
<p>布局的传统解决方案，基于<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box_model">盒状模型</a>，依赖 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/display"><code>display</code></a> 属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position"><code>position</code></a>属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/float"><code>float</code></a>属性。它对于那些特殊布局非常不方便，比如，<a href="https://css-tricks.com/centering-css-complete-guide/">垂直居中</a>就不容易实现。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071002.png" alt="img"></p>
<p>2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071003.jpg" alt="img"></p>
<p>Flex 布局将成为未来布局的首选方案。本文介绍它的语法，<a href="https://www.ruanyifeng.com/blog/2015/07/flex-examples.html">下一篇文章</a>给出常见布局的 Flex 写法。网友 <a href="http://vgee.cn/">JailBreak</a> 为本文的所有示例制作了 <a href="http://static.vgee.cn/static/index.html">Demo</a>，也可以参考。</p>
<p>以下内容主要参考了下面两篇文章：<a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">A Complete Guide to Flexbox</a> 和 <a href="https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties">A Visual Guide to CSS3 Flexbox Properties</a>。</p>
<h2 id="Flex-布局是什么？"><a href="#Flex-布局是什么？" class="headerlink" title="Flex 布局是什么？"></a>Flex 布局是什么？</h2><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p>
<p>任何一个容器都可以指定为 Flex 布局。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>行内元素也可以使用 Flex 布局。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Webkit 内核的浏览器，必须加上<code>-webkit</code>前缀。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex; <span class="comment">/* Safari */</span></span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意，设为 Flex 布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png" alt="img"></p>
<p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p>
<p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p>
<h2 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h2><p>以下6个属性设置在容器上。</p>
<blockquote>
<ul>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ul>
</blockquote>
<h3 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h3><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png" alt="img"></p>
<p>它可能有4个值。</p>
<blockquote>
<ul>
<li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li>
<li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li>
<li><code>column</code>：主轴为垂直方向，起点在上沿。</li>
<li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li>
</ul>
</blockquote>
<h3 id="flex-wrap属性"><a href="#flex-wrap属性" class="headerlink" title="flex-wrap属性"></a>flex-wrap属性</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071006.png" alt="img"></p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>它可能取三个值。</p>
<p>（1）<code>nowrap</code>（默认）：不换行。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png" alt="img"></p>
<p>（2）<code>wrap</code>：换行，第一行在上方。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg" alt="img"></p>
<p>（3）<code>wrap-reverse</code>：换行，第一行在下方。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg" alt="img"></p>
<h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="justify-content属性"><a href="#justify-content属性" class="headerlink" title="justify-content属性"></a>justify-content属性</h3><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png" alt="img"></p>
<p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p>
<blockquote>
<ul>
<li><code>flex-start</code>（默认值）：左对齐</li>
<li><code>flex-end</code>：右对齐</li>
<li><code>center</code>： 居中</li>
<li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li>
<li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>
</blockquote>
<h3 id="align-items属性"><a href="#align-items属性" class="headerlink" title="align-items属性"></a>align-items属性</h3><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png" alt="img"></p>
<p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>
<blockquote>
<ul>
<li><code>flex-start</code>：交叉轴的起点对齐。</li>
<li><code>flex-end</code>：交叉轴的终点对齐。</li>
<li><code>center</code>：交叉轴的中点对齐。</li>
<li><code>baseline</code>: 项目的第一行文字的基线对齐。</li>
<li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
</blockquote>
<h3 id="align-content属性"><a href="#align-content属性" class="headerlink" title="align-content属性"></a>align-content属性</h3><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png" alt="img"></p>
<p>该属性可能取6个值。</p>
<blockquote>
<ul>
<li><code>flex-start</code>：与交叉轴的起点对齐。</li>
<li><code>flex-end</code>：与交叉轴的终点对齐。</li>
<li><code>center</code>：与交叉轴的中点对齐。</li>
<li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li>
</ul>
</blockquote>
<h2 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h2><p>以下6个属性设置在项目上。</p>
<blockquote>
<ul>
<li><code>order</code></li>
<li><code>flex-grow</code></li>
<li><code>flex-shrink</code></li>
<li><code>flex-basis</code></li>
<li><code>flex</code></li>
<li><code>align-self</code></li>
</ul>
</blockquote>
<h3 id="order属性"><a href="#order属性" class="headerlink" title="order属性"></a>order属性</h3><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png" alt="img"></p>
<h3 id="flex-grow属性"><a href="#flex-grow属性" class="headerlink" title="flex-grow属性"></a>flex-grow属性</h3><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png" alt="img"></p>
<p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
<h3 id="flex-shrink属性"><a href="#flex-shrink属性" class="headerlink" title="flex-shrink属性"></a>flex-shrink属性</h3><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg" alt="img"></p>
<p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>
<p>负值对该属性无效。</p>
<h3 id="flex-basis属性"><a href="#flex-basis属性" class="headerlink" title="flex-basis属性"></a>flex-basis属性</h3><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间。</p>
<h3 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h3><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt;<span class="string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="string">&#x27;flex-basis&#x27;</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p>
<p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>
<h3 id="align-self属性"><a href="#align-self属性" class="headerlink" title="align-self属性"></a>align-self属性</h3><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png" alt="img"></p>
<p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>
]]></content>
      <tags>
        <tag>css</tag>
        <tag>css布局</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript</title>
    <url>/2021/07/30/JavaScript---data/</url>
    <content><![CDATA[<h2 id="1-1数据类型"><a href="#1-1数据类型" class="headerlink" title="1-1数据类型"></a>1-1数据类型</h2><h4 id="5种基本类型"><a href="#5种基本类型" class="headerlink" title="5种基本类型"></a>5种基本类型</h4><p>number<br>String<br>boolean<br>undefined<br>null</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">特例：</span><br><span class="line"><span class="comment">/* undefined</span></span><br><span class="line"><span class="comment">  如果声明一个变量没有赋值的情况下，就会输出undefined</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* null</span></span><br><span class="line"><span class="comment">   null就是空，不占内存空间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 声明提前，变量提升 (仅存在ES5中)</span></span><br><span class="line"><span class="comment">    js在执行代码的时候会将所有使用var声明的变量，放在作用域</span></span><br><span class="line"><span class="comment">    的顶部集中创建，赋值留在原地</span></span><br><span class="line"><span class="comment">    var a;</span></span><br><span class="line"><span class="comment">    console.log(a);</span></span><br><span class="line"><span class="comment">    a =20;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">//报错</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">20</span>;	</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">30</span>;</span><br></pre></td></tr></table></figure>
<h4 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*转换成number型*/</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;12&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="string">&quot;12.22px&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> num = <span class="built_in">Number</span>(a); <span class="comment">//12</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="built_in">Number</span>(b); <span class="comment">//1</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="built_in">Number</span>(c); <span class="comment">//isNaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(c)) <span class="comment">//12</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(c))	<span class="comment">//12.22</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*转换成String型*/</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> t = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> arr);  <span class="comment">//object,无法判断数组。</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">String</span>(a));   <span class="comment">//方法一</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> t.toString());		<span class="comment">//方法二</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*转换成boolean型*/</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;tr&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> d = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> e = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">var</span> f = <span class="literal">undefined</span>;</span><br><span class="line"><span class="built_in">Boolean</span>(a); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Boolean</span>(b); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Boolean</span>(c); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Boolean</span>(d); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Boolean</span>(e); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Boolean</span>(f); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自动转换 隐式转换 </span></span><br><span class="line"><span class="comment">   不需要程序员干预，js自动完成的类型转换</span></span><br><span class="line"><span class="comment">   场景:主要在算术计算中 + - * / %</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* 1.在加运算中的自动转换 </span></span><br><span class="line"><span class="comment">算术计算中，先将两边的变量转换为Number再计算</span></span><br><span class="line"><span class="comment">特殊：只要有一边在加运算中碰到字符串，+就作为拼接符的作用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="string">&quot;hello&quot;</span> ;</span><br><span class="line"><span class="keyword">var</span> str = a+b;</span><br><span class="line"><span class="keyword">var</span> sum = a+c;</span><br><span class="line"><span class="built_in">console</span>.log(str)    <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(sum)    <span class="comment">//1hello</span></span><br><span class="line"><span class="built_in">console</span>.log(b+c)    <span class="comment">//truehello</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a-(b+<span class="string">&quot;2&quot;</span>)); <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">20</span>-b+<span class="string">&quot;false&quot;</span>) <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">20</span>-b+<span class="built_in">Number</span>(<span class="string">&quot;12.34&quot;</span>)); <span class="comment">//31.34</span></span><br></pre></td></tr></table></figure>
<h2 id="1-2算术运算符"><a href="#1-2算术运算符" class="headerlink" title="1-2算术运算符"></a>1-2算术运算符</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	&gt; &lt; &lt;= &gt;= 比较运算的结果是TURE FLASE</span></span><br><span class="line"><span class="comment">	先将两边的值转换为Number再比较</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;20&quot;</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(a&gt;b)  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(a&gt;c)  <span class="comment">//false  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 比较运算</span></span><br><span class="line"><span class="comment">&lt; &gt; &lt;= &gt;=  == != */</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a=b);   <span class="comment">//20</span></span><br><span class="line"><span class="built_in">console</span>.log(a==b);  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(a!=b);  <span class="comment">//true</span></span><br><span class="line"><span class="comment">/* NaN与任何值做！= 比较时，结果为True */</span></span><br><span class="line"><span class="built_in">console</span>.log(a!=<span class="string">&quot;true&quot;</span>)  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*isNaN()方法判断是否为NaN*/</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(a));  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*三目运算*/</span></span><br><span class="line"><span class="keyword">var</span> c = (a&gt;b)?<span class="string">&quot;a大于b&quot;</span>:<span class="string">&quot;a小于b&quot;</span> <span class="comment">//（条件）？Y:N;</span></span><br><span class="line"><span class="built_in">console</span>.log(c)</span><br></pre></td></tr></table></figure>
<h5 id="三木运算符（vue）"><a href="#三木运算符（vue）" class="headerlink" title="三木运算符（vue）"></a>三木运算符（vue）</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;img @click=&quot;handleClick&quot; :src=&quot;isPlay?&#x27;images/hh.png&#x27;:&#x27;images/zs.png&#x27;&quot; alt=&quot;&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123;isPlay&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el:&quot;#app&quot;,</span><br><span class="line">        data()&#123;</span><br><span class="line">            return&#123;</span><br><span class="line">                isPlay:false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            handleClick()&#123;</span><br><span class="line">                this.isPlay = !this.isPlay</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-循环"><a href="#1-3-循环" class="headerlink" title="1-3 循环"></a>1-3 循环</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//whlle循环</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//switch case break continue循环</span></span><br><span class="line"><span class="keyword">switch</span>(variety)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;等于1&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;等于2&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;等于3&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;其他值&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="死循环实例"><a href="#死循环实例" class="headerlink" title="死循环实例"></a>死循环实例</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">window</span>.confirm(<span class="string">&quot;我帅吗&quot;</span>);</span><br><span class="line">  a+=<span class="number">10</span>;</span><br><span class="line">  <span class="keyword">while</span>(a)&#123;</span><br><span class="line">      alert(<span class="string">&quot;请说我很帅一百遍&quot;</span>); <span class="comment">//死循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*continue 和 break*/</span></span><br><span class="line"><span class="keyword">continue</span>是跳出本次循环</span><br><span class="line"><span class="keyword">break</span>是结束循环</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">/* break 中断跳出循环 */</span>  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;***********&quot;</span>)</span><br><span class="line">    <span class="comment">/* continue 跳出当前循环 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">1</span>;j&lt;=<span class="number">5</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript</title>
    <url>/2021/07/30/JavaScript---fun+arr/</url>
    <content><![CDATA[<h2 id="4-1函数"><a href="#4-1函数" class="headerlink" title="4-1函数"></a>4-1函数</h2><h4 id="1-赋值"><a href="#1-赋值" class="headerlink" title="1.赋值"></a>1.赋值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">/* es6 如果对象的属性名和值相同就可以简写 */</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;cheng&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">        name,   <span class="comment">//name:name</span></span><br><span class="line">        age,		<span class="comment">//age:age</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(obj)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="2-默认赋值"><a href="#2-默认赋值" class="headerlink" title="2.默认赋值"></a>2.默认赋值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params">type=<span class="string">&quot;get&quot;</span></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(type)</span><br><span class="line">&#125;</span><br><span class="line">go()        <span class="comment">//get</span></span><br><span class="line">go(<span class="string">&quot;post&quot;</span>)  <span class="comment">//post</span></span><br></pre></td></tr></table></figure>
<h4 id="3-有关函数的问题"><a href="#3-有关函数的问题" class="headerlink" title="3.有关函数的问题"></a>3.有关函数的问题</h4><ul>
<li>返回值 js不需要返回值，但是使用了return语句，后面的代码将不运行</li>
<li>函数传不定参的情况：多余的参数会被arguments对象接收。显示一个类数组对象</li>
<li>函数重载<ul>
<li>js不支持重载，若要实现重载，见下<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]+<span class="built_in">arguments</span>[<span class="number">1</span>])</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">arguments</span>.length == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">show(<span class="number">10</span>)</span><br><span class="line">show(<span class="number">10</span>,<span class="number">20</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>块级作用域</li>
<li>{ }<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">/* 块级作用域 </span></span><br><span class="line"><span class="comment">    es6之前没有块级作用域</span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> a = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(i)  <span class="comment">//4</span></span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">//报错</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="2-箭头函数"><a href="#2-箭头函数" class="headerlink" title="2.箭头函数"></a>2.箭头函数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="function"><span class="params">x</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="function">(<span class="params">x,y</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li>箭头函数<ul>
<li>参数只有一个可以不用小括号，输出语句只有一行可以不用大括号<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> go = <span class="function"><span class="params">x</span>=&gt;</span>x;</span><br><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="params">z</span>=&gt;</span><span class="built_in">console</span>.log(z);</span><br><span class="line"><span class="keyword">var</span> getInfo=<span class="function">(<span class="params">x,y</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">    <span class="built_in">console</span>.log(x+y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2this指向函数"><a href="#4-2this指向函数" class="headerlink" title="4-2this指向函数"></a>4-2this指向函数</h2><h4 id="1-箭头函数与this的关系"><a href="#1-箭头函数与this的关系" class="headerlink" title="1.箭头函数与this的关系"></a>1.箭头函数与this的关系</h4></li>
</ul>
</li>
<li>解决了函数内部this关键字的指向问题。当函数直接调用时，this指向window<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)  <span class="comment">//div&#123;&#125;</span></span><br><span class="line">    go()   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)  <span class="comment">//window&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-有关方法的用法及语法"><a href="#2-有关方法的用法及语法" class="headerlink" title="2.有关方法的用法及语法"></a>2.有关方法的用法及语法</h4></li>
<li>bind( ) 改变了函数执行的上下文环境</li>
<li>call( ) 改变函数this的指向，函数调用的时候执行</li>
<li>apply( ) 改变函数this的指向，函数调用的时候执行<br>bind改变函数上下文执行环境,不会马上执行，被apply,call绑定的函数会马上执行</li>
</ul>
<p>键值语法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* es5语法 */</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;html&quot;</span>,</span><br><span class="line">    <span class="attr">sayName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">/* es6语法 */</span> </span><br><span class="line"><span class="keyword">var</span> skill = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;javascript&quot;</span>,</span><br><span class="line">    <span class="function"><span class="title">saySkill</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bind，call ，apply方法的调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 调用实例一 --&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">var</span> li = <span class="string">&quot;li&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">var</span> obj = &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">name</span> : <span class="string">&quot;cheng&quot;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)  <span class="comment">//cheng</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">test.call(obj) </span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- 调用实例一 --&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params">name,age</span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name+<span class="string">&quot;:&quot;</span>+<span class="built_in">this</span>.age)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">console</span>.log(name)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">console</span>.log(age)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;    </span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> li = &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">name</span>:<span class="string">&quot;李梦瑶&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">age</span>:<span class="number">23</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> zhang = &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">name</span>:<span class="string">&quot;张三丰&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">age</span>:<span class="number">100</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    go.apply(li,[<span class="string">&quot;li&quot;</span>,<span class="number">24</span>])</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    go.call(zhang,<span class="string">&quot;zhang&quot;</span>,<span class="number">111</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 结果 */</span></span><br><span class="line">李梦瑶:<span class="number">23</span></span><br><span class="line">li</span><br><span class="line"><span class="number">24</span></span><br><span class="line">张三丰:<span class="number">100</span></span><br><span class="line">zhang</span><br><span class="line"><span class="number">111</span></span><br></pre></td></tr></table></figure>
<h2 id="4-3回调函数"><a href="#4-3回调函数" class="headerlink" title="4-3回调函数"></a>4-3回调函数</h2><p><strong>回调函数</strong><br>就是将函数作为参数传递给另外一个函数函数执行完后再执行回调的函数 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">http</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> data = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;cheng&quot;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;;</span><br><span class="line">        callback(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleData</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;</span><br><span class="line">    http(handleData);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="4-4操作数组"><a href="#4-4操作数组" class="headerlink" title="4-4操作数组"></a>4-4操作数组</h2><h4 id="1-创建数组的两种方法"><a href="#1-创建数组的两种方法" class="headerlink" title="1.创建数组的两种方法"></a>1.创建数组的两种方法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h4 id="2-数组的遍历"><a href="#2-数组的遍历" class="headerlink" title="2.数组的遍历"></a>2.数组的遍历</h4><ul>
<li>for in遍历(可以对对象进行遍历)<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> arr)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(arr[key])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li> forEach 遍历</li>
<li> for of 遍历</li>
<li> map 遍历（下面介绍）</li>
<li> some 所有数据满足一个条件，返回true</li>
<li> every 所有数据满足条件，返回true<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">/* forEach */</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;html&#x27;</span>,<span class="string">&#x27;css&#x27;</span>,<span class="string">&#x27;vue&#x27;</span>];</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line"><span class="built_in">console</span>.log(index)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* of */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> value <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* map */</span>   </span><br><span class="line"><span class="keyword">var</span> newArray = arr.map(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item+<span class="string">&quot;1&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(newArray)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt; </span><br></pre></td></tr></table></figure>
<h4 id="3-遍历键值对变量"><a href="#3-遍历键值对变量" class="headerlink" title="3.遍历键值对变量"></a>3.遍历键值对变量</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> data = &#123;<span class="attr">name</span>:<span class="string">&quot;wujianxiong&quot;</span>,<span class="attr">age</span>:<span class="number">20</span>,<span class="attr">sex</span>:<span class="string">&quot;男&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> data)&#123;</span><br><span class="line">        <span class="keyword">var</span> p = <span class="built_in">document</span>.createElement(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">        p.innerHTML = data[key];</span><br><span class="line">        <span class="built_in">document</span>.body.append(p)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">​<span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string">#### 4.数组排序</span></span><br><span class="line"><span class="string">- reserve 倒序</span></span><br><span class="line"><span class="string">- sort 根据函数冒泡排序</span></span><br><span class="line"><span class="string">- reduce 根据匿名函数进行累加／累减</span></span><br><span class="line"><span class="string">#### 5.数组的增加</span></span><br><span class="line"><span class="string">- push( )  从数组的末尾增加一个值，可一次性增加多个</span></span><br><span class="line"><span class="string">- unshift 从数组的开头增加</span></span><br><span class="line"><span class="string">- concat( )  拼接两个数组,但是不能改变原数组的结构</span></span><br><span class="line"><span class="string">- ...  展开</span></span><br><span class="line"><span class="string">- filter( ) 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素</span></span><br><span class="line"><span class="string">- join(&quot;/&quot;) 参数是分隔符</span></span><br><span class="line"><span class="string">​`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="comment">/* push() */</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    arr.push(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(arr)  <span class="comment">//Array[5] &#123;1，2，3，4，5&#125;</span></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* concat() */</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> obj = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> newArray = arr.concat(obj)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="built_in">console</span>.log(newArray)  <span class="comment">//Array[6] &#123;1,2,3,4,5,6&#125;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> obj = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="built_in">console</span>.log(...arr)    <span class="comment">//1 2 3</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    arr.push(...obj)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="built_in">console</span>.log(arr)	<span class="comment">//Array[6] &#123;1,2,3,4,5,6&#125;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li>定点增加<br>splice(index,0,parmas)<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">/* splice(index,0,parmas) 从index的前面增加*/</span></span><br><span class="line">  <span class="keyword">var</span> skills = [<span class="string">&#x27;html&#x27;</span>,<span class="string">&#x27;css&#x27;</span>,<span class="string">&#x27;jq&#x27;</span>,<span class="string">&#x27;js&#x27;</span>]</span><br><span class="line">  <span class="comment">/* splice */</span></span><br><span class="line">  skills.splice(<span class="number">2</span>,<span class="number">0</span>,<span class="string">&#x27;vue&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(skills)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="5-删除"><a href="#5-删除" class="headerlink" title="5.删除"></a>5.删除</h4></li>
<li>pop( ) 从后面删除</li>
<li>shift( ) 从前面删除</li>
<li>arrayObject.splice(index,howmany,item1,…..,itemX)<h4 id="6-查询"><a href="#6-查询" class="headerlink" title="6.查询"></a>6.查询</h4></li>
<li>indexOf(element) 查询元素下标的方法</li>
<li>slice(start,end) 从start下标处查询到end-1处</li>
<li>includes( ) 判断数组是否包含某个值</li>
<li>Math.max(…arr) 查询最大值</li>
<li>Math.min(…arr) 查询最小值</li>
<li>find(item=&gt;item==2) 返回第一个满足条件的值</li>
<li>findIndex(item=&gt;item.id==123)返回满足条件的下标</li>
<li>filter(item=&gt;item.id==123)返回满足条件的对象</li>
<li>map(item=&gt;item.id==123)返回新数组，但是不能改变数组结构 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(songs[i].name.length&gt;<span class="number">5</span>)&#123;</span><br><span class="line">  obj.name = songs[i].name.slice(<span class="number">0</span>, <span class="number">5</span>)+<span class="string">&quot;...&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  obj.name = songs[i].name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="filter-every介绍"><a href="#filter-every介绍" class="headerlink" title="filter\every介绍"></a>filter\every介绍</h3></li>
<li>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</li>
<li>every() 方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。<br>every() 方法使用指定函数检测数组中的所有元素：</li>
<li>如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。</li>
<li>如果所有元素都满足条件，则返回 true。</li>
</ul>
<p><strong>注意</strong>： every() 不会对空数组进行检测。<br><strong>注意</strong>： every() 不会改变原始数组。</p>
<img src="https://cdn.nlark.com/yuque/0/2019/png/402742/1573888111278-9f33b7c5-72f0-4ad8-97e8-8fc2ccd18519.png" alt="img" style="zoom: 80%;">]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript</title>
    <url>/2021/07/30/JavaScript---method/</url>
    <content><![CDATA[<h3 id="1-小数化整"><a href="#1-小数化整" class="headerlink" title="1.小数化整"></a>1.小数化整</h3><p>Math.ceil( ) 上取整<br>​        Math.floor( ) 下取整<br>​        Math.round( ) 四舍五入取整</p>
<ul>
<li>1-1保留一位小数<ul>
<li>num.toFixed(1)<h3 id="2-重置下标"><a href="#2-重置下标" class="headerlink" title="2.重置下标"></a>2.重置下标</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//javascript</span></span><br><span class="line"><span class="keyword">var</span> index = <span class="built_in">this</span>.index;</span><br><span class="line"><span class="comment">//jquery</span></span><br><span class="line"><span class="keyword">var</span> index = $(<span class="built_in">this</span>).index();</span><br></pre></td></tr></table></figure>
<h3 id="3-更改CSS里的属性"><a href="#3-更改CSS里的属性" class="headerlink" title="3.更改CSS里的属性"></a>3.更改CSS里的属性</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> move = <span class="built_in">document</span>.getElementById(<span class="string">&quot;move&quot;</span>);</span><br><span class="line">move.style.cssText = <span class="string">`left:<span class="subst">$&#123;left&#125;</span>px;top:<span class="subst">$&#123;top&#125;</span>px`</span>;</span><br></pre></td></tr></table></figure>
<h3 id="4-给标签填充文字"><a href="#4-给标签填充文字" class="headerlink" title="4.给标签填充文字"></a>4.给标签填充文字</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 如果有引号用转义符\ */</span></span><br><span class="line">p.innerHTML = <span class="string">&quot;搜索\&quot;&quot;</span>+v.value+<span class="string">&quot;\&quot;,找到600首单曲&quot;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="5-JS装换时分秒"><a href="#5-JS装换时分秒" class="headerlink" title="5.JS装换时分秒"></a>5.JS装换时分秒</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">如果你红框内返回的是毫秒数，你就要先转换为date类型 比如红框内是X ;</span><br><span class="line">(注:这里的毫秒数是由具体年月日转换来的，但接口里就是根据时间转换过来的，可以直接用)</span><br><span class="line">(不能用年月日的时间差去转换)</span><br><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>(X);</span><br><span class="line"><span class="keyword">var</span> year = now.getFullYear(); <span class="comment">//获取年份</span></span><br><span class="line"><span class="keyword">var</span> month = now.getMonth(); <span class="comment">//获取月份 月份要+1</span></span><br><span class="line"><span class="keyword">var</span> date = now.getDate(); <span class="comment">//获取日期</span></span><br><span class="line"><span class="keyword">var</span> hour = now.getHours(); <span class="comment">//获取时</span></span><br><span class="line"><span class="keyword">var</span> minu = now.getMinutes(); <span class="comment">//获取分钟</span></span><br><span class="line"><span class="keyword">var</span> sec = now.getSeconds(); <span class="comment">//获取秒钟</span></span><br><span class="line">这些都是原生的js方法</span><br></pre></td></tr></table></figure>
<h3 id="6-JS封装入口（窗口加载完成）"><a href="#6-JS封装入口（窗口加载完成）" class="headerlink" title="6.JS封装入口（窗口加载完成）"></a>6.JS封装入口（窗口加载完成）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">window</span>.onload(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="7-遍历接口中多个相同属性"><a href="#7-遍历接口中多个相同属性" class="headerlink" title="7.遍历接口中多个相同属性"></a>7.遍历接口中多个相同属性</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [];</span><br><span class="line"><span class="keyword">var</span> castnames = [];</span><br><span class="line">writers.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">  names.push(item.name)</span><br><span class="line">&#125;);  </span><br><span class="line">obj.writers = names.join(<span class="string">&quot;/&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="8-关于冒号"><a href="#8-关于冒号" class="headerlink" title="8.关于冒号 :"></a>8.关于冒号 :</h3>$(“:button”) 表示匹配所有的按钮。<br>$(“input:checked”)表示匹配所有选中的被选中元素(复选框、单选框等，不包括select中的option)。 </li>
</ul>
</li>
</ul>
<h3 id="9-is"><a href="#9-is" class="headerlink" title="9.is()"></a>9.is()</h3><ul>
<li>$(selector).is(selectorElement,function(index,element))<ul>
<li>选择器表达式，根据选择器/元素/jQuery 对象检查匹配元素集合，如果存在至少一个匹配元素，则返回 true，否则返回 false.</li>
<li>function()可选项<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ($(<span class="string">&quot;p&quot;</span>).parent().is(<span class="string">&quot;div&quot;</span>)) &#123;</span><br><span class="line">    alert(<span class="string">&quot;p 的父元素是 div&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">判断动画播放完</span><br><span class="line"><span class="keyword">if</span>(!$(<span class="string">&quot;.pic&gt;img&quot;</span>).is(<span class="string">&quot;:animated&quot;</span>))</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -----------生命周期--------</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 可以获取dom元素，但无法获取宽高等属性（window.onload可以获取）</span></span><br><span class="line"><span class="comment">* 可以依次执行多个ready函数（但window.onload只执行一次）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行函数（等同于上面的ready函数）</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------获取dom-----------</span></span><br><span class="line"><span class="keyword">var</span> $dom = $(<span class="string">&quot;p&quot;</span>);  <span class="comment">//这里是jq对象的dom，如果$(&quot;p&quot;)[0],这是原生dom，下同。</span></span><br><span class="line"><span class="keyword">var</span> $dom_class = $(<span class="string">&quot;.box&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> $dom_id = $(<span class="string">&quot;#box&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------修改CSS-----------</span></span><br><span class="line">$dom.css(&#123;</span><br><span class="line">  <span class="attr">background</span>: <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------获取宽高-----------</span></span><br><span class="line">$dom.width()</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------创建DOM------------</span></span><br><span class="line"><span class="keyword">var</span> $p = $(<span class="string">&quot;&lt;p&gt;hello&lt;/p&gt;&quot;</span>);</span><br><span class="line">$dom.append($p)</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------遍历伪数组----------</span></span><br><span class="line"><span class="keyword">var</span> warr = &#123;<span class="number">0</span>: <span class="string">&#x27;s&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;r&#x27;</span>, <span class="attr">length</span>: <span class="number">2</span>&#125;;</span><br><span class="line">$.each(warr, <span class="function"><span class="keyword">function</span>(<span class="params">index, item</span>)</span>&#123; &#125;); <span class="comment">// $.each也可以遍历数组，返回值是原对象</span></span><br><span class="line">$.map(warr, <span class="function"><span class="keyword">function</span>(<span class="params">item, index</span>)</span>&#123; <span class="keyword">return</span> item &#125;); <span class="comment">// $.map也可以遍历数组,</span></span><br><span class="line">	返回值是<span class="keyword">return</span>处理的数组</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascrip</title>
    <url>/2021/07/30/JavaScript---object/</url>
    <content><![CDATA[<h2 id="2-1Dom树"><a href="#2-1Dom树" class="headerlink" title="2-1Dom树"></a>2-1Dom树</h2><h4 id="Dom-document-object-model-文档对象模型"><a href="#Dom-document-object-model-文档对象模型" class="headerlink" title="Dom (document object model)文档对象模型"></a>Dom (document object model)文档对象模型</h4><p>Dom树 :增删改查元素的标准,可以动态的修改元素的内容，样式，结构</p>
<ul>
<li>Dom树是由一个个节点构成</li>
<li>节点的关系：父子关系，兄弟关系<h5 id="1-如何获取一个Dom-html元素"><a href="#1-如何获取一个Dom-html元素" class="headerlink" title="1. 如何获取一个Dom (html元素)"></a>1. 如何获取一个Dom (html元素)</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p id=<span class="string">&quot;test&quot;</span>&gt;&lt;/p&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">       </span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">var</span> test = <span class="built_in">document</span>.getElementById(<span class="string">&quot;test&quot;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span>       </span><br></pre></td></tr></table></figure>
<h5 id="2-给节点增加一个class"><a href="#2-给节点增加一个class" class="headerlink" title="2.给节点增加一个class"></a>2.给节点增加一个class</h5></li>
<li>object.className = “classname”<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="built_in">document</span>.getElementById(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">test.className = <span class="string">&quot;current&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="2-给节点增加一个class-1"><a href="#2-给节点增加一个class-1" class="headerlink" title="2.给节点增加一个class"></a>2.给节点增加一个class</h5></li>
<li>object.className = “classname”<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="built_in">document</span>.getElementById(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">test.className = <span class="string">&quot;current&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="3-判断一个元素是否有某Class"><a href="#3-判断一个元素是否有某Class" class="headerlink" title="3.判断一个元素是否有某Class"></a>3.判断一个元素是否有某Class</h5></li>
<li>object.classList.contains(“classname”)<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">this</span>.classList.contains(<span class="string">&quot;one&quot;</span>))&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-节点查询元素属性"><a href="#4-节点查询元素属性" class="headerlink" title="4.节点查询元素属性"></a>4.节点查询元素属性</h5></li>
<li>元素节点=1</li>
<li>属性节点=2</li>
<li>文本节点=3<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//firstChild 输出第一个节点</span></span><br><span class="line"><span class="comment">//firstElementChild 输出第一个元素节点</span></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;parent&quot;</span>&gt;</span>wujx<span class="tag">&lt;<span class="name">p</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">         <span class="keyword">var</span> parent = <span class="built_in">document</span>.getElementById(<span class="string">&quot;parent&quot;</span>); </span></span></span><br><span class="line"><span class="javascript"><span class="xml">         <span class="keyword">var</span> tNode = parent.firstChild;         <span class="comment">//文本节点</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">         <span class="keyword">var</span> aNode = parent.getAttributeNode(<span class="string">&quot;id&quot;</span>);  <span class="comment">//属性节点</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">         <span class="built_in">console</span>.log(parent.firstElementChild)  <span class="comment">//&lt;p&gt;hello world&lt;/p&gt;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">         <span class="built_in">console</span>.log(parent.firstChild)			<span class="comment">//&quot;wujx&quot;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">         <span class="built_in">console</span>.log(parent.nodeType)			<span class="comment">//1</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">         <span class="built_in">console</span>.log(tNode.nodeType)			<span class="comment">//3</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">         <span class="built_in">console</span>.log(aNode.nodeType)			<span class="comment">//2</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<h5 id="5-自定义属性"><a href="#5-自定义属性" class="headerlink" title="5.自定义属性"></a>5.自定义属性</h5></li>
<li>data-*<ul>
<li>这个属性是html5新加的特性，为了绑定数据，我们可以将一些参数绑定到dom标签上，而不用将数据填 到input标签上然后隐藏该标签。最需要注意的一点的取值时必需全部使用小写的名字，”data-*”中名字可以用驼峰命名。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;test&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;one&quot;</span> data-uid=<span class="string">&quot;two&quot;</span>&gt;hello world&lt;/div&gt;  </span><br></pre></td></tr></table></figure>
<h5 id="6-增删改查"><a href="#6-增删改查" class="headerlink" title="6.增删改查"></a>6.增删改查</h5></li>
</ul>
</li>
<li>增：appendChild()</li>
<li>删：removeChild()</li>
<li>改：replaceChild(newChild,oldChild)</li>
<li>查：<ul>
<li>id :获取后直接查询</li>
<li> class :获取后直接查询的是HTML collection,通过下标查询该元素所有属性<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*增*/</span></span><br><span class="line"><span class="keyword">var</span> parent = <span class="built_in">document</span>.getElementById(<span class="string">&quot;parent&quot;</span>)；</span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.createElement(<span class="string">&quot;p&quot;</span>);</span><br><span class="line"><span class="comment">//内容增加方法一 innerHTML</span></span><br><span class="line">  p.innerHTML = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">  parent.appendChild(p); <span class="comment">//在原有内容的后面增加新的元素</span></span><br><span class="line">  parent.insertBefore(p,parent.firstElementChild)<span class="comment">//在原有内容的前面增加新的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内容增加方法二 document.createTextNode(&quot;contents&quot;)</span></span><br><span class="line">  <span class="keyword">var</span> txt = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;第零个&quot;</span>);</span><br><span class="line">  p.appendChild(txt)</span><br><span class="line">  parent.insertBefore(p,parent.firstElementChild)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*删*/</span></span><br><span class="line">	<span class="comment">//父类parent</span></span><br><span class="line">  <span class="comment">//子类good</span></span><br><span class="line">	<span class="keyword">var</span> parent = <span class="built_in">document</span>.getElementById(<span class="string">&quot;parent&quot;</span>)；		</span><br><span class="line">  parent.removeChild(good);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*改*/</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>good<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">var</span> parent = <span class="built_in">document</span>.getElementById(<span class="string">&quot;parent&quot;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">var</span> p = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;p&quot;</span>)[<span class="number">0</span>];</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">var</span> h2 = <span class="built_in">document</span>.createElement(<span class="string">&quot;h2&quot;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  h2.innerHTML = <span class="string">&quot;标题&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  parent.replaceChild(h2,p);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*查*/</span></span><br><span class="line"><span class="comment">//id       			getElementById()</span></span><br><span class="line"><span class="comment">//class    			getElementsByClassName()</span></span><br><span class="line"><span class="comment">//tagName  			getElementsByTagName()</span></span><br><span class="line"><span class="comment">//querySelector querySelectorAll() querySelector()</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;one&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;one&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">var</span> one = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;one&quot;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">console</span>.log(one)  							<span class="comment">//HTML collection</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">console</span>.log(one[<span class="number">0</span>])  						<span class="comment">//元素属性</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(one)) <span class="comment">//false 原因：class是集合中的一个对象</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">				<span class="built_in">console</span>.log(<span class="keyword">typeof</span> one)         <span class="comment">//object</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        one[<span class="number">0</span>].style.color = <span class="string">&quot;red&quot;</span>;     <span class="comment">//这里只能通过数组去改变</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h5 id="7-克隆节点"><a href="#7-克隆节点" class="headerlink" title="7.克隆节点"></a>7.克隆节点</h5></li>
</ul>
</li>
<li>cloneNode(true)<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;test&quot;</span>&gt;hello world&lt;/p&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> test = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;test&quot;</span>)[<span class="number">0</span>];</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">var</span> cTest = test.cloneNode(<span class="literal">true</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="built_in">document</span>.body.appendChild(cTest)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h5 id="8-获取节点"><a href="#8-获取节点" class="headerlink" title="8.获取节点"></a>8.获取节点</h5></li>
<li>childNode  获取子节点， 不会区分文本，和元素节点</li>
<li>children 与上一个方法相同</li>
<li>nextSibling 获取下一个兄弟节点</li>
<li>nextElementSibling  获取下个兄弟元素节点<h5 id="9-获取定位偏移值"><a href="#9-获取定位偏移值" class="headerlink" title="9.获取定位偏移值"></a>9.获取定位偏移值</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">offsetParent 获取给了定位元素的父级 </span><br><span class="line">offsetLeft  返回元素的相对定位父元素水平偏移的位置。返回number</span><br><span class="line">offsetTop  返回元素的相对定位父元素水平垂直偏移的位置.</span><br></pre></td></tr></table></figure>
<h5 id="10-操作属性"><a href="#10-操作属性" class="headerlink" title="10.操作属性"></a>10.操作属性</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setAttribute(<span class="string">&quot;attr&quot;</span>,<span class="string">&quot;value&quot;</span>)  <span class="comment">//设置属性</span></span><br><span class="line">getAttribute(<span class="string">&quot;attr&quot;</span>)  <span class="comment">//获取属性</span></span><br><span class="line">removeAttribute(<span class="string">&quot;attr&quot;</span>)  移除属性</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-2BOM"><a href="#2-2BOM" class="headerlink" title="2-2BOM"></a>2-2BOM</h2><h4 id="定义：BOM（browser-object-model）浏览器对象模型"><a href="#定义：BOM（browser-object-model）浏览器对象模型" class="headerlink" title="定义：BOM（browser object model）浏览器对象模型"></a>定义：BOM（browser object model）浏览器对象模型</h4><h5 id="1-window内置的Bom方法"><a href="#1-window内置的Bom方法" class="headerlink" title="1.window内置的Bom方法"></a>1.window内置的Bom方法</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert()    警告</span><br><span class="line">prompt()   提示</span><br><span class="line">confirm()  确认</span><br><span class="line">open(<span class="string">&#x27;url&#x27;</span>) 打开网页</span><br><span class="line"><span class="built_in">setTimeout</span>(func,time)</span><br><span class="line"><span class="comment">//  window.alert(1);</span></span><br><span class="line"><span class="comment">//  window.prompt(&quot;请输入你的年龄&quot;)</span></span><br><span class="line"><span class="comment">//  window.confirm(&quot;是否支付&quot;)</span></span><br></pre></td></tr></table></figure>
<h5 id="2-定时器"><a href="#2-定时器" class="headerlink" title="2.定时器"></a>2.定时器</h5><ul>
<li>设置超时定时器：setTimeout(func,time)</li>
<li>设置间隔定时器：setInterval(func,time)</li>
<li>清除定时器：clearInterval(variety)<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//超时调用，只执行一次</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">&#125;,<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//间隔调用，反复执行，可应用递归思想调用函数</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//清除定时器</span></span><br><span class="line"><span class="built_in">clearInterval</span>()</span><br></pre></td></tr></table></figure>
<h5 id="3-history"><a href="#3-history" class="headerlink" title="3.history"></a>3.history</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 历史页面记录回掉 */</span></span><br><span class="line">history.back()</span><br><span class="line"><span class="comment">/* 返回历史记录的前一个页面 */</span></span><br><span class="line">history.forward()</span><br></pre></td></tr></table></figure>
<h2 id="2-3增删class和元素"><a href="#2-3增删class和元素" class="headerlink" title="2-3增删class和元素"></a>2-3增删class和元素</h2><h5 id="1-classList"><a href="#1-classList" class="headerlink" title="1.classList"></a>1.classList</h5><h6 id="Javascript中"><a href="#Javascript中" class="headerlink" title="Javascript中:"></a>Javascript中:</h6></li>
<li>add( )  增加                        </li>
<li> remove( ) 移除</li>
<li> toggle( )  切换</li>
<li> contains( )  是否包含class<h6 id="Jquery中："><a href="#Jquery中：" class="headerlink" title="Jquery中："></a>Jquery中：</h6></li>
<li>addClass( )</li>
<li>removeClass( )</li>
<li>toggleClass( )</li>
<li>hasClass( )<h5 id="2-增加元素的方法"><a href="#2-增加元素的方法" class="headerlink" title="2.增加元素的方法"></a>2.增加元素的方法</h5></li>
<li>prepend( )  在父元素第一位增加元素</li>
<li>append( )   在父元素后面增加元素<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">var</span> parent = <span class="built_in">document</span>.getElementById(<span class="string">&quot;parent&quot;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">var</span> h1 = <span class="built_in">document</span>.createElement(<span class="string">&quot;h1&quot;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        h1.innerHTML = <span class="string">&#x27;head&#x27;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        parent.prepend(h1);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        parent.append(<span class="string">&quot;foot&quot;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<h6 id="Jquery实现"><a href="#Jquery实现" class="headerlink" title="Jquery实现"></a>Jquery实现</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;body&quot;</span>).prepend(<span class="string">&quot;&lt;h1&gt;前面&lt;/h1&gt;&quot;</span>)    </span><br><span class="line">$(<span class="string">&quot;body&quot;</span>).append(<span class="string">&quot;&lt;h1&gt;后面&lt;/h1&gt;&quot;</span>)   </span><br></pre></td></tr></table></figure>
<h6 id="before-after实现"><a href="#before-after实现" class="headerlink" title="before-after实现"></a>before-after实现</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">&quot;p&quot;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        p.before(<span class="string">&quot;前面&quot;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        p.after(<span class="string">&quot;后面&quot;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<h5 id="3-获取样式表中的样式"><a href="#3-获取样式表中的样式" class="headerlink" title="3. 获取样式表中的样式"></a>3. 获取样式表中的样式</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getComputedStyle(obj).attr</span><br></pre></td></tr></table></figure>
<h2 id="2-4文档碎片"><a href="#2-4文档碎片" class="headerlink" title="2-4文档碎片"></a>2-4文档碎片</h2><h4 id="文档碎片-脱离Dom"><a href="#文档碎片-脱离Dom" class="headerlink" title="文档碎片 脱离Dom"></a>文档碎片 脱离Dom</h4></li>
<li>原理：将Dom暂时寄存在fragment上，之后一次性添加到Dom上就可以了<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="built_in">document</span>.getElementById(<span class="string">&quot;parent&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> frag = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">var</span> li =<span class="built_in">document</span>.createElement(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">        li.innerHTML = i;</span><br><span class="line">        <span class="comment">/* 寄存在文档碎片上 */</span></span><br><span class="line">        frag.appendChild(li);</span><br><span class="line">    &#125;</span><br><span class="line">    parent.appendChild(frag)</span><br></pre></td></tr></table></figure>
<h2 id="2-5批量操作"><a href="#2-5批量操作" class="headerlink" title="2-5批量操作"></a>2-5批量操作</h2>style<br> 属性<br> cssText  批量操作<br> getPropertyValue()<br> item()  返回对应位置的css属性名<br> removeProperty(attr)<br> setProperty(attr,value)<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="built_in">document</span>.getElementById(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    test.style.cssText = <span class="string">&quot;color:red;background-color:#333&quot;</span></span><br><span class="line">    <span class="built_in">console</span>.log(test.style.getPropertyValue(<span class="string">&quot;color&quot;</span>))</span><br><span class="line">    <span class="built_in">console</span>.log(test.style.item(<span class="number">0</span>))</span><br><span class="line">    test.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.style.removeProperty(<span class="string">&quot;color&quot;</span>)</span><br><span class="line">        <span class="built_in">this</span>.style.setProperty(<span class="string">&quot;background&quot;</span>,<span class="string">&quot;green&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB--集合操作</title>
    <url>/2021/08/02/MongoDB--collection/</url>
    <content><![CDATA[<h2 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h2><p>集合，类似关系型数据库中的表<br>可以显示的创建，也可以隐式的创建</p>
<h5 id="集合的显示创建-了解"><a href="#集合的显示创建-了解" class="headerlink" title="集合的显示创建(了解)"></a>集合的显示创建(了解)</h5><p>基本语法格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.createCollection(name)</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>name: 要创建的集合名称</li>
</ul>
<p>例如：创建一个名为<code>mycollection</code>的普通集合。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.createCollection(&quot;mycollection&quot;)</span><br></pre></td></tr></table></figure>
<p>查看当前库中的表：show tables命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show collections</span><br><span class="line">或</span><br><span class="line">show tables</span><br></pre></td></tr></table></figure>

<p>集合的命名规范：</p>
<ul>
<li>集合名不能是空字符串(“”)</li>
<li>集合名不能包含 \0 字符(空字符)，这个字符标识集合名的结束</li>
<li>集合名不能以 “system.” 开头，这是为系统保留的前缀</li>
<li>用户创建的集合名字不能有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的合集，否则千万不要在名字里出现$</li>
</ul>
<h5 id="集合的隐式创建"><a href="#集合的隐式创建" class="headerlink" title="集合的隐式创建"></a>集合的隐式创建</h5><p>当前一个集合中插入一个文档的时候，如果集合不存在，则会自动创建集合。<br>详见<code>文档的插入</code>章节<br>提示：通常我们使用隐式创建文档即可</p>
<h5 id="集合的删除"><a href="#集合的删除" class="headerlink" title="集合的删除"></a>集合的删除</h5><p>集合删除语法格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.集合名字.drop()</span><br></pre></td></tr></table></figure>
<p><strong>返回值</strong><br>如果成功删除选定集合，则 drop() 方法返回 true，否则返回 false。</p>
<p>例如：要删除<code>mycollection</code>集合</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.mycollection.drop()</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB--数据库操作</title>
    <url>/2021/08/02/MongoDB--databse/</url>
    <content><![CDATA[<h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><h5 id="选择和创建数据库"><a href="#选择和创建数据库" class="headerlink" title="选择和创建数据库"></a>选择和创建数据库</h5><p>选择和创建数据库的语法格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use 数据库名称</span><br></pre></td></tr></table></figure>

<p>查看有权限查看的所有的数据库命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show dbs</span><br><span class="line">或</span><br><span class="line">show dababases</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong> 在MongoDB中，集合只有在插入后才会创建！就是说，创建集合（数据表）后要再插入一个文档（记录），集合才会真正创建</p>
</blockquote>
<p>查看当前正在使用的数据库命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db</span><br></pre></td></tr></table></figure>
<p>MongoDB中默认的数据库为test，如果你没有选择数据库，集合将存放在test数据库中。</p>
<p>数据库名可以是满足以下条件的任意UTF-8字符串:</p>
<ul>
<li>不能是空字符串（””)。</li>
<li>不得含有’ ‘（空格)、.、$、/、\和\0 (空字符)。</li>
<li>应全部小写。</li>
<li>最多64字节。<br>有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。</li>
<li><strong>admin</strong>： 从权限的角度来看，这是”root”数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。</li>
<li><strong>local</strong>: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</li>
<li><strong>config</strong>: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。</li>
</ul>
<h5 id="数据的删除"><a href="#数据的删除" class="headerlink" title="数据的删除"></a>数据的删除</h5><p>MongoDB删除数据库的语法格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.dropDatabase()</span><br></pre></td></tr></table></figure>
<p>提示：主要用来删除已经持久化的数据库</p>
]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript</title>
    <url>/2021/07/30/JavaScript---event/</url>
    <content><![CDATA[<h2 id="3-1常用的事件"><a href="#3-1常用的事件" class="headerlink" title="3-1常用的事件"></a>3-1常用的事件</h2><h4 id="1-常用的事件"><a href="#1-常用的事件" class="headerlink" title="1.常用的事件"></a>1.常用的事件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">onclick     点击事件</span><br><span class="line">onmouseover 鼠标悬停</span><br><span class="line">onmouseout  鼠标移出</span><br><span class="line">onchange    元素改变</span><br><span class="line">onkeydown   按下键盘</span><br><span class="line">onkeyup    松开键盘</span><br><span class="line">onload     浏览器完成页面加载</span><br><span class="line">onblur     元素失去焦点</span><br><span class="line">onfocus    元素获得焦点</span><br><span class="line">onscroll   滚动事件（scrollTop获取滚动条距离顶部的高度）</span><br><span class="line">onresize   当浏览器被重置大小时触发</span><br><span class="line">onmousemove 鼠标移动</span><br><span class="line">onmousedown 鼠标按下</span><br><span class="line">onmouseup 鼠标松开</span><br></pre></td></tr></table></figure>
<h4 id="2-获取键盘码"><a href="#2-获取键盘码" class="headerlink" title="2.获取键盘码"></a>2.获取键盘码</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">input.onkeyup = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="comment">/* keyCode返回一个键盘码 */</span></span><br><span class="line">    <span class="keyword">if</span>(event.keyCode==<span class="number">13</span>)&#123; <span class="comment">//回车键：13</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-实现淡入淡出效果的方法"><a href="#3-实现淡入淡出效果的方法" class="headerlink" title="3.实现淡入淡出效果的方法"></a>3.实现淡入淡出效果的方法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">is(<span class="string">&quot;:visible&quot;</span>) 判断一个元素是否可见</span><br><span class="line">fadeIn   淡入</span><br><span class="line">fadeOut  淡出</span><br><span class="line">fadeToggle() 淡入淡出</span><br><span class="line">fadeTo(speed,opacity,callback)</span><br></pre></td></tr></table></figure>
<h2 id="3-2获取窗口属性"><a href="#3-2获取窗口属性" class="headerlink" title="3-2获取窗口属性"></a>3-2获取窗口属性</h2><h4 id="1-获取可视区域的高度和宽度"><a href="#1-获取可视区域的高度和宽度" class="headerlink" title="1.获取可视区域的高度和宽度"></a>1.获取可视区域的高度和宽度</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.documentElement.clientWidth</span><br><span class="line"><span class="built_in">document</span>.documentElement.clientHeight</span><br></pre></td></tr></table></figure>
<h4 id="2-获取滚动区域的宽高"><a href="#2-获取滚动区域的宽高" class="headerlink" title="2.获取滚动区域的宽高"></a>2.获取滚动区域的宽高</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.documentElement.scrollWidth</span><br><span class="line"><span class="built_in">document</span>.documentElement.scrollHeight</span><br></pre></td></tr></table></figure>
<h4 id="3-鼠标距离X-Y轴的距离"><a href="#3-鼠标距离X-Y轴的距离" class="headerlink" title="3.鼠标距离X,Y轴的距离"></a>3.鼠标距离X,Y轴的距离</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">event.pageX</span><br><span class="line">event.clientX</span><br><span class="line"><span class="keyword">var</span> pageX = event.clientX; <span class="comment">//获取鼠标距离X轴距离</span></span><br><span class="line"><span class="keyword">var</span> pageY = event.clientY; <span class="comment">//获取鼠标距离y轴距离</span></span><br></pre></td></tr></table></figure>
<h4 id="4-判断滚动条是否到达底部"><a href="#4-判断滚动条是否到达底部" class="headerlink" title="4.判断滚动条是否到达底部"></a>4.判断滚动条是否到达底部</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- javascript --&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onReachBottom</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">/* 获取滚动区域的高度 */</span></span><br><span class="line">    <span class="keyword">var</span> dh = <span class="built_in">document</span>.documentElement.scrollHeight;</span><br><span class="line">    <span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> sh = <span class="built_in">Math</span>.ceil(<span class="built_in">document</span>.documentElement.scrollTop);</span><br><span class="line">        <span class="keyword">var</span> ah = <span class="built_in">document</span>.documentElement.clientHeight;</span><br><span class="line">        <span class="keyword">if</span>(sh+ah == dh)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;到达底部&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    onReachBottom()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- jquery --&gt;</span><br><span class="line"><span class="keyword">var</span> scrollHeight = $(<span class="built_in">document</span>).height();</span><br><span class="line"><span class="keyword">var</span> availHeight = $(<span class="built_in">window</span>).height();</span><br><span class="line">$(<span class="built_in">window</span>).scroll(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scrollTop = $(<span class="built_in">document</span>).scrollTop();</span><br><span class="line">    <span class="keyword">if</span>(scrollTop+availHeight==scrollHeight)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;到达底部&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="3-2-1回到顶部"><a href="#3-2-1回到顶部" class="headerlink" title="3-2-1回到顶部"></a>3-2-1回到顶部</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* javascript */</span></span><br><span class="line">test.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">document</span>.body.scrollTop = <span class="built_in">document</span>.documentElement.scrollTop = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* jquery */</span></span><br><span class="line">$(<span class="string">&quot;body,html&quot;</span>).animate(&#123;<span class="attr">scrollTop</span>:<span class="number">0</span>&#125;,<span class="number">2000</span>);</span><br></pre></td></tr></table></figure>
<h3 id="3-2-2-瀑布流"><a href="#3-2-2-瀑布流" class="headerlink" title="3-2-2 瀑布流"></a>3-2-2 瀑布流</h3><h4 id="1-手工瀑布流"><a href="#1-手工瀑布流" class="headerlink" title="1.手工瀑布流"></a>1.手工瀑布流</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE <span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">html</span> lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-<span class="number">8</span>&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; <span class="attribute">content</span>=&quot;<span class="attribute">width</span>=device-<span class="attribute">width</span>, <span class="attribute">initial</span>-scale=<span class="number">1.0</span>&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; <span class="attribute">content</span>=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;script <span class="attribute">src</span>=&quot;https://cdn.bootcss.com/jquery/<span class="number">3.4</span>.<span class="number">1</span>/jquery.js<span class="string">&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;title&gt;Document&lt;/title&gt;</span></span><br><span class="line"><span class="string">    &lt;style&gt;</span></span><br><span class="line"><span class="string">        *&#123;margin:0;padding:0&#125;</span></span><br><span class="line"><span class="string">        img&#123;</span></span><br><span class="line"><span class="string">            width:240px;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        .item&#123;</span></span><br><span class="line"><span class="string">            border:1px solid rgb(131, 130, 130);</span></span><br><span class="line"><span class="string">            padding:20px;</span></span><br><span class="line"><span class="string">            float: left;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &lt;/style&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;</span>content<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;</span>item<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;img src=&quot;</span>images/<span class="number">01</span>.jpg<span class="string">&quot; alt=&quot;</span><span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;</span>item<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;img src=&quot;</span>images/<span class="number">02</span>.jpg<span class="string">&quot; alt=&quot;</span><span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;</span>item<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;img src=&quot;</span>images/<span class="number">03</span>.jpg<span class="string">&quot; alt=&quot;</span><span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;</span>item<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;img src=&quot;</span>images/<span class="number">04</span>.jpg<span class="string">&quot; alt=&quot;</span><span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;</span>item<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;img src=&quot;</span>images/<span class="number">05</span>.jpg<span class="string">&quot; alt=&quot;</span><span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;</span>item<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;img src=&quot;</span>images/<span class="number">06</span>.jpg<span class="string">&quot; alt=&quot;</span><span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;</span>item<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;img src=&quot;</span>images/<span class="number">07</span>.jpg<span class="string">&quot; alt=&quot;</span><span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;</span>item<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;img src=&quot;</span>images/<span class="number">08</span>.jpg<span class="string">&quot; alt=&quot;</span><span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;</span>item<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;img src=&quot;</span>images/<span class="number">09</span>.jpg<span class="string">&quot; alt=&quot;</span><span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;</span>item<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;img src=&quot;</span>images/<span class="number">10</span>.jpg<span class="string">&quot; alt=&quot;</span><span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;</span>item<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;img src=&quot;</span>images/<span class="number">11</span>.jpg<span class="string">&quot; alt=&quot;</span><span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;</span>item<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;img src=&quot;</span>images/<span class="number">12</span>.jpg<span class="string">&quot; alt=&quot;</span><span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;script&gt;</span></span><br><span class="line"><span class="string">        /* 1.一排能放置几张图片 */</span></span><br><span class="line"><span class="string">        window.onload = function()&#123;</span></span><br><span class="line"><span class="string">            var ww = $(window).width()</span></span><br><span class="line"><span class="string">            var itemWidth = $(&quot;</span>.item<span class="string">&quot;).outerWidth();</span></span><br><span class="line"><span class="string">            var num =  Math.floor(ww/itemWidth);</span></span><br><span class="line"><span class="string">            /* 2.将第一排的高度放置在一个数组中 */</span></span><br><span class="line"><span class="string">            var arrHeight = []</span></span><br><span class="line"><span class="string">            $(&quot;</span>.item<span class="string">&quot;).each((index,item)=&gt;&#123;</span></span><br><span class="line"><span class="string">                if(index&lt;num)&#123;</span></span><br><span class="line"><span class="string">                    var itemHeight = $(item).outerHeight();</span></span><br><span class="line"><span class="string">                    arrHeight.push(itemHeight)</span></span><br><span class="line"><span class="string">                &#125;else&#123;</span></span><br><span class="line"><span class="string">                    /* 3.从高度最小的地方开发放置图片 */</span></span><br><span class="line"><span class="string">                    var minHeight = Math.min(...arrHeight);</span></span><br><span class="line"><span class="string">                    var minIndex = arrHeight.indexOf(minHeight);</span></span><br><span class="line"><span class="string">                    var offsetLeft = $(&quot;</span>.item<span class="string">&quot;).eq(minIndex).offset().left;</span></span><br><span class="line"><span class="string">                    $(&quot;</span>.item<span class="string">&quot;).eq(index).css(&#123;position:&#x27;absolute&#x27;,top:minHeight,left:offsetLeft&#125;)</span></span><br><span class="line"><span class="string">                    /* 4.重置数组中的最小高度 */</span></span><br><span class="line"><span class="string">                    arrHeight[minIndex]=minHeight +$(&quot;</span>.item<span class="string">&quot;).eq(index).outerHeight();</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;)</span></span><br><span class="line"><span class="string">            console.log(arrHeight)</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-从接口获取图片渲染成瀑布流"><a href="#2-从接口获取图片渲染成瀑布流" class="headerlink" title="2.从接口获取图片渲染成瀑布流"></a>2.从接口获取图片渲染成瀑布流</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE <span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">html</span> lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-<span class="number">8</span>&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; <span class="attribute">content</span>=&quot;<span class="attribute">width</span>=device-<span class="attribute">width</span>, <span class="attribute">initial</span>-scale=<span class="number">1.0</span>&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; <span class="attribute">content</span>=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;script <span class="attribute">src</span>=&quot;https://cdn.bootcss.com/jquery/<span class="number">3.4</span>.<span class="number">1</span>/jquery.js<span class="string">&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script src=&quot;</span>lib/base.js<span class="string">&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;title&gt;Document&lt;/title&gt;</span></span><br><span class="line"><span class="string">    &lt;style&gt;</span></span><br><span class="line"><span class="string">        * &#123;</span></span><br><span class="line"><span class="string">            margin: 0;</span></span><br><span class="line"><span class="string">            padding: 0</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        img &#123;</span></span><br><span class="line"><span class="string">            width: 240px;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        .item &#123;</span></span><br><span class="line"><span class="string">            border: 1px solid rgb(131, 130, 130);</span></span><br><span class="line"><span class="string">            padding: 20px;</span></span><br><span class="line"><span class="string">            float: left;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &lt;/style&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;</span>content<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;</span>item<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;img src=&quot;</span>images/<span class="number">01</span>.jpg<span class="string">&quot; alt=&quot;</span><span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;</span>item<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;img src=&quot;</span>images/<span class="number">02</span>.jpg<span class="string">&quot; alt=&quot;</span><span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;</span>item<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;img src=&quot;</span>images/<span class="number">03</span>.jpg<span class="string">&quot; alt=&quot;</span><span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;</span>item<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;img src=&quot;</span>images/<span class="number">04</span>.jpg<span class="string">&quot; alt=&quot;</span><span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;</span>item<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;img src=&quot;</span>images/<span class="number">05</span>.jpg<span class="string">&quot; alt=&quot;</span><span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;</span>item<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;img src=&quot;</span>images/<span class="number">06</span>.jpg<span class="string">&quot; alt=&quot;</span><span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;</span>item<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;img src=&quot;</span>images/<span class="number">07</span>.jpg<span class="string">&quot; alt=&quot;</span><span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;</span>item<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;img src=&quot;</span>images/<span class="number">08</span>.jpg<span class="string">&quot; alt=&quot;</span><span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;</span>item<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;img src=&quot;</span>images/<span class="number">09</span>.jpg<span class="string">&quot; alt=&quot;</span><span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;</span>item<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;img src=&quot;</span>images/<span class="number">10</span>.jpg<span class="string">&quot; alt=&quot;</span><span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;</span>item<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;img src=&quot;</span>images/<span class="number">11</span>.jpg<span class="string">&quot; alt=&quot;</span><span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;</span>item<span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;img src=&quot;</span>images/<span class="number">12</span>.jpg<span class="string">&quot; alt=&quot;</span><span class="string">&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;script&gt;</span></span><br><span class="line"><span class="string">        /* 假设是从服务器取得的数据 */</span></span><br><span class="line"><span class="string">        var url = &#123;</span></span><br><span class="line"><span class="string">            dataUrl: [&#123;</span></span><br><span class="line"><span class="string">                src: &quot;</span><span class="number">01</span>.jpg<span class="string">&quot;</span></span><br><span class="line"><span class="string">            &#125;, &#123;</span></span><br><span class="line"><span class="string">                src: &quot;</span><span class="number">02</span>.jpg<span class="string">&quot;</span></span><br><span class="line"><span class="string">            &#125;, &#123;</span></span><br><span class="line"><span class="string">                src: &quot;</span><span class="number">03</span>.jpg<span class="string">&quot;</span></span><br><span class="line"><span class="string">            &#125;, &#123;</span></span><br><span class="line"><span class="string">                src: &quot;</span><span class="number">04</span>.jpg<span class="string">&quot;</span></span><br><span class="line"><span class="string">            &#125;, &#123;</span></span><br><span class="line"><span class="string">                src: &quot;</span><span class="number">05</span>.jpg<span class="string">&quot;</span></span><br><span class="line"><span class="string">            &#125;, &#123;</span></span><br><span class="line"><span class="string">                src: &quot;</span><span class="number">06</span>.jpg<span class="string">&quot;</span></span><br><span class="line"><span class="string">            &#125;, &#123;</span></span><br><span class="line"><span class="string">                src: &quot;</span><span class="number">07</span>.jpg<span class="string">&quot;</span></span><br><span class="line"><span class="string">            &#125;, &#123;</span></span><br><span class="line"><span class="string">                src: &quot;</span><span class="number">08</span>.jpg<span class="string">&quot;</span></span><br><span class="line"><span class="string">            &#125;, &#123;</span></span><br><span class="line"><span class="string">                src: &quot;</span><span class="number">09</span>.jpg<span class="string">&quot;</span></span><br><span class="line"><span class="string">            &#125;, &#123;</span></span><br><span class="line"><span class="string">                src: &quot;</span><span class="number">10</span>.jpg<span class="string">&quot;</span></span><br><span class="line"><span class="string">            &#125;, &#123;</span></span><br><span class="line"><span class="string">                src: &quot;</span><span class="number">11</span>.jpg<span class="string">&quot;</span></span><br><span class="line"><span class="string">            &#125;, &#123;</span></span><br><span class="line"><span class="string">                src: &quot;</span><span class="number">12</span>.jpg<span class="string">&quot;</span></span><br><span class="line"><span class="string">            &#125;]</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        /* 1.一排能放置几张图片 */</span></span><br><span class="line"><span class="string">        window.onload = function () &#123;</span></span><br><span class="line"><span class="string">            place_img();</span></span><br><span class="line"><span class="string">            $(window).scroll(function()&#123;</span></span><br><span class="line"><span class="string">                if(onReachBottom())&#123;</span></span><br><span class="line"><span class="string">                    url.dataUrl.forEach(item=&gt;&#123;</span></span><br><span class="line"><span class="string">                        let list = `&lt;div class=&quot;</span>item<span class="string">&quot;&gt;&lt;img  src=&quot;</span>images/$&#123;item.src&#125;&quot;/&gt;&lt;/<span class="selector-tag">div</span>&gt;`</span><br><span class="line">                        $(&quot;<span class="selector-class">.content</span>&quot;)<span class="selector-class">.append</span>(list);</span><br><span class="line">                        place_img()</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        function place_img() &#123;</span><br><span class="line">            <span class="selector-tag">var</span> ww = $(window)<span class="selector-class">.width</span>()</span><br><span class="line">            <span class="selector-tag">var</span> itemWidth = $(&quot;<span class="selector-class">.item</span>&quot;)<span class="selector-class">.outerWidth</span>();</span><br><span class="line">            <span class="selector-tag">var</span> num = Math<span class="selector-class">.floor</span>(ww / itemWidth);</span><br><span class="line">            <span class="comment">/* 2.将第一排的高度放置在一个数组中 */</span></span><br><span class="line">            <span class="selector-tag">var</span> arrHeight = <span class="selector-attr">[]</span></span><br><span class="line">            $(&quot;<span class="selector-class">.item</span>&quot;)<span class="selector-class">.each</span>((index, item) =&gt; &#123;</span><br><span class="line">                if (index &lt; num) &#123;</span><br><span class="line">                    <span class="selector-tag">var</span> itemHeight = $(item)<span class="selector-class">.outerHeight</span>();</span><br><span class="line">                    arrHeight<span class="selector-class">.push</span>(itemHeight)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    <span class="comment">/* 3.从高度最小的地方开发放置图片 */</span></span><br><span class="line">                    <span class="selector-tag">var</span> minHeight = Math<span class="selector-class">.min</span>(..<span class="selector-class">.arrHeight</span>);</span><br><span class="line">                    <span class="selector-tag">var</span> minIndex = arrHeight<span class="selector-class">.indexOf</span>(minHeight);</span><br><span class="line">                    <span class="selector-tag">var</span> offsetLeft = $(&quot;<span class="selector-class">.item</span>&quot;)<span class="selector-class">.eq</span>(minIndex)<span class="selector-class">.offset</span>()<span class="selector-class">.left</span>;</span><br><span class="line">                    $(&quot;<span class="selector-class">.item</span>&quot;)<span class="selector-class">.eq</span>(index)<span class="selector-class">.css</span>(&#123; <span class="attribute">position</span>: <span class="string">&#x27;absolute&#x27;</span>, top: minHeight, left: offsetLeft &#125;)</span><br><span class="line">                    <span class="comment">/* 4.重置数组中的最小高度 */</span></span><br><span class="line">                    arrHeight<span class="selector-attr">[minIndex]</span> = minHeight + $(&quot;<span class="selector-class">.item</span>&quot;)<span class="selector-class">.eq</span>(index)<span class="selector-class">.outerHeight</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/<span class="selector-tag">body</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;/<span class="selector-tag">html</span>&gt;</span><br><span class="line"></span><br><span class="line">//封装JS</span><br><span class="line">function onReachBottom() &#123;</span><br><span class="line">    <span class="selector-tag">var</span> dh = $(document)<span class="selector-class">.height</span>();</span><br><span class="line">    <span class="selector-tag">var</span> sh = $(window)<span class="selector-class">.scrollTop</span>();</span><br><span class="line">    <span class="selector-tag">var</span> wh = $(window)<span class="selector-class">.height</span>();</span><br><span class="line">    return (Math<span class="selector-class">.ceil</span>(sh + wh) == dh) ? true : false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3事件冒泡"><a href="#3-3事件冒泡" class="headerlink" title="3-3事件冒泡"></a>3-3事件冒泡</h2><h4 id="1-事件冒泡"><a href="#1-事件冒泡" class="headerlink" title="1.事件冒泡"></a>1.事件冒泡</h4><ul>
<li>起因：父元素和子元素绑定了相同的事件</li>
<li>结果：子元素的事件执行完后父元素的事件也会触发<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 阻止事件冒泡(子元素父元素事件都要调用) */</span></span><br><span class="line">event.stopPropagation()</span><br></pre></td></tr></table></figure>
<h4 id="2-事件捕获"><a href="#2-事件捕获" class="headerlink" title="2.事件捕获"></a>2.事件捕获</h4></li>
<li>从不太具体的节点 最早接收事件，而最具体的节点 最后接收事件<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">addEventListener(<span class="string">&#x27;event&#x27;</span>,<span class="function"><span class="keyword">function</span>,<span class="title">boolean</span>)</span></span><br><span class="line"><span class="function">	-<span class="title">boolean</span>取值决定事件</span></span><br><span class="line"><span class="function">  	-<span class="title">true</span> 事件捕获</span></span><br><span class="line"><span class="function">  	-<span class="title">false</span> 事件冒泡</span></span><br></pre></td></tr></table></figure>
<h2 id="3-4异常处理"><a href="#3-4异常处理" class="headerlink" title="3-4异常处理"></a>3-4异常处理</h2><h4 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h4></li>
<li>try-catch-throw<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//try中的语句错误,将会执行catch中的语句</span></span><br><span class="line">     alertt(<span class="string">&quot;good&quot;</span>)</span><br><span class="line">&#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">     alert(<span class="string">&quot;hello&quot;</span>)；</span><br><span class="line">     <span class="comment">//err.message输出错误的信息</span></span><br><span class="line">     <span class="comment">//alert(err.message)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>()&#123;</span><br><span class="line">        <span class="comment">/* throw可以自定义错误并传给err */</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;输入的值不能为空&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    alert(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB---单机部署</title>
    <url>/2021/08/02/MongoDB--deplpy/</url>
    <content><![CDATA[<h2 id="Windows系统中的安装启动"><a href="#Windows系统中的安装启动" class="headerlink" title="Windows系统中的安装启动"></a>Windows系统中的安装启动</h2><h5 id="第一步：下载安装包"><a href="#第一步：下载安装包" class="headerlink" title="第一步：下载安装包"></a>第一步：下载安装包</h5><p><a href="https://www.mongodb.com/try/download/community">https://www.mongodb.com/try/download/community</a><br><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/mongodb.png"></p>
<p>根据上图所示下载<code>zip</code>包<br>提示：版本的选择：<br>MongoDB的版本命名规范如：ｘ．ｙ．ｚ<br>ｙ为奇数时表示当前版本为开发版<br>ｙ为偶数时表示当前版本为稳定版<br>ｚ是修正版本号，数字越大越好</p>
<h5 id="第二步：解压安装启动"><a href="#第二步：解压安装启动" class="headerlink" title="第二步：解压安装启动"></a>第二步：解压安装启动</h5><p>将压缩包解压大一个目录中。<br>在解压目录中，手动建立一个目录用于存放数据文件，如data/db</p>
<p>方式1：命令行参数方式启动服务<br>在bin目录中打开命令提示符，输入如下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongod --dbpath=..\data\db</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/conf.png"><br>mongoDB的默认端口是27017</p>
<p>方式2：配置文件方式启动服务<br>在解压目录中新建<code>config</code>文件夹，该文件夹中新建配置文件<code>mongod.conf</code>，内如参考如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">storage:</span></span><br><span class="line">	<span class="comment">#The directory where the mongod instance stores its data.Default Value is &quot;data\db&quot; on windows</span></span><br><span class="line">	<span class="attr">dbPath:</span> <span class="string">D:\MongoDB\data</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongod -f ../config/mongod.conf</span><br><span class="line">或</span><br><span class="line">mongod --config ../config/mongod.conf</span><br></pre></td></tr></table></figure>

<h2 id="Shell链接（mongo命令）"><a href="#Shell链接（mongo命令）" class="headerlink" title="Shell链接（mongo命令）"></a>Shell链接（mongo命令）</h2><p>在命令提示符输入以下shell命令即可完成登录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongo</span><br></pre></td></tr></table></figure>
<p>查看已经有的数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show databases</span><br></pre></td></tr></table></figure>
<p>退出mongodb</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>
<p>更多参数可以通过帮助查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongo --help</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB--文档的更多查询</title>
    <url>/2021/08/02/MongoDB--file_more/</url>
    <content><![CDATA[<h2 id="正则的复杂条件查询"><a href="#正则的复杂条件查询" class="headerlink" title="正则的复杂条件查询"></a>正则的复杂条件查询</h2><p>MongoDB的模糊查询是通过<strong>正则表达式</strong>方式实现的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.集合名称.find(&#123;字段: /正则表达式/&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>提示：</strong> 正则表达式是js的语法，直接量的写法<br>例如：要查询评论内容包容<code>的</code>的所有文档：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.document.find(&#123;content: /的/&#125;)</span><br></pre></td></tr></table></figure>
<p>例如：要查询评论内容中以<code>有些</code>开头：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.document.find(&#123;content: /^有些/&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="比较查询"><a href="#比较查询" class="headerlink" title="比较查询"></a>比较查询</h2><p>&lt;,&lt;=,&gt;,&gt;= ,!=这个操作符也是很常用的，格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.集合名称.find(&#123;&quot;field&quot;: &#123; $gt: value &#125;&#125;) // 大于： field &gt; value</span><br><span class="line">db.集合名称.find(&#123;&quot;field&quot;: &#123; $lt: value &#125;&#125;) // 小于： field &lt; value</span><br><span class="line">db.集合名称.find(&#123;&quot;field&quot;: &#123; $gte: value &#125;&#125;) // 大于等于： field &gt;= value</span><br><span class="line">db.集合名称.find(&#123;&quot;field&quot;: &#123; $lte: value &#125;&#125;) // 小于等于： field &lt;= value</span><br><span class="line">db.集合名称.find(&#123;&quot;field&quot;: &#123; $ne: value &#125;&#125;) // 不等于： field != value</span><br></pre></td></tr></table></figure>
<p>例如：查询<code>likenum</code>字段数据大于<code>700</code>的记录:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.document.find(&#123;likenum: &#123; $gt: NumberInt(700)&#125;&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="包含查询"><a href="#包含查询" class="headerlink" title="包含查询"></a>包含查询</h2><p>包含使用<code>$in</code>操作符<br>例如：查询<code>userid</code>字段包含1003或1004的文档</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.document.find(&#123;userid: &#123; $in: [&quot;1003&quot;, &quot;1004&quot;]&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>不包含使用<code>$nin</code>操作符<br>例如：查询<code>userid</code>字段不包含1003或1004的文档</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.document.find(&#123;userid: &#123; $nin: [&quot;1003&quot;, &quot;1004&quot;]&#125;&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="条件连接查询"><a href="#条件连接查询" class="headerlink" title="条件连接查询"></a>条件连接查询</h2><p>我们如果需要查询同时满足两个以上条件，需要使用<code>$and</code>操作符将条件进行关联<br>格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">and:[&#123;&#125;,&#123;&#125;,&#123;&#125;]</span></span><br></pre></td></tr></table></figure>
<p>例如：查询<code>likenum</code>字段包含大于等于700并且小于2000的文档：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.document.find(&#123;$and:[&#123;likenum: &#123; $gte: NumberInt(700)&#125;&#125;,&#123;likenum: &#123; $lt: NumberInt(2000)&#125;&#125;]&#125;)</span><br></pre></td></tr></table></figure>

<p>如果两个以上条件之间是或者关系，需要使用<code>$or</code>操作符将条件进行关<br>联<br>例如：查询<code>likenum</code>字段包含大于等于700或小于2000的文档：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.document.find(&#123;$or:[&#123;likenum: &#123; $gte: NumberInt(700)&#125;&#125;,&#123;likenum: &#123; $lt: NumberInt(2000)&#125;&#125;]&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB--文档基本CRUD</title>
    <url>/2021/08/02/MongoDB--file_CRUD/</url>
    <content><![CDATA[<h2 id="文档基本CRUD"><a href="#文档基本CRUD" class="headerlink" title="文档基本CRUD"></a>文档基本CRUD</h2><p>文档（document）的数据库和JSON基本一样。<br>所有存储在集合中的数据都是BSON格式</p>
<blockquote>
<p>“BSON是一种类json的一种二进制形式的存储格式,简称Binary JSON,它和JSON一样,支持内嵌的文档对象和数组对象,但是BSON有JSON没有的一些数据类型,如Date和BinData类型。”</p>
</blockquote>
<h3 id="文档的插入"><a href="#文档的插入" class="headerlink" title="文档的插入"></a>文档的插入</h3><p>(1) 单个文档插入<br>使用 <code>insert()</code> 或 <code>save()</code> 方法向集合中插入文档，语法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.集合名字.insert(</span><br><span class="line">   &lt;document or array od documents&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">       writeConcern: &lt;document&gt;,</span><br><span class="line">       ordered: &lt;boolean&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>参数:</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>document</td>
<td>document or array</td>
<td>document：要写入的文档。</td>
</tr>
<tr>
<td>writeConcern</td>
<td>document</td>
<td>写入策略，默认为 1，即要求确认写操作，0 是不要求。</td>
</tr>
<tr>
<td>ordered</td>
<td>boolean</td>
<td>指定是否按顺序写入，默认 true，按顺序写入。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>document</td>
<td>document or array</td>
<td>document：要写入的文档。</td>
</tr>
<tr>
<td></td>
<td>document</td>
<td>写入策略，默认为 1，即要求确认写操作，0 是不要求。</td>
</tr>
<tr>
<td>ordered</td>
<td>boolean</td>
<td>指定是否按顺序写入，默认 true，按顺序写入。</td>
</tr>
</tbody></table>
<p><strong>【示例】</strong><br>要向document的集合（表）中插入一条测试数据:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.document.insert(&#123;&quot;articleid&quot;: &quot;100000&quot;,&quot;content&quot;: &quot;今天天气真好，阳光明媚&quot;,&quot;userid&quot;: &quot;1001&quot;,&quot;nickname&quot;: &quot;Rose&quot;,&quot;createdatetime&quot;: new Date(),&quot;likenum&quot;: NumberInt(10),&quot;state&quot;: null&#125;)</span><br></pre></td></tr></table></figure>
<p>提示:</p>
<ul>
<li>comment集合如果不存在，则会隐式创建</li>
<li>mongo中的数字，默认情况下是double类型，如果存整型，必须使用函数<code>NumberInt(整型数字)</code>，否则取出来就有问题</li>
<li>插入当前日期使用<code>new Date()</code></li>
<li>插入的数据没有指定<code>_id</code>，会自动生成主键值</li>
<li>如果某字段没有值，可以赋值为null，或不写该字段</li>
</ul>
<p>执行后，如下，说明插入一个数据成功了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>文档中的键/值对是有序的</li>
<li>文档中的值不仅可以是在双引号里面的字符，还可以是其他几种数据类型（甚至可以是整个嵌入的文档）</li>
<li>MongoDB区分类型和大小写</li>
<li>MongoDB的文档不可以有重复的键</li>
<li>文档的键是字符串，除了少数例外情况，键可以是任意UTF-8字符<br>文档命名规范：</li>
<li>键不能包含\0字符（空字符），因为这个字符表示键的结束；</li>
<li>不能包含$和.，因为.和$是被保留的，只能在特定环境下使用；</li>
<li>以下划线”_”开头的键是保留的（不是严格要求的）</li>
</ul>
<p>(2) 批量插入<br>语法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.集合名字.insertMany(</span><br><span class="line">   [&lt;document1&gt;, &lt;document2&gt;], ...],</span><br><span class="line">   &#123;</span><br><span class="line">       writeConcern: &lt;document&gt;,</span><br><span class="line">       ordered: &lt;boolean&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>参数:</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>document</td>
<td>document or array</td>
<td>document：要写入的文档。</td>
</tr>
<tr>
<td>writeConcern</td>
<td>document</td>
<td>写入策略，默认为 1，即要求确认写操作，0 是不要求。</td>
</tr>
<tr>
<td>ordered</td>
<td>boolean</td>
<td>指定是否按顺序写入，默认 true，按顺序写入。</td>
</tr>
</tbody></table>
<p><strong>【示例】</strong><br>批量插入多条文档的评论：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.document.insertMany([</span><br><span class="line">  &#123;&quot;_id&quot;: &quot;1&quot;, &quot;articleid&quot;: &quot;100001&quot;,&quot;content&quot;: &quot;给大家讲一下，这个歌单是私人定制，根据你听的歌来制定的歌单，所以会有你收藏的歌，每个人都不一样的。&quot;,&quot;userid&quot;: &quot;1002&quot;,&quot;nickname&quot;: &quot;春天吃了自己&quot;,&quot;createdatetime&quot;: new Date(&quot;2020-1-19T22:08:15.522z&quot;),&quot;likenum&quot;: NumberInt(1000),&quot;state&quot;: &quot;1&quot;&#125;,</span><br><span class="line">  &#123;&quot;_id&quot;: &quot;2&quot;, &quot;articleid&quot;: &quot;100001&quot;,&quot;content&quot;: &quot;我们收藏的是同一个歌单，听的是不同的歌曲。&quot;,&quot;userid&quot;: &quot;1003&quot;,&quot;nickname&quot;: &quot;景随风&quot;,&quot;createdatetime&quot;: new Date(&quot;2020-1-20T23:23:12.485z&quot;),&quot;likenum&quot;: NumberInt(8888),&quot;state&quot;: &quot;1&quot;&#125;,</span><br><span class="line">  &#123;&quot;_id&quot;: &quot;3&quot;, &quot;articleid&quot;: &quot;100001&quot;,&quot;content&quot;: &quot;有些歌你已经忘了,网易云还帮你记着.&quot;,&quot;userid&quot;: &quot;1004&quot;,&quot;nickname&quot;: &quot;低温低气压&quot;,&quot;createdatetime&quot;: new Date(&quot;2020-2-29-T08:18:35.288z&quot;),&quot;likenum&quot;: NumberInt(999),&quot;state&quot;: &quot;1&quot;&#125;,</span><br><span class="line">  &#123;&quot;_id&quot;: &quot;4&quot;, &quot;articleid&quot;: &quot;100001&quot;,&quot;content&quot;: &quot;今天从《Let Me Love You》听起&quot;,&quot;userid&quot;: &quot;1005&quot;,&quot;nickname&quot;: &quot;银牙不是熊猫&quot;,&quot;createdatetime&quot;: new Date(),&quot;likenum&quot;: NumberInt(),&quot;state&quot;: &quot;1&quot;&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<h5 id="文档插入使用try-catch"><a href="#文档插入使用try-catch" class="headerlink" title="文档插入使用try catch"></a>文档插入使用try catch</h5><p>因为批量插入由于数据较多容易出现失败，因此，可以使用try catch进行异常捕捉处理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">db.document.insertMany([</span><br><span class="line">  &#123;&quot;_id&quot;: &quot;5&quot;, &quot;articleid&quot;: &quot;100001&quot;,&quot;content&quot;: &quot;给大家讲一下，这个歌单是私人定制，根据你听的歌来制定的歌单，所以会有你收藏的歌，每个人都不一样的。&quot;,&quot;userid&quot;: &quot;1002&quot;,&quot;nickname&quot;: &quot;春天吃了自己&quot;,&quot;createdatetime&quot;: new Date(&quot;2020-1-19T22:08:15.522z&quot;),&quot;likenum&quot;: NumberInt(1000),&quot;state&quot;: &quot;1&quot;&#125;,</span><br><span class="line">  &#123;&quot;_id&quot;: &quot;6&quot;, &quot;articleid&quot;: &quot;100001&quot;,&quot;content&quot;: &quot;我们收藏的是同一个歌单，听的是不同的歌曲。&quot;,&quot;userid&quot;: &quot;1003&quot;,&quot;nickname&quot;: &quot;景随风&quot;,&quot;createdatetime&quot;: new Date(&quot;2020-1-20T23:23:12.485z&quot;),&quot;likenum&quot;: NumberInt(8888),&quot;state&quot;: &quot;1&quot;&#125;</span><br><span class="line">])</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">  print(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文档的基本查询"><a href="#文档的基本查询" class="headerlink" title="文档的基本查询"></a>文档的基本查询</h3><p>查询数据的语法格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.集合名字.find(&lt;query&gt;, &lt;projection&gt;)</span><br></pre></td></tr></table></figure>

<p>参数:</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>query</td>
<td>document</td>
<td>可选，使用查询操作符指定查询条件。</td>
</tr>
<tr>
<td>projection</td>
<td>document</td>
<td>可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。</td>
</tr>
</tbody></table>
<p><strong>【示例】</strong><br>(1) 查询所有<br>如果我们要查询<code>document</code>集合的所有的文档</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.document.find()</span><br><span class="line">或</span><br><span class="line">db.document.find(&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>这里你会发现每条文档会有一个叫<code>_id</code>的字段，这个相当于我们原来关系数据中表的主键，当你在插入文档记录时没有指定该字段，MongoDB会自动创建，其类型是ObjectID类型。</p>
<p>如果我们在插入文档记录时该字段也可以，其类型是ObjectID类型，也可以是MongoDB支持的任意类型。</p>
<p>如果我想按一定条件来查询，比如我想查询<code>userid为1003</code>的记录，怎么办？很简单！只需要在<code>find()</code>中田间参数即可，参数也是json格式，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.document.find(&#123;userid: &#x27;1003&#x27;&#125;)</span><br></pre></td></tr></table></figure>

<p>如果你只需要返回符合的第一条数据，我们可以使用<code>findOne</code>命令来实现，语法和<code>find</code>一样。<br>如：查询用户编号是1003的记录，但是最多返回条件的第一条记录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.document.findOne(&#123;userid: &#x27;1003&#x27;&#125;)</span><br></pre></td></tr></table></figure>

<p>（2）投影查询（Projection Query）<br>如果要查询结果只返回部分字段，则需要使用投影查询（不显示所有字段，只显示指定的字段）<br>如：查询结果只显示<code>_id、userid、nickname</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.document.find(&#123;userid: &#x27;1003&#x27;&#125;,&#123;userid: 1, nickname: 1&#125;)</span><br></pre></td></tr></table></figure>
<p>默认<code>_id</code>会显示<br>如：查询结果只显示<code>userid、nickname</code>，不显示<code>_id</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.document.find(&#123;userid: &#x27;1003&#x27;&#125;,&#123;userid: 1, nickname: 1, _id: 0&#125;)</span><br></pre></td></tr></table></figure>
<p>在例如：查询所有数据，但只显示<code>_id、userid、nickname</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.document.find(&#123;&#125;,&#123;userid: 1, nickname: 1&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="文档的更新"><a href="#文档的更新" class="headerlink" title="文档的更新"></a>文档的更新</h3><p>更新文档的语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.集合名字.update(query, update, options)</span><br><span class="line">db.集合名字.update(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &lt;update&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="attr">upsert</span>: &lt;boolean&gt;,</span><br><span class="line">     multi: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;<span class="built_in">document</span>&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>参数:</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>query</td>
<td>document</td>
<td>update的查询条件，类似sql update查询内where后面的。</td>
</tr>
<tr>
<td>update</td>
<td>document or pipeline</td>
<td>update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的</td>
</tr>
<tr>
<td>upsert</td>
<td>boolean</td>
<td>可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。</td>
</tr>
<tr>
<td>multi</td>
<td>boolean</td>
<td>可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。</td>
</tr>
<tr>
<td>writeConcern</td>
<td>document</td>
<td>可选，抛出异常的级别。</td>
</tr>
</tbody></table>
<p><strong>【示例】</strong><br>(1) 覆盖的修改<br>如果我们想修改<code>_id</code>为1的记录，点赞量为<code>1001</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.document.update(&#123;_id: &quot;1&quot;&#125;,&#123;likenum: NumberInt(1001)&#125;)</span><br></pre></td></tr></table></figure>
<p>执行后，我们发现，这条文档除了<code>likenum</code>字段其它字段都不见了。</p>
<p>(2)局部修改<br>为了解决这个问题，我们需要使用修改器<code>$set</code>来实现<br>如果我们想修改<code>_id</code>为2的记录，点赞量为<code>8812</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.document.update(&#123;_id: &quot;2&quot;&#125;,&#123;$set:&#123;likenum: NumberInt(8812)&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>(3)批量的修改<br>更新所有用户为<code>1003</code>的用户的昵称为<code>moppet</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认只修改第一条数据</span></span><br><span class="line">db.document.update(&#123;<span class="attr">userid</span>: <span class="string">&quot;1003&quot;</span>&#125;,&#123;<span class="attr">$set</span>:&#123;<span class="attr">nickname</span>: <span class="string">&quot;moppet&quot;</span>&#125;&#125;)</span><br><span class="line"><span class="comment">// 修改所有符合条件的数据</span></span><br><span class="line">db.document.update(&#123;<span class="attr">userid</span>: <span class="string">&quot;1003&quot;</span>&#125;,&#123;<span class="attr">$set</span>:&#123;<span class="attr">nickname</span>: <span class="string">&quot;moppet&quot;</span>&#125;&#125;,&#123;<span class="attr">multi</span>:<span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>(4) 列值增长的修改<br>如果我们想要实现对某列值在原有的基础上进行增加或减少，可以使用<code>$inc</code>运算符来实现<br>需求：对3号数据的点赞数，每次递增1</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.document.update(&#123;_id: &quot;3&quot;&#125;,&#123;$inc:&#123;likenum: NumberInt(1)&#125;&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><p>删除文档的语法结构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.集合名词.remove(条件)</span><br></pre></td></tr></table></figure>
<p>如果想删除全部数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.document.remove(&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>如果想删除<code>_id=1</code>的记录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.document.remove(&#123;_id: &quot;1&quot;&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB--文档的分页查询</title>
    <url>/2021/08/02/MongoDB--file_paging/</url>
    <content><![CDATA[<h2 id="统计查询"><a href="#统计查询" class="headerlink" title="统计查询"></a>统计查询</h2><p>统计查询使用<code>count()</code>方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.集合名字.count(query, options)</span><br></pre></td></tr></table></figure>
<p>参数:</p>
<table>
<thead>
<tr>
<th align="left">Parameter</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">query</td>
<td>document</td>
<td>查询选择的条件</td>
</tr>
<tr>
<td align="left">options</td>
<td>document</td>
<td>可选。用于修改计数的额外选项。</td>
</tr>
</tbody></table>
<p><strong>【示例】</strong><br>(1) 统计所有的记录数<br>统计<code>document</code>集合的所有的记录数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.document.count()</span><br></pre></td></tr></table></figure>

<p>(2) 按条件统计记录数<br>统计<code>userid为1003</code>的所有的记录数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.document.count(&#123;userid: &quot;1003&quot;&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="分页列表查询"><a href="#分页列表查询" class="headerlink" title="分页列表查询"></a>分页列表查询</h2><p>可以使用<code>limit()</code>方法来读取指定数量的数据，使用<code>skip()</code>方法来跳过指定数量的数据。<br>基本语法如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.集合名字.find().limit(NUMBER).skip(NUMBER)</span><br></pre></td></tr></table></figure>

<p>如果你想返回指定条数的记录，可以在<code>fin()</code>方法后调用<code>limit()</code>来返回结果（TopN），默认值20</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.document.find().limit(3)  // 显示前3条数据</span><br></pre></td></tr></table></figure>
<p><code>skip()</code>方法同样接受一个数字参数作为跳过的记录条数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.document.find().skip(3) // 不显示前3条数据</span><br></pre></td></tr></table></figure>

<p>分页查询：需求：每页2歌，第二页开始：跳过前两条数，按着值显示3条和4条数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 第一页</span><br><span class="line">db.document.find().skip(0).limit(2) // 显示前2条数据</span><br><span class="line">// 第二页</span><br><span class="line">db.document.find().skip(2).limit(2) // 不显示前2条数据</span><br><span class="line">// 第三页</span><br><span class="line">db.document.find().skip(4).limit(2) // 不显示前4条数据</span><br></pre></td></tr></table></figure>

<h2 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h2><p><code>sort()</code>方法对数据进行排序，<code>sort()</code>方法可以通过参数指定排序的字段，并使用<code>1</code>和<code>-1</code>来指定排序的方式，其中<code>1</code>为升序排列，<code>-1</code>为降序排列。<br>基本语法如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.集合名字.find().sort(&#123;KEY:1&#125;)</span><br><span class="line">或</span><br><span class="line">db.集合名字.find().sort(排序方式)</span><br></pre></td></tr></table></figure>
<p>例如：<br>对<code>userid</code>降序排列，并对<code>likenum</code>升序排列</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.document.find().sort(&#123;userid: -1, likenum: 1&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>提示：</strong> <code>skip()</code>，<code>limit()</code>，<code>sort()</code>三个放在一起执行的时候，执行的顺序先<code>sort()</code>，然后是<code>skip()</code>，最后是显示的<code>limit()</code>，和命令编写的顺序无关。</p>
</blockquote>
]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB--索引-Index</title>
    <url>/2021/08/02/MongoDB--index/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>索引支持在MongoDB中高效地执行查询。如果没有索引，MongoDB必须执行全集合扫描，即扫描集合中的每个文档,以选择与查询语句匹配的文档。这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的。</p>
<p>如果查询存在适当的索引，MongoDB可以使用该索引限制必须检查的文档数。</p>
<p>索引是特殊的数据结构，它以易于遍历的形式存储集合数据集的一小部分。</p>
<p>索引存储特定字段或一组字段的值，按字段值排序。索引项的排序支持有效的相等匹配和基于范围的查询操作。此外，MongoDB还可以使用索引中的排序返回排序结果。</p>
<p>官网文档: <a href="https://docs.mongodb.com/manual/indexes/">https://docs.mongodb.com/manual/indexes/</a></p>
<p>了解:<br>MongoDB索引使用B树数据结构（确切的说是B-Tree,MySQL是B+Tree)</p>
<h2 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h2><h4 id="单字段索引"><a href="#单字段索引" class="headerlink" title="单字段索引"></a>单字段索引</h4><p>MongoDB支持在文档的单个字段上创建用户定义的升序/降序索引，称为单字段索引(Single Field lndex)。</p>
<p>对于单个字段索引和排序操作，索引键的排序顺序(即升序或降序)并不重要，因为MongoDB可以在任何方向上遍历索引。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/sin.png"></p>
<h4 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h4><p>MongoDB支持多个字段的用户定义索引，即复合索引(Compound Index)</p>
<p>复合索引中列出的字段顺序具有重要的意义。(eg:如果复合索引由{userid:1，score:-1}组成，则索引首先按照userid正序排序，然后在每个userid的值内，再按照score倒序排序)</p>
<p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/com.png"></p>
<h4 id="其它索引"><a href="#其它索引" class="headerlink" title="其它索引"></a>其它索引</h4><p>地理空间索引(Geospatial Index)、文本索引(Text Indexes)、哈希索引(Hashed  Indexes)</p>
<p>地理空间索引（Geospatial Index） 为了支持对地理空间坐标数据的有效查询，MongoDB提供了两种特殊的索引：返回结果时使用平面几何的二维索引和返回结果时使用球面 几何的二维球面索引。</p>
<p>文本索引（Text Indexes） MongoDB提供了一种文本索引类型，支持在集合中搜索字符串内容。这些文本索引不存储特定于语言的停止词（例如“the”、“a”、“or”）， 而将集合中的词作为词干，只存储根词。</p>
<p>哈希索引（Hashed Indexes） 为了支持基于散列的分片，MongoDB提供了散列索引类型，它对字段值的散列进行索引。这些索引在其范围内的值分布更加随机，但只支 持相等匹配，不支持基于范围的查询。</p>
<h2 id="索引的管理操作"><a href="#索引的管理操作" class="headerlink" title="索引的管理操作"></a>索引的管理操作</h2><h4 id="索引的查看"><a href="#索引的查看" class="headerlink" title="索引的查看"></a>索引的查看</h4><blockquote>
<p><strong>说明：</strong><br>    返回一个集合中的所有索引的数组</p>
</blockquote>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.集合名字.getIndexes()</span><br></pre></td></tr></table></figure>
<p><strong>【示例】</strong><br>查看document集合中所有的所有索引情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> db.document.getIndexes()</span></span><br><span class="line">[</span><br><span class="line">        &#123;</span><br><span class="line">                &quot;v&quot; : 2,</span><br><span class="line">                &quot;key&quot; : &#123;</span><br><span class="line">                        &quot;_id&quot; : 1</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;name&quot; : &quot;_id_&quot;,</span><br><span class="line">                &quot;ns&quot; : &quot;articledb.document&quot;</span><br><span class="line">        &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>结果中显示的是默认<code>_id</code>索引：<br>MongoDB在创建集合的过程中，在<code> _id</code> 字段上创建一个唯一的索引，默认名字为<code> _id_</code>，该索引可防止客户端插入两个具有相同值的文档，不能在<code>_id</code>字段上删除此索引。</p>
<blockquote>
<p><strong>注意：</strong>该索引是唯一索引，因此值不能重复，即 _id 值不能重复的。在分片集群中，通常使用 _id 作为片键。</p>
</blockquote>
<h4 id="索引的创建"><a href="#索引的创建" class="headerlink" title="索引的创建"></a>索引的创建</h4><blockquote>
<p><strong>说明：</strong><br>    在集合上创建索引</p>
</blockquote>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.集合名字.createIndex(keys, options)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>keys</td>
<td>document</td>
<td>包含字段和值对的文档，其中字段是索引键，值描述该字段的索引类型。对于字段上的升序索引，请指定值1;对于降序索引，请指定值-1。比如∶{字段:1或-1}，其中1为指定按升序创建索引，如果你想按降序来创建索引指定为-1即可。另外，MongoDB支持几种不同的索引类型，包括文本、地理空间和哈希索引。</td>
</tr>
<tr>
<td>options</td>
<td>document</td>
<td>可选。包含一组控制索引创建的选项的文档。有关详细信息，请参见选项详情列表。</td>
</tr>
</tbody></table>
<p>options(更多选项)列表：</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>background</td>
<td>Boolean</td>
<td>建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加”background”可选参数。”background”默认值为<strong>false</strong>。</td>
</tr>
<tr>
<td>unique</td>
<td>Boolean</td>
<td>建立的索引是否唯一。指定为true创建唯一索引。默认值为<strong>false</strong>.</td>
</tr>
<tr>
<td>name</td>
<td>string</td>
<td>索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称。</td>
</tr>
<tr>
<td>dropDups</td>
<td>Boolean</td>
<td>3.0+版本已废弃。在建立唯一索引时是否删除重复记录,指定<strong>true</strong>创建唯一索引。默认值为<strong>false</strong>.</td>
</tr>
<tr>
<td>sparse</td>
<td>Boolean</td>
<td>对文档中不存在的字段数据不启用索引;这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档.。默认值为<strong>false</strong>.</td>
</tr>
<tr>
<td>expireAfterSeconds</td>
<td>integer</td>
<td>指定一个以秒为单位的数值，完成TTL设定，设定集合的生存时间。</td>
</tr>
<tr>
<td>v</td>
<td>index version</td>
<td>索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。</td>
</tr>
<tr>
<td>weights</td>
<td>document</td>
<td>索引权重值，数值在1到99,999之间，表示该索引相对于其他索引字段的得分权重。</td>
</tr>
<tr>
<td>default_language</td>
<td>string</td>
<td>对于文本索引，该参数决定了停用词及词千和词器的规则的列表。默认为英语</td>
</tr>
<tr>
<td>language_overridestring</td>
<td></td>
<td>对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为language</td>
</tr>
</tbody></table>
<p>【示例】<br>1）单字段索引示例：对<code>userid</code>字段建立索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; db.document.createIndex(&#123;userid: 1&#125;)</span><br><span class="line">&#123;</span><br><span class="line">        &quot;createdCollectionAutomatically&quot; : false,</span><br><span class="line">        &quot;numIndexesBefore&quot; : 1,</span><br><span class="line">        &quot;numIndexesAfter&quot; : 2,</span><br><span class="line">        &quot;ok&quot; : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数1：按升序创建索引</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> db.document.getIndexes()</span></span><br><span class="line">[</span><br><span class="line">        &#123;</span><br><span class="line">                &quot;v&quot; : 2,</span><br><span class="line">                &quot;key&quot; : &#123;</span><br><span class="line">                        &quot;_id&quot; : 1</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;name&quot; : &quot;_id_&quot;,</span><br><span class="line">                &quot;ns&quot; : &quot;articledb.document&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">                &quot;v&quot; : 2,</span><br><span class="line">                &quot;key&quot; : &#123;</span><br><span class="line">                        &quot;userid&quot; : 1</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;name&quot; : &quot;userid_1&quot;,</span><br><span class="line">                &quot;ns&quot; : &quot;articledb.document&quot;</span><br><span class="line">        &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>


<p>2）复合索引：<br>对<code>userid</code> 和 <code>nickname </code>同时建立复合（Compound）索引：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> db.document.createIndex(&#123;userid: 1,nickname: -1&#125;)</span></span><br><span class="line">&#123;</span><br><span class="line">        &quot;createdCollectionAutomatically&quot; : false,</span><br><span class="line">        &quot;numIndexesBefore&quot; : 2,</span><br><span class="line">        &quot;numIndexesAfter&quot; : 3,</span><br><span class="line">        &quot;ok&quot; : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="索引的移除"><a href="#索引的移除" class="headerlink" title="索引的移除"></a>索引的移除</h4><blockquote>
<p><strong>说明：</strong><br>    可以移除指定的索引，或者移除所有的所有</p>
</blockquote>
<h5 id="指定索引的移除"><a href="#指定索引的移除" class="headerlink" title="指定索引的移除"></a>指定索引的移除</h5><p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.集合名字.dropIndex(index)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>index</td>
<td>string or document</td>
<td>指定要删除的索引。可以通过索引名称或索引规范文档指定索引。若要删除文本索引，请指定索引名称。</td>
</tr>
</tbody></table>
<p>【示例】<br>删除<code>document</code>集合中<code> userid</code>字段上的升序索引：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> db.document.dropIndex(&#123;userid: 1&#125;)</span></span><br><span class="line">&#123; &quot;nIndexesWas&quot; : 3, &quot;ok&quot; : 1 &#125;</span><br></pre></td></tr></table></figure>
<h5 id="所有索引的移除"><a href="#所有索引的移除" class="headerlink" title="所有索引的移除"></a>所有索引的移除</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> db.document.dropIndexes()</span></span><br><span class="line">&#123;</span><br><span class="line">        &quot;nIndexesWas&quot; : 2,</span><br><span class="line">        &quot;msg&quot; : &quot;non-_id indexes dropped for collection&quot;,</span><br><span class="line">        &quot;ok&quot; : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong> <code> _id</code>的字段的索引是无法删除的，只能删除非 <code>_id</code>字段的索引。</p>
</blockquote>
<h2 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h2><h4 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h4><p>分析查询性能（Analyze Query Performance）通常使用执行计划（解释计划、Explain Plan）来查看查询的情况，如查询耗费的时间、是否基于索引查询等。<br>那么，通常，如果想知道建立的索引是否有效，效果如何，都需要通过执行计划查看。<br>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.collection.find(query,options).explain(options)</span><br></pre></td></tr></table></figure>
<p>【示例】<br>查看根据<code>userid</code>查询数据的情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> db.document.find(&#123;userid: <span class="string">&quot;1003&quot;</span>&#125;).explain()</span></span><br><span class="line">&#123;</span><br><span class="line">        &quot;queryPlanner&quot; : &#123;</span><br><span class="line">                &quot;plannerVersion&quot; : 1,</span><br><span class="line">                &quot;namespace&quot; : &quot;articledb.document&quot;,</span><br><span class="line">                &quot;indexFilterSet&quot; : false,</span><br><span class="line">                &quot;parsedQuery&quot; : &#123;</span><br><span class="line">                        &quot;userid&quot; : &#123;</span><br><span class="line">                                &quot;$eq&quot; : &quot;1003&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;queryHash&quot; : &quot;37A12FC3&quot;,</span><br><span class="line">                &quot;planCacheKey&quot; : &quot;37A12FC3&quot;,</span><br><span class="line">                &quot;winningPlan&quot; : &#123;</span><br><span class="line">                        &quot;stage&quot; : &quot;COLLSCAN&quot;,</span><br><span class="line">                        &quot;filter&quot; : &#123;</span><br><span class="line">                                &quot;userid&quot; : &#123;</span><br><span class="line">                                        &quot;$eq&quot; : &quot;1003&quot;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &quot;direction&quot; : &quot;forward&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;rejectedPlans&quot; : [ ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;serverInfo&quot; : &#123;</span><br><span class="line">                &quot;host&quot; : &quot;WIN-B640FEQTBJ0&quot;,</span><br><span class="line">                &quot;port&quot; : 27017,</span><br><span class="line">                &quot;version&quot; : &quot;4.2.15&quot;,</span><br><span class="line">                &quot;gitVersion&quot; : &quot;d7fd78dead621a539c20791a93abec34bb1be385&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ok&quot; : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/explain.png"></p>
<h4 id="涵盖的查询"><a href="#涵盖的查询" class="headerlink" title="涵盖的查询"></a>涵盖的查询</h4><p>当查询条件和查询的投影仅包含索引字段时，MongoDB直接从索引返回结果，而不扫描任何文档或将文档带入内存。 这些覆盖的查询可以非常有效。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/co.png"></p>
<p>【示例】</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> db.document.find(&#123;userid: <span class="string">&quot;1003&quot;</span>&#125;,&#123;userid:1,_id:0&#125;)</span></span><br><span class="line">&#123; &quot;userid&quot; : &quot;1003&quot; &#125;</span><br><span class="line">&#123; &quot;userid&quot; : &quot;1003&quot; &#125;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.document.find(&#123;userid: <span class="string">&quot;1003&quot;</span>&#125;,&#123;userid:1,_id:0&#125;).explain()</span></span><br><span class="line">&#123;</span><br><span class="line">        &quot;queryPlanner&quot; : &#123;</span><br><span class="line">                &quot;plannerVersion&quot; : 1,</span><br><span class="line">                &quot;namespace&quot; : &quot;articledb.document&quot;,</span><br><span class="line">                &quot;indexFilterSet&quot; : false,</span><br><span class="line">                &quot;parsedQuery&quot; : &#123;</span><br><span class="line">                        &quot;userid&quot; : &#123;</span><br><span class="line">                                &quot;$eq&quot; : &quot;1003&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;queryHash&quot; : &quot;03EEB3D0&quot;,</span><br><span class="line">                &quot;planCacheKey&quot; : &quot;35A92F08&quot;,</span><br><span class="line">                &quot;winningPlan&quot; : &#123;</span><br><span class="line">                        &quot;stage&quot; : &quot;PROJECTION_COVERED&quot;,</span><br><span class="line">                        &quot;transformBy&quot; : &#123;</span><br><span class="line">                                &quot;userid&quot; : 1,</span><br><span class="line">                                &quot;_id&quot; : 0</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &quot;inputStage&quot; : &#123;</span><br><span class="line">                                &quot;stage&quot; : &quot;IXSCAN&quot;,</span><br><span class="line">                                &quot;keyPattern&quot; : &#123;</span><br><span class="line">                                        &quot;userid&quot; : 1</span><br><span class="line">                                &#125;,</span><br><span class="line">                                &quot;indexName&quot; : &quot;userid_1&quot;,</span><br><span class="line">                                &quot;isMultiKey&quot; : false,</span><br><span class="line">                                &quot;multiKeyPaths&quot; : &#123;</span><br><span class="line">                                        &quot;userid&quot; : [ ]</span><br><span class="line">                                &#125;,</span><br><span class="line">                                &quot;isUnique&quot; : false,</span><br><span class="line">                                &quot;isSparse&quot; : false,</span><br><span class="line">                                &quot;isPartial&quot; : false,</span><br><span class="line">                                &quot;indexVersion&quot; : 2,</span><br><span class="line">                                &quot;direction&quot; : &quot;forward&quot;,</span><br><span class="line">                                &quot;indexBounds&quot; : &#123;</span><br><span class="line">                                        &quot;userid&quot; : [</span><br><span class="line">                                                &quot;[\&quot;1003\&quot;, \&quot;1003\&quot;]&quot;</span><br><span class="line">                                        ]</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;rejectedPlans&quot; : [ ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;serverInfo&quot; : &#123;</span><br><span class="line">                &quot;host&quot; : &quot;WIN-B640FEQTBJ0&quot;,</span><br><span class="line">                &quot;port&quot; : 27017,</span><br><span class="line">                &quot;version&quot; : &quot;4.2.15&quot;,</span><br><span class="line">                &quot;gitVersion&quot; : &quot;d7fd78dead621a539c20791a93abec34bb1be385&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ok&quot; : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>promise,Generator函数，async函数区别与理解</title>
    <url>/2021/08/04/promise,Generator,async/</url>
    <content><![CDATA[<blockquote>
<p>promise,generator函数和async函数是es6中的三个比较重要的新语法，都是用来解决异步操作为问题的，初学时只知道三者大概怎么用，但是最关键的三者到底有什么区别，什么时候可以用到这些认识都很模糊。这里对这三者进行一下个人理解的记录</p>
</blockquote>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise比较简单，也是最常用的，主要就是将原来的用回调函数的异步编程方法转成用relsove和reject触发事件， 用then和catch捕获成功或者失败的状态执行相应代码的异步编程的方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//回调写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params">value,callback</span>) </span>&#123;</span><br><span class="line">	value++</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			value++</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        		value++</span><br><span class="line">           <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">				<span class="built_in">console</span>.log(value)</span><br><span class="line">           &#125;，<span class="number">2000</span>)；</span><br><span class="line">        &#125;，<span class="number">2000</span>)；</span><br><span class="line">	，<span class="number">2000</span>)；</span><br><span class="line">&#125;</span><br><span class="line">fun1() <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Promise写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">	retrun	<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">      		resolve(value++)</span><br><span class="line">    	&#125;，<span class="number">2000</span>)；</span><br><span class="line">	&#125;) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun1(<span class="number">0</span>).then(<span class="function">(<span class="params">value</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> 	<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">      		resolve(value++)</span><br><span class="line">    	&#125;，<span class="number">2000</span>)；</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">value</span>)=&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> 	<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">      		resolve(value++)</span><br><span class="line">    	&#125;，<span class="number">2000</span>)；</span><br><span class="line">&#125;).then(value)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value) </span><br><span class="line">&#125;    <span class="comment">// 4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由上面代码可以看出 promise将多个回调函数嵌套的回调地狱 ，变成了链式的写法 ，可读性更高写法也更清晰</p>
<h3 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h3><p>Generator函数是将函数分步骤阻塞 ，只有主动调用next() 才能进行下一步 ，因为asyns函数相当于Generator函数的语法糖，做出了优化，所以这里对Generator函数不做赘述，而且一般用到异步编程的时候一般也只用async和promise。所以这里就省略了,<br>额。。。这里改一下，因为dva中异步处理的实现就是Generator函数，所以还是挺有用的，当然dva中自己带状态机使函数自动运行下去。</p>
<h3 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h3><p>简单的说async函数就相当于自执行的Generator函数，相当于自带一个状态机，在await的部分等待返回， 返回后自动执行下一步。而且相较于Promise,async的优越性就是把每次异步返回的结果从then中拿到最外层的方法中，不需要链式调用，只要用同步的写法就可以了。更加直观而且，更适合处理并发调用的问题。但是async必须以一个Promise对象开始 ，所以async通常是和Promise结合使用的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//回调写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">	retrun	<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">      		resolve(value++)</span><br><span class="line">    	&#125;，<span class="number">2000</span>)；</span><br><span class="line">	&#125;) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun1(<span class="number">0</span>).then(<span class="function">(<span class="params">value</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> 	<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">      		resolve(value++)</span><br><span class="line">    	&#125;，<span class="number">2000</span>)；</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">value</span>)=&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> 	<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">      		resolve(value++)</span><br><span class="line">    	&#125;，<span class="number">2000</span>)；</span><br><span class="line">&#125;).then(value)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value) </span><br><span class="line">&#125;    <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//async函数写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">	retrun	<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">      		resolve(value++)</span><br><span class="line">    	&#125;，<span class="number">2000</span>)；</span><br><span class="line">	&#125;) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asy</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> v = <span class="number">0</span></span><br><span class="line">    v = <span class="keyword">await</span> fun1(v)</span><br><span class="line">    v = <span class="keyword">await</span> fun1(v)</span><br><span class="line">    v = <span class="keyword">await</span> fun1(v)</span><br><span class="line">    <span class="built_in">console</span>.log(v)</span><br><span class="line">&#125;  </span><br><span class="line">asy() <span class="comment">//4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上面代码来看await函数的写法确实简洁了很多，而且异步的顺序也非常清晰</p>
<p><strong>总的来说，async和generator函数主要就是为了解决异步的并发调用使用的 ，直接将参数从then里取出来，相比promise的链式调用，传参更加方便，异步顺序更加清晰</strong></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>transform，transition，animation，keyframes区别</title>
    <url>/2021/08/04/transform%EF%BC%8Ctransition%EF%BC%8Canimation%EF%BC%8Ckeyframes/</url>
    <content><![CDATA[<h1 id="transform转变"><a href="#transform转变" class="headerlink" title="transform转变"></a>transform转变</h1><p><code>transform</code>并不是一个动态属性，他是一个静态的属性。专注于改变元素基于默认位置的以下值。<br>注意，只是改变，并不是一个过程，只是针对css的各种特殊改变，完全可以看作是与<code>width，height，position</code>等同类的属性。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>定义不进行转换。</td>
</tr>
<tr>
<td>matrix(n,n,n,n,n,n)</td>
<td>定义 2D 转换，使用六个值的矩阵。</td>
</tr>
<tr>
<td>matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n)</td>
<td>定义 3D 转换，使用 16 个值的 4x4 矩阵。</td>
</tr>
<tr>
<td>translate(x,y)</td>
<td>定义 2D 转换。</td>
</tr>
<tr>
<td>translate3d(x,y,z)</td>
<td>定义 3D 转换。</td>
</tr>
<tr>
<td>translateX(x)</td>
<td>定义转换，只是用 X 轴的值。</td>
</tr>
<tr>
<td>translateY(y)</td>
<td>定义转换，只是用 Y 轴的值。</td>
</tr>
<tr>
<td>translateZ(z)</td>
<td>定义 3D 转换，只是用 Z 轴的值。</td>
</tr>
<tr>
<td>scale(x,y)</td>
<td>定义 2D 缩放转换。</td>
</tr>
<tr>
<td>scale3d(x,y,z)</td>
<td>定义 3D 缩放转换。</td>
</tr>
<tr>
<td>scaleX(x)</td>
<td>通过设置 X 轴的值来定义缩放转换。</td>
</tr>
<tr>
<td>scaleY(y)</td>
<td>通过设置 Y 轴的值来定义缩放转换。</td>
</tr>
<tr>
<td>scaleZ(z)</td>
<td>通过设置 Z 轴的值来定义 3D 缩放转换。</td>
</tr>
<tr>
<td>rotate(angle)</td>
<td>定义 2D 旋转，在参数中规定角度。</td>
</tr>
<tr>
<td>rotate3d(x,y,z,angle)</td>
<td>定义 3D 旋转。</td>
</tr>
<tr>
<td>rotateX(angle)</td>
<td>定义沿着 X 轴的 3D 旋转。</td>
</tr>
<tr>
<td>rotateY(angle)</td>
<td>定义沿着 Y 轴的 3D 旋转。</td>
</tr>
<tr>
<td>rotateZ(angle)</td>
<td>定义沿着 Z 轴的 3D 旋转。</td>
</tr>
<tr>
<td>skew(x-angle,y-angle)</td>
<td>定义沿着 X 和 Y 轴的 2D 倾斜转换。</td>
</tr>
<tr>
<td>skewX(angle)</td>
<td>定义沿着 X 轴的 2D 倾斜转换。</td>
</tr>
<tr>
<td>skewY(angle)</td>
<td>定义沿着 Y 轴的 2D 倾斜转换。</td>
</tr>
<tr>
<td>perspective(n)</td>
<td>为 3D 转换元素定义透视视图。</td>
</tr>
</tbody></table>
<h1 id="transition过渡"><a href="#transition过渡" class="headerlink" title="transition过渡"></a>transition过渡</h1><p><code>transition</code>是指当它所绑定的属性（比如width）发生改变的时候，不再突变，而是根据速度曲线慢慢变化。<br>这种改变不仅仅是定义好的hover改变，也包括后期js导致的改变，甚至不小心替换class名导致的css属性改变，也就是说无论在何种情况下发生的属性改变，都会导致过渡。<br>这个时候就会知道<code>transition</code>并不是与<code>transform</code>绑定的属性，初学者（比如我&gt;.&lt;）在刚看的时候总会以为有<code>transform</code>必然有<code>transition</code>，不然不可用，然而其实<code>transition</code>是完全可以不需要<code>transform</code>而独立使用的。<br><code>transform</code>可以看作只是一个基础属性，与width，height，position同类的属性，而<code>transition</code>只是规定了发生过渡的时候所需的自定义规则，两者独立使用也可。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>transition-property</td>
<td>规定设置过渡效果的 CSS 属性的名称。</td>
</tr>
<tr>
<td>transition-duration</td>
<td>规定完成过渡效果需要多少秒或毫秒。</td>
</tr>
<tr>
<td>transition-timing-function</td>
<td>规定速度效果的速度曲线。</td>
</tr>
<tr>
<td>transition-delay</td>
<td>定义过渡效果何时开始。</td>
</tr>
</tbody></table>
<h1 id="animation动画"><a href="#animation动画" class="headerlink" title="animation动画"></a>animation动画</h1><p>先看表</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>animation-name</td>
<td>规定需要绑定到选择器的 keyframe 名称。</td>
</tr>
<tr>
<td>animation-duration</td>
<td>规定完成动画所花费的时间，以秒或毫秒计。</td>
</tr>
<tr>
<td>animation-timing-function</td>
<td>规定动画的速度曲线。</td>
</tr>
<tr>
<td>animation-delay</td>
<td>规定在动画开始之前的延迟。</td>
</tr>
<tr>
<td>animation-iteration-count</td>
<td>规定动画应该播放的次数。</td>
</tr>
<tr>
<td>animation-direction</td>
<td>规定是否应该轮流反向播放动画。</td>
</tr>
</tbody></table>
<p>它已然规定需要绑定<code>keyframe</code>，这就说明<code>animation</code>才是与<code>keyframes</code>不可分割的，不定义<code>animation</code>，<code>keyframes</code>写了毫无意义，<code>keyframes</code>不写，<code>animation</code>怎么也动不起来。</p>
<p>由此可知，<code>keyframes</code>是帮助<code>animation</code>的一个东西，那我们先看看<code>keyframes</code>再说<code>animation</code>。</p>
<h1 id="keyframes关键帧"><a href="#keyframes关键帧" class="headerlink" title="keyframes关键帧"></a>keyframes关键帧</h1><p>熟悉动画制作的同学估计都知道关键帧，他也可以看作时间帧，这个时间在表述的时候以百分比的形式展示出来。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> move</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;<span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">25%  &#123;<span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line">50%  &#123;<span class="attribute">top</span>:<span class="number">100px</span>;&#125;</span><br><span class="line">75%  &#123;<span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line">100% &#123;<span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在每个百分比里，其实就是写好的css样式，里面可以规定width等基础属性，当然也可以写<code>transform</code>！按照时间从小到大进行过渡</p>
<p>那最后<code>keyframes</code>就是已经写好的有过渡的动画动作，这才是动态的！<br><code>transform</code>只是某刻的转变，加了时间，才叫动态，才叫动画！</p>
<p>那写好了动画，给谁用，就用到了<code>animation</code>，将<code>animation</code>配置好写到css里，就可以给特定元素辅以动画了！<br>每写出来的一个<code>keyframes</code>，只是代表一个动画行为，变长变短，转圈圈，仅此而已，没有别的含义了。<br>使用<code>keyframes</code>的就是<code>animation</code>了。</p>
<h1 id="transition与animation的区别"><a href="#transition与animation的区别" class="headerlink" title="transition与animation的区别"></a>transition与animation的区别</h1><p>所以其实要说区别，应该是要区分<code>transition</code>与<code>animation</code>的区别，说了这么多，顾名思义就可以看出来，一个是过渡，一个是动画！硬要说的话，过渡是只有两个帧的动画，动画是有很多次过渡的过渡。</p>
<p><code>transition</code>是由属性的变化而触发的，无论这个变化是不是我们期望的，只要属性改变，就会触发<code>transition</code>。<br><code>animation</code>的触发就是我们所设置的，根据她所规定的值指定我们想要的规则，可以在一开始就执行，可以执行一次再也不变。</p>
]]></content>
      <tags>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>8 道高频出现的 Vue 面试题及答案</title>
    <url>/2021/08/04/vue-interview/</url>
    <content><![CDATA[<h2 style="color: rgb(53, 179, 120)"> 前言</h2>
本文讲解 8 道高频出现的 Vue 面试题及答案。
> 复习前端面试的知识，是为了巩固前端的基础知识，最重要的还是平时的积累！

<p><code>注意</code>：文章的题与题之间用下划线分隔开，答案仅供参考。</p>
<h3 style="color: rgb(53, 179, 120)"> Vue</h3>
<h4 style="color: rgb(53, 179, 120)"> 对 MVC、MVP 、MVVM 的理解</h4>
MVC 模式的意思是，软件可以分成三个部分。



<img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/1.png" style="zoom:50%;">

<ul>
<li>视图（View）：用户界面。</li>
<li>控制器（Controller）：业务逻辑。</li>
<li>模型（Model）：数据保存。<br>各部分之间的通信方式如下。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/2.png" alt="图片" style="zoom: 50%;">

<ul>
<li><p>View 传送指令到 Controller</p>
</li>
<li><p>Controller 完成业务逻辑后，要求 Model 改变状态</p>
</li>
<li><p>Model 将新的数据发送到 View，用户得到反馈</p>
</li>
<li><p>所有通信都是单向的（逆时针）。</p>
</li>
</ul>
<p>MVP 模式将 Controller 改名为 Presenter，同时改变了通信方向。</p>
<img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/3.png" alt="图片" style="zoom:50%;">

<ul>
<li>各部分之间的通信，都是双向的（顺时针）。</li>
<li>View 与 Model 不发生联系，都通过 Presenter 传递。</li>
<li>View 非常薄，不部署任何业务逻辑，称为 “被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。</li>
</ul>
<p>MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。</p>
<img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/4.png" alt="图片" style="zoom:50%;">

<p>唯一的区别是，它采用双向绑定（data-binding）：View 的变动，自动反映在 ViewModel，反之亦然。Angular 和 Ember 都采用这种模式。</p>
<h4 style="color: rgb(53, 179, 120)"> 如何理解 Vue 是异步执行 DOM 更新的 ？</h4>
- Vue 是异步执行 DOM 更新。
- 只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。
- 如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。
- 然后，在下一个的事件循环` tick `中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。

<p>例如，当你设置 vm.someData = ‘new value’ ，该组件不会立即重新渲染。</p>
<ul>
<li>当刷新队列时，组件会在事件循环队列清空时的下一个 <code>tick</code> 更新。</li>
<li>多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。</li>
<li>虽然 Vue.js 通常鼓励开发人员沿着 “数据驱动” 的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。</li>
</ul>
<h4 style="color: rgb(53, 179, 120)"> 深入响应式原理</h4>

<p>如何追踪变化</p>
<ul>
<li><p>当你把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转 getter/setter。</p>
</li>
<li><p>Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。</p>
</li>
<li><p>这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。这里需要注意的问题是浏览器控制台在打印数据对象时 getter/setter 的格式化并不同，所以你可能需要安装 vue-devtools 来获取更加友好的检查接口。</p>
</li>
<li><p>每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。</p>
</li>
<li><p>观察者订阅了可观察对象，当可观察对象发布事件，则就直接调度观察者的行为，所以这里观察者和可观察对象其实就产生了一个依赖的关系。</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/5.png" alt="图片" style="zoom:50%;">

<h4 style="color: rgb(53, 179, 120)"> 说下对 Virtual DOM 算法的理解 ?</h4>

<p>包括几个步骤：</p>
<ul>
<li>1、用 JavaScript 对象结构表示 DOM 树的结构，然后用这个树构建一个真正的 DOM 树，插到文档当中；</li>
<li>2、当状态变更的时候，重新构造一棵新的对象树，然后用新的树和旧的树进行比较，记录两棵树差异；</li>
<li>3、把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。</li>
</ul>
<p>Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）。</p>
<h4 style="color: rgb(53, 179, 120)"> 比较两棵虚拟 DOM 树的差异</h4>

<p>比较两棵 DOM 树的差异是 Virtual DOM 算法最核心的部分，这也是所谓的 Virtual DOM 的 diff 算法。两个树的完全的 diff 算法是一个时间复杂度为 O(n^3) 的问题。但是在前端当中，你很少会跨越层级地移动 DOM 元素。</p>
<p>所以 Virtual DOM 只会对同一个层级的元素进行对比：</p>
<img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/6.png" alt="图片" style="zoom:50%;">

<p>上面的 div 只会和同一层级的 div 对比，第二层级的只会跟第二层级对比。这样算法复杂度就可以达到 O(n)。</p>
<p>深度优先遍历，记录差异</p>
<p>在实际的代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记：</p>
<img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/7.png" alt="图片" style="zoom:50%;">

<p>在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。</p>
<p>Virtual DOM 算法主要是实现上面步骤的三个函数：element，diff，patch。然后就可以实际的进行使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 构建虚拟 DOM</span></span><br><span class="line"><span class="keyword">var</span> tree = el(<span class="string">&#x27;div&#x27;</span>, &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;container&#x27;</span>&#125;, [</span><br><span class="line">    el(<span class="string">&#x27;h1&#x27;</span>, &#123;<span class="attr">style</span>: <span class="string">&#x27;color: blue&#x27;</span>&#125;, [<span class="string">&#x27;simple virtal dom&#x27;</span>]),</span><br><span class="line">    el(<span class="string">&#x27;p&#x27;</span>, [<span class="string">&#x27;Hello, virtual-dom&#x27;</span>]),</span><br><span class="line">    el(<span class="string">&#x27;ul&#x27;</span>, [el(<span class="string">&#x27;li&#x27;</span>)])</span><br><span class="line">])</span><br><span class="line"><span class="comment">// 2. 通过虚拟 DOM 构建真正的 DOM</span></span><br><span class="line"><span class="keyword">var</span> root = tree.render()</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(root)</span><br><span class="line"><span class="comment">// 3. 生成新的虚拟 DOM</span></span><br><span class="line"><span class="keyword">var</span> newTree = el(<span class="string">&#x27;div&#x27;</span>, &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;container&#x27;</span>&#125;, [</span><br><span class="line">    el(<span class="string">&#x27;h1&#x27;</span>, &#123;<span class="attr">style</span>: <span class="string">&#x27;color: red&#x27;</span>&#125;, [<span class="string">&#x27;simple virtal dom&#x27;</span>]),</span><br><span class="line">    el(<span class="string">&#x27;p&#x27;</span>, [<span class="string">&#x27;Hello, virtual-dom&#x27;</span>]),</span><br><span class="line">    el(<span class="string">&#x27;ul&#x27;</span>, [el(<span class="string">&#x27;li&#x27;</span>), el(<span class="string">&#x27;li&#x27;</span>)])</span><br><span class="line">])</span><br><span class="line"><span class="comment">// 4. 比较两棵虚拟 DOM 树的不同</span></span><br><span class="line"><span class="keyword">var</span> patches = diff(tree, newTree)</span><br><span class="line"><span class="comment">// 5. 在真正的 DOM 元素上应用变更</span></span><br><span class="line">patch(root, patches)</span><br></pre></td></tr></table></figure>

<p>当然这是非常粗糙的实践，实际中还需要处理事件监听等；生成虚拟 DOM 的时候也可以加入 JSX 语法。这些事情都做了的话，就可以构造一个简单的 ReactJS 了。</p>
<h4 style="color: rgb(53, 179, 120)"> 非父子组件如何通信 ？</h4>

<p>Vue 官网介绍了非父子组件通信方法：</p>
<img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/8.png" alt="图片" style="zoom:50%;">

<p>在 bus.js 里面 写入下面信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span><span class="string">&#x27;vue&#x27;</span></span><br><span class="line">exportdefaultnew Vue();</span><br></pre></td></tr></table></figure>

<p>在需要通信的组件都引入 Bus.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;emit&quot;&gt;</span><br><span class="line">    &lt;button @click=&quot;bus&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template &gt;</span><br><span class="line">import Bus from &#x27;./bus.js&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    bus() &#123;</span><br><span class="line">      Bus.$emit(&#x27;msg&#x27;, &#x27;我要传给兄弟组件们，你收到没有&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=&quot;on&quot;&gt;</span><br><span class="line">      &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">import Bus from &#x27;./bus.js&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        message:  &#x27;&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;　　　</span><br><span class="line">       let self = this</span><br><span class="line">       Bus.$on(&#x27;msg&#x27;, (e) =&gt; &#123;</span><br><span class="line">         self.message = e</span><br><span class="line">         console.log(`传来的数据是：$&#123;e&#125;`)</span><br><span class="line">       &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>最后 p 会显示来自 $emit 传来的信息。</p>
<h4 style="color: rgb(53, 179, 120)"> 什么情况下我应该使用 Vuex ？</h4>

<ul>
<li>虽然 Vuex 可以帮助我们管理共享状态，但也附带了更多的概念和框架。这需要对短期和长期效益进行权衡。</li>
<li>如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此，如果您的应用够简单，您最好不要使用 Vuex。一个简单的 <strong>global event bus</strong>[2] 就足够您所需了。</li>
<li>但是，如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。</li>
</ul>
<h4 style="color: rgb(53, 179, 120)"> Vue 过程图解</h4>

<p>Vue 生命周期过程图解</p>
<img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/9.png" alt="图片" style="zoom:50%;">

<p style="text-align:center">Vue 生命周期</p>

<p>Vue 响应式原理</p>
<img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/10.png" alt="图片" style="zoom:50%;">

<p style="text-align:center">Vue 响应式原理</p>
Vue 过程图解

<img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/11.png" alt="图片" style="zoom:50%;">

<p style="text-align:center">Vue 过程图解</p>
Vuex

<img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/12.png" alt="图片" style="zoom:50%;">

<p style="text-align:center">Vuex</p>

]]></content>
      <tags>
        <tag>面试</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue生命周期</title>
    <url>/2021/08/04/vue-lifeCycle/</url>
    <content><![CDATA[<blockquote>
<p>生命周期：Vue 实例从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期，各个阶段有相对应的事件钩子</p>
</blockquote>
<h2 id="生命周期钩子函数"><a href="#生命周期钩子函数" class="headerlink" title="生命周期钩子函数"></a>生命周期钩子函数</h2><p>下面这张图是vue生命周期各个阶段的执行情况：</p>
<img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/v-1.png" alt="img" style="zoom:50%;">


<table>
<thead>
<tr>
<th><strong>生命周期钩子</strong></th>
<th>组件状态</th>
<th><strong>最佳实践</strong></th>
</tr>
</thead>
<tbody><tr>
<td>beforeCreate</td>
<td>实例初始化之后，this指向创建的实例，不能访问到data、computed、watch、methods上的方法和数据</td>
<td>常用于初始化非响应式变量</td>
</tr>
<tr>
<td>created</td>
<td>实例创建完成，可访问data、computed、watch、methods上的方法和数据，未挂载到DOM，不能访问到el属性，ref属性内容为空数组</td>
<td>常用于简单的ajax请求，页面的初始化</td>
</tr>
<tr>
<td>beforeMount</td>
<td>在挂载开始之前被调用，beforeMount之前，会找到对应的template，并编译成render函数</td>
<td>-</td>
</tr>
<tr>
<td>mounted</td>
<td>实例挂载到DOM上，此时可以通过DOM API获取到DOM节点，$ref属性可以访问常用于获取VNode信息和操作，ajax请求</td>
<td>常用于获取VNode信息和操作，ajax请求</td>
</tr>
<tr>
<td>beforeupdate</td>
<td>响应式数据更新时调用，发生在虚拟DOM打补丁之前</td>
<td>适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器</td>
</tr>
<tr>
<td>updated</td>
<td>虚拟 DOM 重新渲染和打补丁之后调用，组件DOM已经更新，可执行依赖于DOM的操作</td>
<td>避免在这个钩子函数中操作数据，可能陷入死循环</td>
</tr>
<tr>
<td>beforeDestroy</td>
<td>实例销毁之前调用。这一步，实例仍然完全可用，this仍能获取到实例</td>
<td>常用于销毁定时器、解绑全局事件、销毁插件对象等操作</td>
</tr>
<tr>
<td>destroyed</td>
<td>实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁</td>
<td>-</td>
</tr>
</tbody></table>
<p>注意：</p>
<ol>
<li>created阶段的ajax请求与mounted请求的区别：前者页面视图未出现，如果请求信息过多，页面会长时间处于白屏状态</li>
<li><code>mounted</code> 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染</li>
</ol>
<p>完毕，可以用 <a href="https://cn.vuejs.org/v2/api/#vm-nextTick">vm.$nextTick</a></p>
<ol>
<li>vue2.0之后主动调用$destroy()不会移除dom节点，作者不推荐直接destroy这种做法，如果实在需要这样用可以在这个生命周期钩子中手动移除dom节点</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>vue生命周期学习<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/vue/2.4.2/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">message</span>: <span class="string">&#x27;Vue的生命周期&#x27;</span></span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">beforeCreate</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.group(<span class="string">&#x27;------beforeCreate创建前状态------&#x27;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span> , <span class="string">&quot;el     : &quot;</span> + <span class="built_in">this</span>.$el); <span class="comment">//undefined</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="built_in">this</span>.$data); <span class="comment">//undefined </span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="built_in">this</span>.message) </span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">created</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.group(<span class="string">&#x27;------created创建完毕状态------&#x27;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + <span class="built_in">this</span>.$el); <span class="comment">//undefined</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="built_in">this</span>.$data); <span class="comment">//已被初始化 </span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="built_in">this</span>.message); <span class="comment">//已被初始化</span></span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">beforeMount</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.group(<span class="string">&#x27;------beforeMount挂载前状态------&#x27;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + (<span class="built_in">this</span>.$el)); <span class="comment">//已被初始化</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="built_in">this</span>.$data); <span class="comment">//已被初始化  </span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="built_in">this</span>.message); <span class="comment">//已被初始化  </span></span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">mounted</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.group(<span class="string">&#x27;------mounted 挂载结束状态------&#x27;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + <span class="built_in">this</span>.$el); <span class="comment">//已被初始化</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el);    </span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="built_in">this</span>.$data); <span class="comment">//已被初始化</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="built_in">this</span>.message); <span class="comment">//已被初始化 </span></span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">beforeUpdate</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.group(<span class="string">&#x27;beforeUpdate 更新前状态===============》&#x27;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + <span class="built_in">this</span>.$el);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el);   </span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="built_in">this</span>.$data); </span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="built_in">this</span>.message); </span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">updated</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.group(<span class="string">&#x27;updated 更新完成状态===============》&#x27;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + <span class="built_in">this</span>.$el);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el); </span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="built_in">this</span>.$data); </span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="built_in">this</span>.message); </span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">beforeDestroy</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.group(<span class="string">&#x27;beforeDestroy 销毁前状态===============》&#x27;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + <span class="built_in">this</span>.$el);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el);    </span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="built_in">this</span>.$data); </span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="built_in">this</span>.message); </span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">destroyed</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.group(<span class="string">&#x27;destroyed 销毁完成状态===============》&#x27;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;el     : &quot;</span> + <span class="built_in">this</span>.$el);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el);  </span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;data   : &quot;</span> + <span class="built_in">this</span>.$data); </span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;%c%s&quot;</span>, <span class="string">&quot;color:red&quot;</span>,<span class="string">&quot;message: &quot;</span> + <span class="built_in">this</span>.message)</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行后打开console可以看到打印出来内容如下:<br><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/v-3.png"></p>
<h2 id="单个组件的生命周期"><a href="#单个组件的生命周期" class="headerlink" title="单个组件的生命周期"></a>单个组件的生命周期</h2><p>现根据实际代码执行情况分析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;单组件&lt;/h3&gt;</span><br><span class="line">        &lt;el-button @click=&quot;dataVar += 1&quot;&gt;更新 &#123;&#123;dataVar&#125;&#125;&lt;/el-button&gt;</span><br><span class="line">        &lt;el-button @click=&quot;handleDestroy&quot;&gt;销毁&lt;/el-button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            dataVar: 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line">        this.compName = &#x27;single&#x27;</span><br><span class="line">        console.log(`--$&#123;this.compName&#125;--beforeCreate`)</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">        console.log(`--$&#123;this.compName&#125;--created`)</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeMount() &#123;</span><br><span class="line">        console.log(`--$&#123;this.compName&#125;--beforeMount`)</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        console.log(`--$&#123;this.compName&#125;--mounted`)</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeUpdate() &#123;</span><br><span class="line">        console.log(`--$&#123;this.compName&#125;--beforeUpdate`)</span><br><span class="line">    &#125;,</span><br><span class="line">    updated() &#123;</span><br><span class="line">        console.log(`--$&#123;this.compName&#125;--updated`)</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeDestroy() &#123;</span><br><span class="line">        console.log(`--$&#123;this.compName&#125;--beforeDestroy`)</span><br><span class="line">    &#125;,</span><br><span class="line">    destroyed() &#123;</span><br><span class="line">        console.log(`--$&#123;this.compName&#125;--destroyed`)</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        handleDestroy() &#123;</span><br><span class="line">            this.$destroy()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化组件时，打印：</p>
<img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/v-2.webp" alt="14483412-308eb2388198fe14" style="zoom:80%;">

<p>当data中的值变化时，打印：</p>
<img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/v-3.webp" alt="img" style="zoom:80%;">

<p>当组件销毁时，打印：</p>
<img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/v-4.webp" alt="img" style="zoom:80%;">

<p>从打印结果可以看出:</p>
<ol>
<li>初始化组件时，仅执行了beforeCreate/Created/beforeMount/mounted四个钩子函数</li>
<li>当改变data中定义的变量（响应式变量）时，会执行beforeUpdate/updated钩子函数</li>
<li>当切换组件（当前组件未缓存）时，会执行beforeDestory/destroyed钩子函数</li>
<li><strong>初始化和销毁时的生命钩子函数均只会执行一次，beforeUpdate/updated可多次执行</strong></li>
</ol>
<h2 id="父子组件的生命周期"><a href="#父子组件的生命周期" class="headerlink" title="父子组件的生命周期"></a>父子组件的生命周期</h2><p>将单组件作为基础组件（由于props在beforeCreate()中未初始化），需要做如下更改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">    compName: &#123;</span><br><span class="line">        type: String,</span><br><span class="line">        default: &#x27;single&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">beforeCreate() &#123;</span><br><span class="line">    // this.compName = &#x27;single&#x27;</span><br><span class="line">    // console.log(`--$&#123;this.compName&#125;--beforeCreate`)</span><br><span class="line"></span><br><span class="line">    console.log(` --data未初始化--beforeCreate`)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>父组件代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;complex&quot;&gt;</span><br><span class="line">        &lt;h3&gt;复杂组件&lt;/h3&gt;</span><br><span class="line">        &lt;lifecycle-single compName=&quot;child&quot;&gt;&lt;/lifecycle-single&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const COMPONENT_NAME = &#x27;complex&#x27;</span><br><span class="line"></span><br><span class="line">import LifecycleSingle from &#x27;./LifeCycleSingle&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line">        console.log(`--$&#123;COMPONENT_NAME&#125;--beforeCreate`)</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">        console.log(`--$&#123;COMPONENT_NAME&#125;--created`)</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeMount() &#123;</span><br><span class="line">        console.log(`--$&#123;COMPONENT_NAME&#125;--beforeMount`)</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        console.log(`--$&#123;COMPONENT_NAME&#125;--mounted`)</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeUpdate() &#123;</span><br><span class="line">        console.log(`--$&#123;COMPONENT_NAME&#125;--beforeUpdate`)</span><br><span class="line">    &#125;,</span><br><span class="line">    updated() &#123;</span><br><span class="line">        console.log(`--$&#123;COMPONENT_NAME&#125;--updated`)</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeDestroy() &#123;</span><br><span class="line">        console.log(`--$&#123;COMPONENT_NAME&#125;--beforeDestroy`)</span><br><span class="line">    &#125;,</span><br><span class="line">    destroyed() &#123;</span><br><span class="line">        console.log(`--$&#123;COMPONENT_NAME&#125;--destroyed`)</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        LifecycleSingle</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化组件时，打印：</p>
<img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/v-5.webp" alt="img" style="zoom:80%;">

<p>当子组件data中的值变化时，打印：</p>
<img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/v-6.webp" alt="img" style="zoom:80%;">

<p>当父组件data中的值变化时，打印：</p>
<img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/v-7.webp" alt="img" style="zoom:80%;">

<p>当props改变时，打印：</p>
<img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/v-8.webp" alt="img" style="zoom:80%;">

<p>当子组件销毁时，打印：</p>
<img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/v-9.webp" alt="img" style="zoom:80%;">

<p>当父组件销毁时，打印：</p>
<img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/v-10.webp" alt="img" style="zoom:80%;">

<p>从打印结果可以看出:</p>
<ol>
<li>仅当子组件完成挂载后，父组件才会挂载</li>
<li>当子组件完成挂载后，父组件会主动执行一次beforeUpdate/updated钩子函数（仅首次）</li>
<li>父子组件在data变化中是分别监控的，但是在更新props中的数据是关联的（可实践）</li>
<li>销毁父组件时，先将子组件销毁后才会销毁父组件</li>
</ol>
<h2 id="在上面的基础上，复杂组件做如下更改"><a href="#在上面的基础上，复杂组件做如下更改" class="headerlink" title="在上面的基础上，复杂组件做如下更改"></a>在上面的基础上，复杂组件做如下更改</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;complex&quot;&gt;</span><br><span class="line">        &lt;h3&gt;复杂组件&lt;/h3&gt;</span><br><span class="line">        &lt;lifecycle-single compName=&quot;cihld1&quot;&gt;&lt;/lifecycle-single&gt;</span><br><span class="line">        &lt;lifecycle-single compName=&quot;child2&quot;&gt;&lt;/lifecycle-single&gt;</span><br><span class="line">        &lt;el-button @click=&quot;dataVar += 1&quot;&gt;complex更新 &#123;&#123;dataVar&#125;&#125;&lt;/el-button&gt;</span><br><span class="line">        &lt;el-button @click=&quot;handleDestroy&quot;&gt;complex销毁&lt;/el-button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>初始化组件时，打印：</p>
<img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/v-11.webp" alt="img" style="zoom:80%;">

<p>当child1更新和销毁时，打印：</p>
<img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/v-12.webp" alt="img" style="zoom:80%;">

<p>当child2更新和销毁时，打印：</p>
<img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/v-13.webp" alt="img" style="zoom: 80%;">

<p>当父组件销毁时，打印：</p>
<img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/v-14.webp" alt="img" style="zoom:80%;">

<p>从打印结果可以看出:</p>
<ol>
<li>组件的初始化（mounted之前）分开进行，挂载是从上到下依次进行</li>
<li>当没有数据关联时，兄弟组件之间的更新和销毁是互不关联的</li>
</ol>
<h2 id="宏mixin的生命周期"><a href="#宏mixin的生命周期" class="headerlink" title="宏mixin的生命周期"></a>宏mixin的生命周期</h2><p>在上面的基础上，添加一个mixin.js文件，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const COMPONENT_NAME = &#x27;lifecycleMixin&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: COMPONENT_NAME,</span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line">        console.log(`--$&#123;COMPONENT_NAME&#125;--beforeCreate`)</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">        console.log(`--$&#123;COMPONENT_NAME&#125;--created`)</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeMount() &#123;</span><br><span class="line">        console.log(`--$&#123;COMPONENT_NAME&#125;--beforeMount`)</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        console.log(`--$&#123;COMPONENT_NAME&#125;--mounted`)</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeUpdate() &#123;</span><br><span class="line">        console.log(`--$&#123;COMPONENT_NAME&#125;--beforeUpdate`)</span><br><span class="line">    &#125;,</span><br><span class="line">    updated() &#123;</span><br><span class="line">        console.log(`--$&#123;COMPONENT_NAME&#125;--updated`)</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeDestroy() &#123;</span><br><span class="line">        console.log(`--$&#123;COMPONENT_NAME&#125;--beforeDestroy`)</span><br><span class="line">    &#125;,</span><br><span class="line">    destroyed() &#123;</span><br><span class="line">        console.log(`--$&#123;COMPONENT_NAME&#125;--destroyed`)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，复杂组件做如下更改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import lifecycleMixin from &#x27;./mixin&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    mixins: [lifecycleMixin],</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件初始化时，打印：</p>
<img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/v-15.webp" alt="img" style="zoom:80%;">

<p>组件销毁时，打印：</p>
<img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/v-16.webp" alt="img" style="zoom:80%;">

<p>从打印结果可以看出:<br>mixin中的生命周期与引入该组件的生命周期是仅仅关联的，且<strong>mixin的生命周期优先执行</strong></p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue学习笔记-实现一个分页组件</title>
    <url>/2021/08/04/vue-note/</url>
    <content><![CDATA[<blockquote>
<p>分页组件在web项目中是十分常见的组件，让我们用vue来实现一个简单的分页组件。</p>
</blockquote>
<h4 id="功能点："><a href="#功能点：" class="headerlink" title="功能点："></a>功能点：</h4><p>1.点击页面序号可以跳转到相应页面。<br> 2.点击上一页或者下一页可以跳转页面，当页面在第一页时上一页无法点击，页面在最后一页时下一页无法点击。<br> 3.一次显示当前页面的前两页和后两页<br> 4.当当前页面的序号和第一页与最后一页相差三个以上时出现省略号<br> 5.始终显示第一页和最后一页，只有一页的时候显示一页</p>
<h4 id="组件代码："><a href="#组件代码：" class="headerlink" title="组件代码："></a>组件代码：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pagination.vue</span><br><span class="line">&lt;!--</span><br><span class="line">  params:</span><br><span class="line">    pageNo: 总页数</span><br><span class="line">    current: 当前的页码</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;pager&quot;&gt;</span><br><span class="line">    &lt;button class=&quot;btn btn-pager&quot; :disabled=&quot;this.current == 1&quot; @click=&quot;prePage&quot;&gt;上一页&lt;/button&gt;</span><br><span class="line">    &lt;span v-if=&quot;pageNo !== 1&quot; class=&quot;page-index &#123;&#123; 1 == current ? &#x27;active&#x27;:&#x27;&#x27;&#125;&#125;&quot; @click=&quot;goPage(1)&quot;&gt;1&lt;/span&gt;</span><br><span class="line">    &lt;span v-if=&quot;preClipped&quot; class=&quot;page-index&quot;&gt;...&lt;/span&gt;</span><br><span class="line">    &lt;span v-for=&quot;index in pages&quot; class=&quot;page-index &#123;&#123; index == current ? &#x27;active&#x27;:&#x27;&#x27;&#125;&#125; &quot; @click=&quot;goPage(index)&quot;&gt;&#123;&#123;index&#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;span v-if=&quot;backClipped&quot; class=&quot;page-index&quot;&gt;...&lt;/span&gt;</span><br><span class="line">    &lt;span class=&quot;page-index &#123;&#123; pageNo == current ? &#x27;active&#x27;:&#x27;&#x27;&#125;&#125; &quot; @click=&quot;goPage(pageNo)&quot;&gt;&#123;&#123;pageNo&#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;button class=&quot;btn btn-pager&quot; :disabled=&quot;this.current == pageNo&quot; @click=&quot;nextPage&quot;&gt;下一页&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>1.给页码标签绑定class，使用对象语法，让当前的页码附上’active’类名，这样可以动态的得到active的样式，使得当前页码区别于其他页码<br> 2.给button绑定:disabled属性，让按钮在当前页面等于最后一页或者第一页时无法点击<br> 3.goPage方法绑定在页码标签上实现点击页面索引，跳转到相应页面<br> 4.prePage方法和nextPage方法绑定在button上实现页面跳转<br> 5.使用v-if指令动态判断省略号和第一页是否能显示<br> 6使用v-for指令将所有应该显示的页码遍历出来</p>
<p>JS部分就直接以注释来说明</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="comment">// 用于记录总页码，可由父组件传过来</span></span><br><span class="line">    <span class="attr">pageNo</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 用于记录当前页数，这个与父组件进行数据交互来完成每一页的数据更新，所以我们只要改变current的值来控制整个页面的数据即可</span></span><br><span class="line">    <span class="attr">current</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">data</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 用于判断省略号是否显示</span></span><br><span class="line">      <span class="attr">backClipped</span>: <span class="literal">true</span>, </span><br><span class="line">      <span class="attr">preClipped</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    prePage () &#123;</span><br><span class="line">      <span class="comment">// 上一页</span></span><br><span class="line">      <span class="built_in">this</span>.current--</span><br><span class="line">    &#125;,</span><br><span class="line">    nextPage () &#123;</span><br><span class="line">      <span class="comment">// 下一页</span></span><br><span class="line">      <span class="built_in">this</span>.current++</span><br><span class="line">    &#125;,</span><br><span class="line">    goPage (index) &#123;</span><br><span class="line">      <span class="comment">// 跳转到相应页面</span></span><br><span class="line">      <span class="keyword">if</span> (index !== <span class="built_in">this</span>.current) &#123;</span><br><span class="line">        <span class="built_in">this</span>.current = index</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">// 使用计算属性来得到每次应该显示的页码</span></span><br><span class="line">    <span class="attr">pages</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> ret = []</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.current &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前页码大于三时，显示当前页码的前2个</span></span><br><span class="line">        ret.push(<span class="built_in">this</span>.current - <span class="number">2</span>)</span><br><span class="line">        ret.push(<span class="built_in">this</span>.current - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.current &gt; <span class="number">4</span>) &#123;</span><br><span class="line">          <span class="comment">// 当前页与第一页差距4以上时显示省略号</span></span><br><span class="line">          <span class="built_in">this</span>.preClipped = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.preClipped = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; <span class="built_in">this</span>.current; i++) &#123;</span><br><span class="line">          ret.push(i)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.current !== <span class="built_in">this</span>.pageNo &amp;&amp; <span class="built_in">this</span>.current !== <span class="number">1</span>) &#123;</span><br><span class="line">        ret.push(<span class="built_in">this</span>.current)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.current &lt; (<span class="built_in">this</span>.pageNo - <span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="comment">// 显示当前页码的后2个</span></span><br><span class="line">        ret.push(<span class="built_in">this</span>.current + <span class="number">1</span>)</span><br><span class="line">        ret.push(<span class="built_in">this</span>.current + <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.current &lt;= (<span class="built_in">this</span>.pageNo - <span class="number">3</span>)) &#123;</span><br><span class="line">          当前页与最后一页差距<span class="number">3</span>以上时显示省略号</span><br><span class="line">          <span class="built_in">this</span>.backClipped = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.backClipped = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = (<span class="built_in">this</span>.current + <span class="number">1</span>); i &lt; <span class="built_in">this</span>.pageNo; i++) &#123;</span><br><span class="line">          ret.push(i)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 返回整个页码组</span></span><br><span class="line">      <span class="keyword">return</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 组件样式</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"><span class="selector-class">.pager</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn-pager</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#000000</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e3e3e3</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0px</span>;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn-pager</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f2f2f2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.page-index</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">35px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.active</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#0bbe06</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h4 id="配合父组件使用"><a href="#配合父组件使用" class="headerlink" title="配合父组件使用"></a>配合父组件使用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;pagination :page-no=<span class="string">&quot;pageNo&quot;</span> :current.sync=<span class="string">&quot;currentPage&quot;</span>&gt;&lt;/pagination&gt;</span><br><span class="line"><span class="comment">// 从父组件使用该分页组件的地方传递总页码pageNo</span></span><br><span class="line"><span class="comment">// 父组件与该分页组件双向绑定current</span></span><br><span class="line"><span class="comment">// 使用currentPage 来更新页面需要的数据</span></span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="attr">currentPage</span>: <span class="string">&#x27;requestData&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ready () &#123;</span><br><span class="line">    <span class="built_in">this</span>.requestData()</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">currentPage</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    requestData () &#123;</span><br><span class="line">      <span class="comment">// 在这里使用ajax或者fetch将对应页传过去获取数据即可</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="完成后的效果图："><a href="#完成后的效果图：" class="headerlink" title="完成后的效果图："></a>完成后的效果图：</h4><p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/v-17.webp"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/v-18.webp"></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>width和height的百分比是相对谁讲的？margin和padding呢？</title>
    <url>/2021/08/04/width%E3%80%81height%E3%80%81margin%E3%80%81padding/</url>
    <content><![CDATA[<ul>
<li>width是相对于直接父元素的width</li>
<li>height是相对于直接父元素的height</li>
<li>padding是相对于直接父元素的width</li>
<li>margin是相对于直接父元素的margin</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-id">#wrapper</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">800px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.son</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 90*40 */</span></span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">30%</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">10%</span>;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 30 30 */</span></span></span><br><span class="line"><span class="css">        <span class="attribute">padding-left</span>: <span class="number">10%</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin-left</span>: <span class="number">10%</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS Grid 网格布局教程</title>
    <url>/2021/08/04/CSS-Grid/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>网格布局（Grid）是最强大的 CSS 布局方案。</p>
<p>它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。以前，只能通过复杂的 CSS 框架达到的效果，现在浏览器内置了。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/1_bg2019032501.png" alt="img"></p>
<p>上图这样的布局，就是 Grid 布局的拿手好戏。</p>
<p>Grid 布局与 <a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局</a>有一定的相似性，都可以指定容器内部多个项目的位置。但是，它们也存在重大区别。</p>
<p>Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是<strong>一维布局</strong>。Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是<strong>二维布局</strong>。Grid 布局远比 Flex 布局强大。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>学习 Grid 布局之前，需要了解一些基本概念。</p>
<h4 id="容器和项目"><a href="#容器和项目" class="headerlink" title="容器和项目"></a>容器和项目</h4><p>采用网格布局的区域，称为”容器”（container）。容器内部采用网格定位的子元素，称为”项目”（item）。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;div&gt;&lt;p&gt;1&lt;/p&gt;&lt;/div&gt;</span><br><span class="line">&lt;div&gt;&lt;p&gt;2&lt;/p&gt;&lt;/div&gt;</span><br><span class="line">&lt;div&gt;&lt;p&gt;3&lt;/p&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，最外层的<code>&lt;div&gt;</code>元素就是容器，内层的三个<code>&lt;div&gt;</code>元素就是项目。</p>
<p>注意：项目只能是容器的顶层子元素，不包含项目的子元素，比如上面代码的<code>&lt;p&gt;</code>元素就不是项目。Grid 布局只对项目生效。</p>
<h4 id="行和列"><a href="#行和列" class="headerlink" title="行和列"></a>行和列</h4><p>容器里面的水平区域称为”行”（row），垂直区域称为”列”（column）。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/1_bg2019032502.png" alt="img"></p>
<p>上图中，水平的深色区域就是”行”，垂直的深色区域就是”列”。</p>
<h4 id="单元格"><a href="#单元格" class="headerlink" title="单元格"></a>单元格</h4><p>行和列的交叉区域，称为”单元格”（cell）。</p>
<p>正常情况下，<code>n</code>行和<code>m</code>列会产生<code>n x m</code>个单元格。比如，3行3列会产生9个单元格。</p>
<h4 id="网格线"><a href="#网格线" class="headerlink" title="网格线"></a>网格线</h4><p>划分网格的线，称为”网格线”（grid line）。水平网格线划分出行，垂直网格线划分出列。</p>
<p>正常情况下，<code>n</code>行有<code>n + 1</code>根水平网格线，<code>m</code>列有<code>m + 1</code>根垂直网格线，比如三行就有四根水平网格线。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/1_bg2019032503.png" alt="img"></p>
<p>上图是一个 4 x 4 的网格，共有5根水平网格线和5根垂直网格线。</p>
<h3 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h3><p>Grid 布局的属性分成两类。一类定义在容器上面，称为容器属性；另一类定义在项目上面，称为项目属性。这部分先介绍容器属性。</p>
<h4 id="display-grid指定一个容器采用网格布局。"><a href="#display-grid指定一个容器采用网格布局。" class="headerlink" title="display: grid指定一个容器采用网格布局。"></a><code>display: grid</code>指定一个容器采用网格布局。</h4><blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032504.png" alt="img"></p>
<p>上图是<code>display: grid</code>的<a href="https://jsbin.com/guvivum/edit?html,css,output">效果</a>。</p>
<p>默认情况下，容器元素都是块级元素，但也可以设成行内元素。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: inline-grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码指定<code>div</code>是一个行内元素，该元素内部采用网格布局。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032505.png" alt="img"></p>
<p>上图是<code>display: inline-grid</code>的<a href="https://jsbin.com/qatitav/edit?html,css,output">效果</a>。</p>
<blockquote>
<p>注意，设为网格布局以后，容器子元素（项目）的<code>float</code>、<code>display: inline-block</code>、<code>display: table-cell</code>、<code>vertical-align</code>和<code>column-*</code>等设置都将失效。</p>
</blockquote>
<h4 id="grid-template-columns-属性，-grid-template-rows-属性"><a href="#grid-template-columns-属性，-grid-template-rows-属性" class="headerlink" title="grid-template-columns 属性， grid-template-rows 属性"></a>grid-template-columns 属性， grid-template-rows 属性</h4><p>容器指定了网格布局以后，接着就要划分行和列。<code>grid-template-columns</code>属性定义每一列的列宽，<code>grid-template-rows</code>属性定义每一行的行高。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: grid;</span><br><span class="line">grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">grid-template-rows: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><a href="https://jsbin.com/qiginur/edit?css,output">上面代码</a>指定了一个三行三列的网格，列宽和行高都是<code>100px</code>。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032506.png" alt="img"></p>
<p>除了使用绝对单位，也可以使用百分比。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: grid;</span><br><span class="line">grid-template-<span class="attribute">columns</span>: <span class="number">33.33%</span> <span class="number">33.33%</span> <span class="number">33.33%</span>;</span><br><span class="line">grid-template-rows: <span class="number">33.33%</span> <span class="number">33.33%</span> <span class="number">33.33%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>（1）repeat()</strong></p>
<p>有时候，重复写同样的值非常麻烦，尤其网格很多时。这时，可以使用<code>repeat()</code>函数，简化重复的值。上面的代码用<code>repeat()</code>改写如下。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: grid;</span><br><span class="line">grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">33.33%</span>);</span><br><span class="line">grid-template-rows: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">33.33%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>repeat()</code>接受两个参数，第一个参数是重复的次数（上例是3），第二个参数是所要重复的值。</p>
<p><code>repeat()</code>重复某种模式也是可以的。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(<span class="number">2</span>, <span class="number">100px</span> <span class="number">20px</span> <span class="number">80px</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p><a href="https://jsbin.com/cokohu/edit?css,output">上面代码</a>定义了6列，第一列和第四列的宽度为<code>100px</code>，第二列和第五列为<code>20px</code>，第三列和第六列为<code>80px</code>。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032507.png" alt="img"></p>
<p><strong>（2）auto-fill 关键字</strong></p>
<p>有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用<code>auto-fill</code>关键字表示自动填充。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: grid;</span><br><span class="line">grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(auto-fill, <span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><a href="https://jsbin.com/himoku/edit?css,output">上面代码</a>表示每列宽度<code>100px</code>，然后自动填充，直到容器不能放置更多的列。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032508.png" alt="img"></p>
<p><strong>（3）fr 关键字</strong></p>
<p>为了方便表示比例关系，网格布局提供了<code>fr</code>关键字（fraction 的缩写，意为”片段”）。如果两列的宽度分别为<code>1fr</code>和<code>2fr</code>，就表示后者是前者的两倍。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: grid;</span><br><span class="line">grid-template-<span class="attribute">columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><a href="https://jsbin.com/hadexek/edit?html,css,output">上面代码</a>表示两个相同宽度的列。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/1_bg2019032509.png" alt="img"></p>
<p><code>fr</code>可以与绝对长度的单位结合使用，这时会非常方便。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: grid;</span><br><span class="line">grid-template-<span class="attribute">columns</span>: <span class="number">150px</span> <span class="number">1</span>fr <span class="number">2</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><a href="https://jsbin.com/remowec/edit?html,css,output">上面代码</a>表示，第一列的宽度为150像素，第二列的宽度是第三列的一半。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032510.png" alt="img"></p>
<p><strong>（4）minmax()</strong></p>
<p><code>minmax()</code>函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="built_in">minmax</span>(<span class="number">100px</span>, <span class="number">1</span>fr);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>minmax(100px, 1fr)</code>表示列宽不小于<code>100px</code>，不大于<code>1fr</code>。</p>
<p><strong>（5）auto 关键字</strong></p>
<p><code>auto</code>关键字表示由浏览器自己决定长度。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> auto <span class="number">100px</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了<code>min-width</code>，且这个值大于最大宽度。</p>
<p><strong>（6）网格线的名称</strong></p>
<p><code>grid-template-columns</code>属性和<code>grid-template-rows</code>属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: grid;</span><br><span class="line">grid-template-<span class="attribute">columns</span>: [c1] <span class="number">100px</span> [c2] <span class="number">100px</span> [c3] auto [c4];</span><br><span class="line">grid-template-rows: [r1] <span class="number">100px</span> [r2] <span class="number">100px</span> [r3] auto [r4];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码指定网格布局为3行 x 3列，因此有4根垂直网格线和4根水平网格线。方括号里面依次是这八根线的名字。</p>
<p>网格布局允许同一根线有多个名字，比如<code>[fifth-line row-5]</code>。</p>
<p><strong>（7）布局实例</strong></p>
<p><code>grid-template-columns</code>属性对于网页布局非常有用。两栏式布局只需要一行代码。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: grid;</span><br><span class="line">grid-template-<span class="attribute">columns</span>: <span class="number">70%</span> <span class="number">30%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码将左边栏设为70%，右边栏设为30%。</p>
<p>传统的十二网格布局，写起来也很容易。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(<span class="number">12</span>, <span class="number">1</span>fr);</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="grid-row-gap-属性，-grid-column-gap-属性，-grid-gap-属性"><a href="#grid-row-gap-属性，-grid-column-gap-属性，-grid-gap-属性" class="headerlink" title="grid-row-gap 属性， grid-column-gap 属性， grid-gap 属性"></a>grid-row-gap 属性， grid-column-gap 属性， grid-gap 属性</h4><p><code>grid-row-gap</code>属性设置行与行的间隔（行间距），<code>grid-column-gap</code>属性设置列与列的间隔（列间距）。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">grid-row-gap: <span class="number">20px</span>;</span><br><span class="line">grid-<span class="attribute">column-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><a href="https://jsbin.com/mezufab/edit?css,output">上面代码</a>中，<code>grid-row-gap</code>用于设置行间距，<code>grid-column-gap</code>用于设置列间距。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032511.png" alt="img"></p>
<p><code>grid-gap</code>属性是<code>grid-column-gap</code>和<code>grid-row-gap</code>的合并简写形式，语法如下。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>因此，上面一段 CSS 代码等同于下面的代码。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">grid-gap: <span class="number">20px</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果<code>grid-gap</code>省略了第二个值，浏览器认为第二个值等于第一个值。</p>
<blockquote>
<p>根据最新标准，上面三个属性名的<code>grid-</code>前缀已经删除，<code>grid-column-gap</code>和<code>grid-row-gap</code>写成<code>column-gap</code>和<code>row-gap</code>，<code>grid-gap</code>写成<code>gap</code>。</p>
</blockquote>
<h4 id="grid-template-areas-属性"><a href="#grid-template-areas-属性" class="headerlink" title="grid-template-areas 属性"></a>grid-template-areas 属性</h4><p>网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。<code>grid-template-areas</code>属性用于定义区域。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: grid;</span><br><span class="line">grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">grid-template-rows: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">grid-template-areas: <span class="string">&#x27;a b c&#x27;</span></span><br><span class="line">                    <span class="string">&#x27;d e f&#x27;</span></span><br><span class="line">                    <span class="string">&#x27;g h i&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码先划分出9个单元格，然后将其定名为<code>a</code>到<code>i</code>的九个区域，分别对应这九个单元格。</p>
<p>多个单元格合并成一个区域的写法如下。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-areas: <span class="string">&#x27;a a a&#x27;</span></span><br><span class="line">                  <span class="string">&#x27;b b b&#x27;</span></span><br><span class="line">                  <span class="string">&#x27;c c c&#x27;</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码将9个单元格分成<code>a</code>、<code>b</code>、<code>c</code>三个区域。</p>
<p>下面是一个布局实例。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-areas: <span class="string">&quot;header header header&quot;</span></span><br><span class="line">                  <span class="string">&quot;main main sidebar&quot;</span></span><br><span class="line">                  <span class="string">&quot;footer footer footer&quot;</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，顶部是页眉区域<code>header</code>，底部是页脚区域<code>footer</code>，中间部分则为<code>main</code>和<code>sidebar</code>。</p>
<p>如果某些区域不需要利用，则使用”点”（<code>.</code>）表示。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-template-areas: <span class="string">&#x27;a . c&#x27;</span></span><br><span class="line">                  <span class="string">&#x27;d . f&#x27;</span></span><br><span class="line">                  <span class="string">&#x27;g . i&#x27;</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，中间一列为点，表示没有用到该单元格，或者该单元格不属于任何区域。</p>
<blockquote>
<p>注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为<code>区域名-start</code>，终止网格线自动命名为<code>区域名-end</code>。</p>
<p>比如，区域名为<code>header</code>，则起始位置的水平网格线和垂直网格线叫做<code>header-start</code>，终止位置的水平网格线和垂直网格线叫做<code>header-end</code>。</p>
</blockquote>
<h4 id="grid-auto-flow-属性"><a href="#grid-auto-flow-属性" class="headerlink" title="grid-auto-flow 属性"></a>grid-auto-flow 属性</h4><p>划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行，即下图数字的顺序。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032506.png" alt="img"></p>
<p>这个顺序由<code>grid-auto-flow</code>属性决定，默认值是<code>row</code>，即”先行后列”。也可以将它设成<code>column</code>，变成”先列后行”。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-<span class="attribute">auto</span>-flow: column;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><a href="https://jsbin.com/xutokec/edit?css,output">上面代码</a>设置了<code>column</code>以后，放置顺序就变成了下图。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032512.png" alt="img"></p>
<p><code>grid-auto-flow</code>属性除了设置成<code>row</code>和<code>column</code>，还可以设成<code>row dense</code>和<code>column dense</code>。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置。</p>
<p><a href="https://jsbin.com/wapejok/edit?css,output">下面的例子</a>让1号项目和2号项目各占据两个单元格，然后在默认的<code>grid-auto-flow: row</code>情况下，会产生下面这样的布局。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032513.png" alt="img"></p>
<p>上图中，1号项目后面的位置是空的，这是因为3号项目默认跟着2号项目，所以会排在2号项目后面。</p>
<p>现在修改设置，设为<code>row dense</code>，表示”先行后列”，并且尽可能紧密填满，尽量不出现空格。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-<span class="attribute">auto</span>-flow: row dense;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><a href="https://jsbin.com/helewuy/edit?css,output">上面代码</a>的效果如下。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032514.png" alt="img"></p>
<p>上图会先填满第一行，再填满第二行，所以3号项目就会紧跟在1号项目的后面。8号项目和9号项目就会排到第四行。</p>
<p>如果将设置改为<code>column dense</code>，表示”先列后行”，并且尽量填满空格。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">grid-<span class="attribute">auto</span>-flow: column dense;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><a href="https://jsbin.com/pupoduc/1/edit?html,css,output">上面代码</a>的效果如下。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032515.png" alt="img"></p>
<p>上图会先填满第一列，再填满第2列，所以3号项目在第一列，4号项目在第二列。8号项目和9号项目被挤到了第四列。</p>
<h4 id="justify-items-属性，-align-items-属性，-place-items-属性"><a href="#justify-items-属性，-align-items-属性，-place-items-属性" class="headerlink" title="justify-items 属性， align-items 属性， place-items 属性"></a>justify-items 属性， align-items 属性， place-items 属性</h4><p><code>justify-items</code>属性设置单元格内容的水平位置（左中右），<code>align-items</code>属性设置单元格内容的垂直位置（上中下）。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">justify-items: start | end | center | stretch;</span><br><span class="line"><span class="attribute">align-items</span>: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这两个属性的写法完全相同，都可以取下面这些值。</p>
<blockquote>
<ul>
<li>start：对齐单元格的起始边缘。</li>
<li>end：对齐单元格的结束边缘。</li>
<li>center：单元格内部居中。</li>
<li>stretch：拉伸，占满单元格的整个宽度（默认值）。</li>
</ul>
</blockquote>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">justify-items: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><a href="https://jsbin.com/gijeqej/edit?css,output">上面代码</a>表示，单元格的内容左对齐，效果如下图。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032516.png" alt="img"></p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line"><span class="attribute">align-items</span>: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><a href="https://jsbin.com/tecawur/edit?css,output">上面代码</a>表示，单元格的内容头部对齐，效果如下图。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032517.png" alt="img"></p>
<p><code>place-items</code>属性是<code>align-items</code>属性和<code>justify-items</code>属性的合并简写形式。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-items: &lt;align-items&gt; &lt;justify-items&gt;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>下面是一个例子。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-items: start end;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果省略第二个值，则浏览器认为与第一个值相等。</p>
<h4 id="justify-content-属性，-align-content-属性，-place-content-属性"><a href="#justify-content-属性，-align-content-属性，-place-content-属性" class="headerlink" title="justify-content 属性， align-content 属性， place-content 属性"></a>justify-content 属性， align-content 属性， place-content 属性</h4><p><code>justify-content</code>属性是整个内容区域在容器里面的水平位置（左中右），<code>align-content</code>属性是整个内容区域的垂直位置（上中下）。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line"><span class="attribute">justify-content</span>: start | end | center | stretch | space-around | space-between | space-evenly;</span><br><span class="line"><span class="attribute">align-content</span>: start | end | center | stretch | space-around | space-between | space-evenly;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这两个属性的写法完全相同，都可以取下面这些值。（下面的图都以<code>justify-content</code>属性为例，<code>align-content</code>属性的图完全一样，只是将水平方向改成垂直方向。）</p>
<blockquote>
<ul>
<li>start - 对齐容器的起始边框。</li>
</ul>
</blockquote>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032519.png" alt="img"></p>
<blockquote>
<ul>
<li>end - 对齐容器的结束边框。</li>
</ul>
</blockquote>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032518.png" alt="img"></p>
<blockquote>
<ul>
<li>center - 容器内部居中。</li>
</ul>
</blockquote>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032520.png" alt="img"></p>
<blockquote>
<ul>
<li>stretch - 项目大小没有指定时，拉伸占据整个网格容器。</li>
</ul>
</blockquote>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032521.png" alt="img"></p>
<blockquote>
<ul>
<li>space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。</li>
</ul>
</blockquote>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032522.png" alt="img"></p>
<blockquote>
<ul>
<li>space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。</li>
</ul>
</blockquote>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032523.png" alt="img"></p>
<blockquote>
<ul>
<li>space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。</li>
</ul>
</blockquote>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032524.png" alt="img"></p>
<p><code>place-content</code>属性是<code>align-content</code>属性和<code>justify-content</code>属性的合并简写形式。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-<span class="attribute">content</span>: &lt;align-content&gt; &lt;justify-content&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>下面是一个例子。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-<span class="attribute">content</span>: space-around space-evenly;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果省略第二个值，浏览器就会假定第二个值等于第一个值。</p>
<h4 id="grid-auto-columns-属性，-grid-auto-rows-属性"><a href="#grid-auto-columns-属性，-grid-auto-rows-属性" class="headerlink" title="grid-auto-columns 属性， grid-auto-rows 属性"></a>grid-auto-columns 属性， grid-auto-rows 属性</h4><p>有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。</p>
<p><code>grid-auto-columns</code>属性和<code>grid-auto-rows</code>属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与<code>grid-template-columns</code>和<code>grid-template-rows</code>完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p>
<p><a href="https://jsbin.com/sayuric/edit?css,output">下面的例子</a>里面，划分好的网格是3行 x 3列，但是，8号项目指定在第4行，9号项目指定在第5行。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: grid;</span><br><span class="line">grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">grid-template-rows: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">grid-<span class="attribute">auto</span>-rows: <span class="number">50px</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码指定新增的行高统一为50px（原始的行高为100px）。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032525.png" alt="img"></p>
<p>grid-template 属性， grid 属性</p>
<p><code>grid-template</code>属性是<code>grid-template-columns</code>、<code>grid-template-rows</code>和<code>grid-template-areas</code>这三个属性的合并简写形式。</p>
<p><code>grid</code>属性是<code>grid-template-rows</code>、<code>grid-template-columns</code>、<code>grid-template-areas</code>、 <code>grid-auto-rows</code>、<code>grid-auto-columns</code>、<code>grid-auto-flow</code>这六个属性的合并简写形式。</p>
<p>从易读易写的角度考虑，还是建议不要合并属性，所以这里就不详细介绍这两个属性了。</p>
<h3 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h3><p>下面这些属性定义在项目上面。</p>
<h4 id="grid-column-start-属性，-grid-column-end-属性，-grid-row-start-属性，-grid-row-end-属性"><a href="#grid-column-start-属性，-grid-column-end-属性，-grid-row-start-属性，-grid-row-end-属性" class="headerlink" title="grid-column-start 属性， grid-column-end 属性， grid-row-start 属性， grid-row-end 属性"></a>grid-column-start 属性， grid-column-end 属性， grid-row-start 属性， grid-row-end 属性</h4><p>项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。</p>
<blockquote>
<ul>
<li><code>grid-column-start</code>属性：左边框所在的垂直网格线</li>
<li><code>grid-column-end</code>属性：右边框所在的垂直网格线</li>
<li><code>grid-row-start</code>属性：上边框所在的水平网格线</li>
<li><code>grid-row-end</code>属性：下边框所在的水平网格线</li>
</ul>
</blockquote>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">grid-column-start: <span class="number">2</span>;</span><br><span class="line">grid-column-end: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><a href="https://jsbin.com/yukobuf/edit?css,output">上面代码</a>指定，1号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032526.png" alt="img"></p>
<p>上图中，只指定了1号项目的左右边框，没有指定上下边框，所以会采用默认位置，即上边框是第一根水平网格线，下边框是第二根水平网格线。</p>
<p>除了1号项目以外，其他项目都没有指定位置，由浏览器自动布局，这时它们的位置由容器的<code>grid-auto-flow</code>属性决定，这个属性的默认值是<code>row</code>，因此会”先行后列”进行排列。读者可以把这个属性的值分别改成<code>column</code>、<code>row dense</code>和<code>column dense</code>，看看其他项目的位置发生了怎样的变化。</p>
<p><a href="https://jsbin.com/nagobey/edit?html,css,output">下面的例子</a>是指定四个边框位置的效果。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">grid-column-start: <span class="number">1</span>;</span><br><span class="line">grid-column-end: <span class="number">3</span>;</span><br><span class="line">grid-row-start: <span class="number">2</span>;</span><br><span class="line">grid-row-end: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032527.png" alt="img"></p>
<p>这四个属性的值，除了指定为第几个网格线，还可以指定为网格线的名字。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">grid-column-start: header-start;</span><br><span class="line">grid-column-end: header-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，左边框和右边框的位置，都指定为网格线的名字。</p>
<p>这四个属性的值还可以使用<code>span</code>关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">grid-column-start: span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><a href="https://jsbin.com/hehumay/edit?html,css,output">上面代码</a>表示，1号项目的左边框距离右边框跨越2个网格。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032528.png" alt="img"></p>
<p>这与<a href="https://jsbin.com/mujihib/edit?html,css,output">下面的代码</a>效果完全一样。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">grid-column-end: span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>使用这四个属性，如果产生了项目的重叠，则使用<code>z-index</code>属性指定项目的重叠顺序。</p>
<h4 id="grid-column-属性，-grid-row-属性"><a href="#grid-column-属性，-grid-row-属性" class="headerlink" title="grid-column 属性， grid-row 属性"></a>grid-column 属性， grid-row 属性</h4><p><code>grid-column</code>属性是<code>grid-column-start</code>和<code>grid-column-end</code>的合并简写形式，<code>grid-row</code>属性是<code>grid-row-start</code>属性和<code>grid-row-end</code>的合并简写形式。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">grid-column: &lt;start-line&gt; / &lt;end-line&gt;;</span><br><span class="line">grid-row: &lt;start-line&gt; / &lt;end-line&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>下面是一个例子。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">grid-column: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">grid-row: <span class="number">1</span> / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 等同于 */</span></span><br><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">grid-column-start: <span class="number">1</span>;</span><br><span class="line">grid-column-end: <span class="number">3</span>;</span><br><span class="line">grid-row-start: <span class="number">1</span>;</span><br><span class="line">grid-row-end: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，项目<code>item-1</code>占据第一行，从第一根列线到第三根列线。</p>
<p>这两个属性之中，也可以使用<code>span</code>关键字，表示跨越多少个网格。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line"><span class="attribute">background</span>: <span class="number">#b03532</span>;</span><br><span class="line">grid-column: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">grid-row: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 等同于 */</span></span><br><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line"><span class="attribute">background</span>: <span class="number">#b03532</span>;</span><br><span class="line">grid-column: <span class="number">1</span> / span <span class="number">2</span>;</span><br><span class="line">grid-row: <span class="number">1</span> / span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><a href="https://jsbin.com/volugow/edit?html,css,output">上面代码</a>中，项目<code>item-1</code>占据的区域，包括第一行 + 第二行、第一列 + 第二列。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032529.png" alt="img"></p>
<p>斜杠以及后面的部分可以省略，默认跨越一个网格。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">grid-column: <span class="number">1</span>;</span><br><span class="line">grid-row: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，项目<code>item-1</code>占据左上角第一个网格。</p>
<h4 id="grid-area-属性"><a href="#grid-area-属性" class="headerlink" title="grid-area 属性"></a>grid-area 属性</h4><p><code>grid-area</code>属性指定项目放在哪一个区域。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">grid-area: e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><a href="https://jsbin.com/qokexob/edit?css,output">上面代码</a>中，1号项目位于<code>e</code>区域，效果如下图。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032530.png" alt="img"></p>
<p><code>grid-area</code>属性还可用作<code>grid-row-start</code>、<code>grid-column-start</code>、<code>grid-row-end</code>、<code>grid-column-end</code>的合并简写形式，直接指定项目的位置。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">grid-area: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>下面是一个<a href="https://jsbin.com/duyafez/edit?css,output">例子</a>。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">grid-area: <span class="number">1</span> / <span class="number">1</span> / <span class="number">3</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="justify-self-属性，-align-self-属性，-place-self-属性"><a href="#justify-self-属性，-align-self-属性，-place-self-属性" class="headerlink" title="justify-self 属性， align-self 属性， place-self 属性"></a>justify-self 属性， align-self 属性， place-self 属性</h4><p><code>justify-self</code>属性设置单元格内容的水平位置（左中右），跟<code>justify-items</code>属性的用法完全一致，但只作用于单个项目。</p>
<p><code>align-self</code>属性设置单元格内容的垂直位置（上中下），跟<code>align-items</code>属性的用法完全一致，也是只作用于单个项目。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">justify-self: start | end | center | stretch;</span><br><span class="line"><span class="attribute">align-self</span>: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这两个属性都可以取下面四个值。</p>
<blockquote>
<ul>
<li>start：对齐单元格的起始边缘。</li>
<li>end：对齐单元格的结束边缘。</li>
<li>center：单元格内部居中。</li>
<li>stretch：拉伸，占满单元格的整个宽度（默认值）。</li>
</ul>
</blockquote>
<p>下面是<code>justify-self: start</code>的例子。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span>  &#123;</span><br><span class="line">justify-self: start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032532.png" alt="img"></p>
<p><code>place-self</code>属性是<code>align-self</code>属性和<code>justify-self</code>属性的合并简写形式。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-self: &lt;align-self&gt; &lt;justify-self&gt;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>下面是一个例子。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">place-self: center center;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果省略第二个值，<code>place-self</code>属性会认为这两个值相等。</p>
]]></content>
      <tags>
        <tag>css</tag>
        <tag>css布局</tag>
      </tags>
  </entry>
  <entry>
    <title>那些必会用到的 ES6 精粹</title>
    <url>/2021/08/04/ES6/</url>
    <content><![CDATA[<h3 id="let-和-constlet"><a href="#let-和-constlet" class="headerlink" title="let 和 constlet"></a>let 和 constlet</h3><p>的作用域与 const 命令相同：只在声明所在的块级作用域内有效。且不存在变量提升 。</p>
<h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p>let 所声明的变量，可以改变。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">123</span></span><br><span class="line">a = <span class="number">456</span> <span class="comment">// 正确，可以改变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">123</span>]</span><br><span class="line">b = [<span class="number">456</span>] <span class="comment">// 正确，可以改变</span></span><br></pre></td></tr></table></figure>

<h4 id="constconst"><a href="#constconst" class="headerlink" title="constconst"></a>constconst</h4><p> 声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<p>简单类型的数据（数值、字符串、布尔值），不可以变动</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">123</span></span><br><span class="line">a = <span class="number">456</span> <span class="comment">// 报错，不可改变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = [<span class="number">123</span>]</span><br><span class="line">b = [<span class="number">456</span>] <span class="comment">// 报错，不可以重新赋值，不可改变</span></span><br></pre></td></tr></table></figure>

<p>复合类型的数据（主要是对象和数组），可以这样子变动</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">123</span>]</span><br><span class="line">a.push(<span class="number">456</span>) <span class="comment">// 成功</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = &#123;&#125;</span><br><span class="line">b.name = <span class="string">&#x27;demo&#x27;</span>  <span class="comment">// 成功</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a <span class="comment">// ReferenceError: a is not defined.</span></span><br><span class="line">b <span class="comment">// 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以 for循环的计数器，就很合适使用 let 命令。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<h4 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h4><p>对于 数值、字符串、布尔值 经常会变的，用 let 声明。</p>
<p>对象、数组和函数用 const 来声明。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如经常用到的导出 函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> funA = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解构（Destructuring）"><a href="#解构（Destructuring）" class="headerlink" title="解构（Destructuring）"></a>解构（Destructuring）</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>一次性声明多个变量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>结合扩展运算符：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(head) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(tail) <span class="comment">// [2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>解构赋值允许指定默认值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(head) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(tail) <span class="comment">// [2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>解构不仅可以用于数组，还可以用于对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; a, b &#125; = &#123; <span class="attr">a</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">b</span>: <span class="string">&quot;bbb&quot;</span> &#125;;</span><br><span class="line">a <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">b <span class="comment">// &quot;bbb&quot;</span></span><br></pre></td></tr></table></figure>

<p>数组中，变量的取值由它 <strong>排列的位置</strong> 决定；而对象中，变量必须与 <strong>属性</strong> 同名，才能取到正确的值。</p>
<p>对象的解构也可以指定默认值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;x = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">x <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;x, y = <span class="number">5</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">a <span class="comment">// &quot;h&quot;</span></span><br><span class="line">b <span class="comment">// &quot;e&quot;</span></span><br><span class="line">c <span class="comment">// &quot;l&quot;</span></span><br><span class="line">d <span class="comment">// &quot;l&quot;</span></span><br><span class="line">e <span class="comment">// &quot;o&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>1.交换变量的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure>

<p>2.从函数返回多个值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">  <span class="keyword">return</span>  [a, b, c] </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure>

<p>3.函数参数的默认值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funA</span> (<span class="params">a = <span class="number">1</span>, b = <span class="number">2</span></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funA(<span class="number">3</span>) <span class="comment">// 5 因为 a 是 3, b 是 2</span></span><br><span class="line">funA(<span class="number">3</span>，<span class="number">3</span>) <span class="comment">// 6 因为 a 是 3, b 是 3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4.输入模块的指定方法</p>
<p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">&quot;source-map&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在utils.js中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="function"><span class="keyword">function</span> <span class="title">A</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="function"><span class="keyword">function</span> <span class="title">B</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="function"><span class="keyword">function</span> <span class="title">C</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 组件中引用时:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; A, B, C &#125; <span class="keyword">from</span> <span class="string">&quot;./utils.js&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">A() <span class="comment">// 输出 A </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="模板字符串（template-string）"><a href="#模板字符串（template-string）" class="headerlink" title="模板字符串（template string）"></a>模板字符串（template string）</h3><p>模板字符串（template string）用反引号（`）标识。</p>
<h4 id="纯字符串"><a href="#纯字符串" class="headerlink" title="纯字符串"></a>纯字符串</h4><p>所有模板字符串的空格和换行，都是被保留的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">`输出值为 N, </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">换行`</span>)</span><br><span class="line"><span class="comment">// &quot;输出值为 N</span></span><br><span class="line"></span><br><span class="line">换行<span class="string">&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串中加变量"><a href="#字符串中加变量" class="headerlink" title="字符串中加变量"></a>字符串中加变量</h4><p>模板字符串中嵌入变量，需要将变量名写在 ${ } 之中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`输出值为：<span class="subst">$&#123;x&#125;</span>`</span>) <span class="comment">// &quot;输出值为：1&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`输出值为：<span class="subst">$&#123;x + y&#125;</span>`</span>) <span class="comment">// &quot;输出值为：3&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="模板字符串之中还能调用函数。"><a href="#模板字符串之中还能调用函数。" class="headerlink" title="模板字符串之中还能调用函数。"></a>模板字符串之中还能调用函数。</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`输出值为：<span class="subst">$&#123;fn()&#125;</span>`</span>) <span class="comment">// &quot;输出值为：Hello World&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串函数扩展"><a href="#字符串函数扩展" class="headerlink" title="字符串函数扩展"></a>字符串函数扩展</h3><ul>
<li><p>includes()：返回布尔值，表示是否找到了参数字符串。</p>
</li>
<li><p>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部</p>
</li>
<li><p>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s.startsWith(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">&#x27;!&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">&#x27;o&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这三个方法都支持第二个参数，表示开始搜索的位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s.startsWith(<span class="string">&#x27;world&#x27;</span>, <span class="number">6</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">5</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">6</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h3><h4 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h4><p>ES2016 新增了一个指数运算符（**）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">2</span> <span class="comment">// 4 </span></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span> <span class="comment">// 8 </span></span><br></pre></td></tr></table></figure>
<p>这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。</p>
<figure class="highlight plaintext"><figcaption><span>相当于 2 ** (3 ** 2)</span></figcaption><table><tr><td class="code"><pre><span class="line">2 ** 3 ** 2 </span><br><span class="line">// 512 </span><br></pre></td></tr></table></figure>
<p>上面代码中，首先计算的是第二个指数运算符，而不是第一个。<br>指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1.5</span>; </span><br><span class="line">a **= <span class="number">2</span>; </span><br><span class="line"><span class="comment">// 等同于 a = a * a; </span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">4</span>; </span><br><span class="line">b **= <span class="number">3</span>; </span><br><span class="line"><span class="comment">// 等同于 b = b * b * b; </span></span><br></pre></td></tr></table></figure>
<h3 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h3><p>除了在解构中说到的函数参数的默认值，还有不少经常会用到的方法。</p>
<h4 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h4><p>ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用 arguments 对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;  </span><br><span class="line">	<span class="keyword">let</span> sum = <span class="number">0</span>;   </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> values) &#123;    </span><br><span class="line">		sum += val;  </span><br><span class="line">	&#125;   </span><br><span class="line">	<span class="keyword">return</span> sum; </span><br><span class="line">&#125; </span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10 </span></span><br></pre></td></tr></table></figure>
<p>上面代码的 add 函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。<br>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, ...b, c</span>) </span>&#123;  </span><br><span class="line">	<span class="comment">// ... </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="箭头-函数"><a href="#箭头-函数" class="headerlink" title="箭头 函数"></a>箭头 函数</h4><p>ES6 允许使用“箭头”（=&gt;）定义函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;输出值:&#x27;</span>, f(<span class="number">3</span>)) <span class="comment">// 输出值: 3 </span></span><br><span class="line"><span class="comment">// 等同于 </span></span><br><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;  </span><br><span class="line">	<span class="keyword">return</span> v; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等同于 </span></span><br><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">5</span> &#125;; </span><br><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2; </span><br><span class="line"><span class="comment">// 等同于 </span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;  </span><br><span class="line">	<span class="keyword">return</span> num1 + num2; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 return 语句返回。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123; <span class="keyword">return</span> num1 + num2; &#125; </span><br></pre></td></tr></table></figure>
<p>箭头函数的一个用处是简化回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">n</span> =&gt;</span> n * n; </span><br><span class="line"><span class="comment">// 正常函数写法 </span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;  </span><br><span class="line">	<span class="keyword">return</span> x * x; </span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">// 箭头函数写法 </span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x); </span><br></pre></td></tr></table></figure>
<p><strong>注意: 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。</strong><br>this 对象的指向是可变的，但是在箭头函数中，它是固定的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;    </span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;id:&#x27;</span>, <span class="built_in">this</span>.id);  </span><br><span class="line">	&#125;, <span class="number">100</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> id = <span class="number">21</span>; </span><br><span class="line">foo.call(&#123; <span class="attr">id</span>: <span class="number">42</span> &#125;); </span><br><span class="line"><span class="comment">// id: 42 </span></span><br></pre></td></tr></table></figure>
<p>上面代码中，setTimeout 的参数是一个箭头函数，这个箭头函数的定义生效是在 foo 函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时 this 应该指向全局对象window，这时应该输出 21。但是，箭头函数导致 this 总是指向函数定义生效时所在的对象（本例是{ id: 42}），所以输出的是 42.</p>
<h3 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h3><p>扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<h4 id="数组合并的新写法。"><a href="#数组合并的新写法。" class="headerlink" title="数组合并的新写法。"></a>数组合并的新写法。</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 的合并数组</span></span><br><span class="line">arr1.concat(arr2, arr3);</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的合并数组</span></span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br></pre></td></tr></table></figure>
<h4 id="函数调用。"><a href="#函数调用。" class="headerlink" title="函数调用。"></a>函数调用。</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">4</span>, <span class="number">4</span>];</span><br><span class="line">add(...numbers) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<h4 id="复制数组的简便写法。"><a href="#复制数组的简便写法。" class="headerlink" title="复制数组的简便写法。"></a>复制数组的简便写法。</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> a2 = [...a1];</span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">a1 <span class="comment">// [1, 2]</span></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> [...a2] = a1;</span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">a1 <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>

<p>上面的两种写法，a2 都是 a1 的克隆，且不会修改原来的数组。</p>
<h4 id="将字符串转为真正的数组。"><a href="#将字符串转为真正的数组。" class="headerlink" title="将字符串转为真正的数组。"></a>将字符串转为真正的数组。</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[...<span class="string">&#x27;hello&#x27;</span>]</span><br><span class="line"><span class="comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span></span><br></pre></td></tr></table></figure>
<h4 id="数组实例的-entries-，keys-和-values"><a href="#数组实例的-entries-，keys-和-values" class="headerlink" title="数组实例的 entries()，keys() 和 values()"></a>数组实例的 entries()，keys() 和 values()</h4><p>用 for…of 循环进行遍历，唯一的区别是 keys() 是对键名的遍历、values() 是对键值的遍历，entries() 是对键值对的遍历。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br><span class="line"><span class="comment">// 1 &quot;b&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h4><p>Array.prototype.includes 方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的 includes 方法类似。ES2016 引入了该方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>)     <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>)     <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>该方法的第二个参数表示搜索的起始位置，默认为 0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为 -4，但数组长度为 3 ），则会重置为从 0 开始。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, <span class="number">3</span>);  <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, -<span class="number">1</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h3><h4 id="属性和方法-的简洁表示法"><a href="#属性和方法-的简洁表示法" class="headerlink" title="属性和方法 的简洁表示法"></a>属性和方法 的简洁表示法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> birth = <span class="string">&#x27;2000/01/01&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> Person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="comment">//等同于birth: birth</span></span><br><span class="line">  birth,</span><br><span class="line">  <span class="comment">// 等同于hello: function ()...</span></span><br><span class="line">  <span class="function"><span class="title">hello</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;我的名字是&#x27;</span>, <span class="built_in">this</span>.name); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h4><p>Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure>
<p>Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。<br><strong>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure>

<p>Object.assign 方法实行的是浅拷贝，而不是深拷贝。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1);</span><br><span class="line"></span><br><span class="line">obj1.a.b = <span class="number">2</span>;</span><br><span class="line">obj2.a.b <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，源对象 obj1 的 a 属性的值是一个对象，Object.assign 拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。</p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set 本身是一个构造函数，用来生成 Set 数据结构。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本用法</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除数组的重复成员</span></span><br><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]</span><br><span class="line">[...new <span class="built_in">Set</span>(array)]</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<h3 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h3><p>Promise 是异步编程的一种解决方案。Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params">flag</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        reject(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing(<span class="literal">true</span>).then(<span class="function">(<span class="params">data</span>)=&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;data:&#x27;</span>,data); <span class="comment">// 输出 &#x27;ok&#x27;</span></span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;error:&#x27;</span>, error); <span class="comment">// 不执行</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">someAsyncThing(<span class="literal">false</span>).then(<span class="function">(<span class="params">data</span>)=&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;data:&#x27;</span>,data); <span class="comment">// 不执行</span></span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;error:&#x27;</span>, error); <span class="comment">// 输出 &#x27;error&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面代码中，someAsyncThing 函数成功返回 ‘OK’, 失败返回 ‘error’, 只有失败时才会被 catch 捕捉到。最简单实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发起异步请求</span></span><br><span class="line">    fetch(<span class="string">&#x27;/api/todos&#x27;</span>)</span><br><span class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">      .then(<span class="function"><span class="params">data</span> =&gt;</span> (&#123; data &#125;))</span><br><span class="line">      .catch(<span class="function"><span class="params">err</span> =&gt;</span> (&#123; err &#125;));</span><br></pre></td></tr></table></figure>

<p>来看一道有意思的面试题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;<span class="number">10000</span> ; i++ ) &#123;</span><br><span class="line">    i == <span class="number">9999</span> &amp;&amp; resolve();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>这道题应该考察 JavaScript 的运行机制的。</p>
<p>首先先碰到一个 setTimeout，于是会先设置一个定时，在定时结束后将传递这个函数放到任务队列里面，因此开始肯定不会输出 1 。</p>
<p>然后是一个 Promise，里面的函数是直接执行的，因此应该直接输出 2 3 。</p>
<p>然后，Promise 的 then 应当会放到当前 tick 的最后，但是还是在当前 tick 中。 </p>
<p>因此，应当先输出 5，然后再输出 4 。 </p>
<p>最后在到下一个 tick，就是 1 。 </p>
<p>答案：<code>“2 3 5 4 1”</code></p>
<h3 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h3><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>
<p>async 函数的使用方式，直接在普通函数前面加上 async，表示这是一个异步函数，在要异步执行的语句前面加上 await，表示后面的表达式需要等待。async 是 Generator 的语法糖</p>
<ul>
<li>async 函数内部 return 语句返回的值，会成为 then 方法回调函数的参数。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>
上面代码中，函数 f 内部 return 命令返回的值，会被 then 方法回调函数接收到。</li>
<li>async 函数内部抛出错误，会导致返回的 Promise 对象变为 reject 状态。抛出的错误对象会被 catch 方法回调函数接收到。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(</span><br><span class="line">  <span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result),</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// Error: 出错了</span></span><br></pre></td></tr></table></figure></li>
<li>async 函数返回的 Promise 对象，必须等到内部所有 await 命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到 return 语句或者抛出错误。也就是说，只有 async 函数内部的异步操作执行完，才会执行 then 方法指定的回调函数。 下面是一个例子:<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getTitle</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">  <span class="keyword">let</span> html = <span class="keyword">await</span> response.text();</span><br><span class="line">  <span class="keyword">return</span> html.match(<span class="regexp">/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i</span>)[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">getTitle(<span class="string">&#x27;https://tc39.github.io/ecma262/&#x27;</span>).then(<span class="built_in">console</span>.log(<span class="string">&#x27;完成&#x27;</span>))</span><br><span class="line"><span class="comment">// &quot;ECMAScript 2017 Language Specification&quot;</span></span><br></pre></td></tr></table></figure>
上面代码中，函数 getTitle 内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行 then 方法里面的 console.log。</li>
<li>在 vue 中，我们可能要先获取 token ，之后再用 token 来请求用户数据什么的，可以这样子用：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">        <span class="function"><span class="title">getToken</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.$http.post(<span class="string">&#x27;/token&#x27;</span>)</span><br><span class="line">                    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (res.data.code === <span class="number">200</span>) &#123;</span><br><span class="line">                           resolve(res.data.data)</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            reject()</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="built_in">console</span>.error(error);</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125;)</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="function"><span class="title">getUserInfo</span>(<span class="params">token</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.$http.post(<span class="string">&#x27;/userInfo&#x27;</span>,&#123;</span><br><span class="line">                        <span class="attr">token</span>: token</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (res.data.code === <span class="number">200</span>) &#123;</span><br><span class="line">                           resolve(res.data.data)</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            reject()</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="built_in">console</span>.error(error);</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125;)</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="keyword">async</span> <span class="function"><span class="title">initData</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> token = <span class="keyword">await</span> <span class="built_in">this</span>.getToken()</span><br><span class="line">            <span class="built_in">this</span>.userInfo = <span class="built_in">this</span>.getUserInfo(token)</span><br><span class="line">       &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
import 和 export<br>import 导入模块、export 导出模块<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example2.js  // 导出默认, 有且只有一个默认</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">const</span> example2 = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&#x27;my name&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span> : <span class="string">&#x27;my age&#x27;</span>,</span><br><span class="line">  getName  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="keyword">return</span> <span class="string">&#x27;my name&#x27;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//全部导入 // 名字可以修改</span></span><br><span class="line"><span class="keyword">import</span> people <span class="keyword">from</span> <span class="string">&#x27;./example2.js&#x27;</span></span><br><span class="line"></span><br><span class="line">-------------------我是一条华丽的分界线---------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// example1.js // 部分导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name  = <span class="string">&#x27;my name&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> age  = <span class="string">&#x27;my age&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> getName  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="string">&#x27;my name&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入部分 // 名字必须和 定义的名字一样。</span></span><br><span class="line"><span class="keyword">import</span>  &#123;name, age&#125; <span class="keyword">from</span> <span class="string">&#x27;./example1.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//有一种特殊情况，即允许你将整个模块当作单一对象进行导入</span></span><br><span class="line"><span class="comment">//该模块的所有导出都会作为对象的属性存在</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> example <span class="keyword">from</span> <span class="string">&quot;./example1.js&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(example.name)</span><br><span class="line"><span class="built_in">console</span>.log(example.age)</span><br><span class="line"><span class="built_in">console</span>.log(example.getName())</span><br><span class="line"></span><br><span class="line">-------------------我是一条华丽的分界线---------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// example3.js  // 有导出默认, 有且只有一个默认，// 又有部分导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">const</span> example3 = &#123;</span><br><span class="line">  <span class="attr">birthday</span> : <span class="string">&#x27;2018 09 20&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name  = <span class="string">&#x27;my name&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> age  = <span class="string">&#x27;my age&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> getName  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="string">&#x27;my name&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入默认与部分</span></span><br><span class="line"><span class="keyword">import</span> example3, &#123;name, age&#125; <span class="keyword">from</span> <span class="string">&#x27;./example1.js&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
总结：</li>
<li>当用 export default people 导出时，就用 import people 导入（不带大括号）</li>
<li> 一个文件里，有且只能有一个 export default。但可以有多个 export。</li>
<li> 当用 export name 时，就用 import { name }导入（记得带上大括号）</li>
<li> 当一个文件里，既有一个 export default people, 又有多个 export name 或者 export age 时，导入就用 import people, { name, age } </li>
<li> 当一个文件里出现 n 多个 export 导出很多模块，导入时除了一个一个导入，也可以用 import * as example</li>
</ul>
]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 组件间通信六种方式</title>
    <url>/2021/08/04/Vue-comm_com/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>组件是 vue.js最强大的功能之一，而组件实例的作用域是相互独立的，这就意味着不同组件之间的数据无法相互引用。一般来说，组件可以有以下几种关系：</p>
<img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/v-4.png" style="zoom: 80%;">

<p>如上图所示，A 和 B、B 和 C、B 和 D 都是父子关系，C 和 D 是兄弟关系，A 和 C 是隔代关系（可能隔多代）。</p>
<p>针对不同的使用场景，如何选择行之有效的通信方式？这是我们所要探讨的主题。本文总结了vue组件间通信的几种方式，如props、<code>$emit</code>/<code>$on</code>、vuex、<code>$parent</code> / <code>$children</code>、<code>$attrs</code>/<code>$listeners</code>和provide/inject</p>
<h2 id="方法一、props-emit"><a href="#方法一、props-emit" class="headerlink" title="方法一、props / $emit"></a>方法一、<code>props</code> / <code>$emit</code></h2><p>父组件A通过props的方式向子组件B传递，B to A 通过在 B 组件中 $emit, A 组件中 v-on 的方式实现。</p>
<p>接下来我们通过一个例子，说明父组件如何向子组件传递值：在子组件Users.vue中如何获取父组件App.vue中的数据 <code>users:[&quot;Henry&quot;,&quot;Bucky&quot;,&quot;Emily&quot;]</code></p>
<p>//App.vue父组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;users v-bind:users=&quot;users&quot;&gt;&lt;/users&gt;//前者自定义名称便于子组件调用，后者要传递数据名</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Users from &quot;./components/Users&quot;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">      users:[&quot;Henry&quot;,&quot;Bucky&quot;,&quot;Emily&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components:&#123;</span><br><span class="line">    &quot;users&quot;:Users</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//users子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li v-for=&quot;user in users&quot;&gt;&#123;&#123;user&#125;&#125;&lt;/li&gt;//遍历传递过来的值，然后呈现到页面</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;HelloWorld&#x27;,</span><br><span class="line">  props:&#123;</span><br><span class="line">    users:&#123;           //这个就是父组件中子标签自定义名字</span><br><span class="line">      type:Array,</span><br><span class="line">      required:true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>总结：父组件通过props向下传递数据给子组件。注：组件中的数据共有三种形式：data、props、computed</strong></p>
<h3 id="子组件向父组件传值（通过事件形式）"><a href="#子组件向父组件传值（通过事件形式）" class="headerlink" title="子组件向父组件传值（通过事件形式）"></a>子组件向父组件传值（通过事件形式）</h3><p>接下来我们通过一个例子，说明子组件如何向父组件传递值：当我们点击“Vue.js Demo”后，子组件向父组件传递值，文字由原来的“传递的是一个值”变成“子向父组件传值”，实现子组件向父组件值的传递。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/v-5.png" alt="子组件向父组件传值之前"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;h1 @click=&quot;changeTitle&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;//绑定一个点击事件</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;app-header&#x27;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      title:&quot;Vue.js Demo&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    changeTitle() &#123;</span><br><span class="line">      this.$emit(&quot;titleChanged&quot;,&quot;子向父组件传值&quot;);//自定义事件  传递值“子向父组件传值”</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;app-header v-on:titleChanged=&quot;updateTitle&quot; &gt;&lt;/app-header&gt;//与子组件titleChanged自定义事件保持一致</span><br><span class="line">   // updateTitle($event)接受传递过来的文字</span><br><span class="line">    &lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Header from &quot;./components/Header&quot;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">      title:&quot;传递的是一个值&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    updateTitle(e)&#123;   //声明这个函数</span><br><span class="line">      this.title = e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components:&#123;</span><br><span class="line">   &quot;app-header&quot;:Header,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>总结：子组件通过events给父组件发送消息，实际上就是子组件把自己的数据发送到父组件。</strong></p>
<h2 id="方法二、-emit-on"><a href="#方法二、-emit-on" class="headerlink" title="方法二、$emit/$on"></a>方法二、<code>$emit</code>/<code>$on</code></h2><p><strong>这种方法通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件,巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级</strong>。当我们的项目比较大时，可以选择更好的状态管理解决方案vuex。</p>
<h3 id="具体实现方式："><a href="#具体实现方式：" class="headerlink" title="具体实现方式："></a>具体实现方式：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var Event=new Vue();</span><br><span class="line">Event.$emit(事件名,数据);</span><br><span class="line">Event.$on(事件名,data =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>假设兄弟组件有三个，分别是A、B、C组件，C组件如何获取A或者B组件的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;itany&quot;&gt;</span><br><span class="line">	&lt;my-a&gt;&lt;/my-a&gt;</span><br><span class="line">	&lt;my-b&gt;&lt;/my-b&gt;</span><br><span class="line">	&lt;my-c&gt;&lt;/my-c&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;template id=&quot;a&quot;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h3&gt;A组件：&#123;&#123;name&#125;&#125;&lt;/h3&gt;</span><br><span class="line">    &lt;button @click=&quot;send&quot;&gt;将数据发送给C组件&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template id=&quot;b&quot;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h3&gt;B组件：&#123;&#123;age&#125;&#125;&lt;/h3&gt;</span><br><span class="line">    &lt;button @click=&quot;send&quot;&gt;将数组发送给C组件&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template id=&quot;c&quot;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h3&gt;C组件：&#123;&#123;name&#125;&#125;，&#123;&#123;age&#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var Event = new Vue();//定义一个空的Vue实例</span><br><span class="line">var A = &#123;</span><br><span class="line">	template: &#x27;#a&#x27;,</span><br><span class="line">	data() &#123;</span><br><span class="line">	  return &#123;</span><br><span class="line">	    name: &#x27;tom&#x27;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	methods: &#123;</span><br><span class="line">	  send() &#123;</span><br><span class="line">	    Event.$emit(&#x27;data-a&#x27;, this.name);</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var B = &#123;</span><br><span class="line">	template: &#x27;#b&#x27;,</span><br><span class="line">	data() &#123;</span><br><span class="line">	  return &#123;</span><br><span class="line">	    age: 20</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	methods: &#123;</span><br><span class="line">	  send() &#123;</span><br><span class="line">	    Event.$emit(&#x27;data-b&#x27;, this.age);</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var C = &#123;</span><br><span class="line">	template: &#x27;#c&#x27;,</span><br><span class="line">	data() &#123;</span><br><span class="line">	  return &#123;</span><br><span class="line">	    name: &#x27;&#x27;,</span><br><span class="line">	    age: &quot;&quot;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	mounted() &#123;//在模板编译完成后执行</span><br><span class="line">	 Event.$on(&#x27;data-a&#x27;,name =&gt; &#123;</span><br><span class="line">	     this.name = name;//箭头函数内部不会产生新的this，这边如果不用=&gt;,this指代Event</span><br><span class="line">	 &#125;)</span><br><span class="line">	 Event.$on(&#x27;data-b&#x27;,age =&gt; &#123;</span><br><span class="line">	     this.age = age;</span><br><span class="line">	 &#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">	el: &#x27;#itany&#x27;,</span><br><span class="line">	components: &#123;</span><br><span class="line">	  &#x27;my-a&#x27;: A,</span><br><span class="line">	  &#x27;my-b&#x27;: B,</span><br><span class="line">	  &#x27;my-c&#x27;: C</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);	</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/v-1.gif"></p>
<p><code>$on</code> 监听了自定义事件 data-a和data-b，因为有时不确定何时会触发事件，一般会在 mounted 或 created 钩子中来监听。</p>
<h2 id="方法三、vuex"><a href="#方法三、vuex" class="headerlink" title="方法三、vuex"></a>方法三、vuex</h2><p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/v-6.png" alt="image"></p>
<h3 id="简要介绍Vuex原理"><a href="#简要介绍Vuex原理" class="headerlink" title="简要介绍Vuex原理"></a>简要介绍Vuex原理</h3><p>Vuex实现了一个单向数据流，在全局拥有一个State存放数据，当组件要更改State中的数据时，必须通过Mutation进行，Mutation同时提供了订阅者模式供外部插件调用获取State数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走Action，但Action也是无法直接修改State的，还是需要通过Mutation来修改State的数据。最后，根据State的变化，渲染到视图上。</p>
<h3 id="简要介绍各模块在流程中的功能："><a href="#简要介绍各模块在流程中的功能：" class="headerlink" title="简要介绍各模块在流程中的功能："></a>简要介绍各模块在流程中的功能：</h3><ul>
<li>Vue Components：Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。</li>
<li>dispatch：操作行为触发方法，是唯一能执行action的方法。</li>
<li>actions：<strong>操作行为处理模块,由组件中的<code>$store.dispatch(&#39;action 名称&#39;, data1)</code>来触发。然后由commit()来触发mutation的调用 , 间接更新 state</strong>。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。</li>
<li>commit：状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。</li>
<li>mutations：<strong>状态改变操作方法，由actions中的<code>commit(&#39;mutation 名称&#39;)</code>来触发</strong>。是Vuex修改state的唯一推荐方法。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。</li>
<li>state：页面状态管理容器对象。集中存储Vue components中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。</li>
<li>getters：state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。</li>
</ul>
<h3 id="Vuex与localStorage"><a href="#Vuex与localStorage" class="headerlink" title="Vuex与localStorage"></a>Vuex与localStorage</h3><p>vuex 是 vue 的状态管理器，存储的数据是响应式的。但是并不会保存起来，刷新之后就回到了初始状态，<strong>具体做法应该在vuex里数据改变的时候把数据拷贝一份保存到localStorage里面，刷新之后，如果localStorage里有保存的数据，取出来再替换store里的state。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> defaultCity = <span class="string">&quot;上海&quot;</span></span><br><span class="line"><span class="keyword">try</span> &#123;   <span class="comment">// 用户关闭了本地存储功能，此时在外层加个try...catch</span></span><br><span class="line">  <span class="keyword">if</span> (!defaultCity)&#123;</span><br><span class="line">    defaultCity = <span class="built_in">JSON</span>.parse(<span class="built_in">window</span>.localStorage.getItem(<span class="string">&#x27;defaultCity&#x27;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">city</span>: defaultCity</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">changeCity</span>(<span class="params">state, city</span>)</span> &#123;</span><br><span class="line">      state.city = city</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.localStorage.setItem(<span class="string">&#x27;defaultCity&#x27;</span>, <span class="built_in">JSON</span>.stringify(state.city));</span><br><span class="line">      <span class="comment">// 数据改变的时候把数据拷贝一份保存到localStorage里面</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是：由于vuex里，我们保存的状态，都是数组，而localStorage只支持字符串，所以需要用JSON转换：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(state.subscribeList);   <span class="comment">// array -&gt; string</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">window</span>.localStorage.getItem(<span class="string">&quot;subscribeList&quot;</span>));    <span class="comment">// string -&gt; array </span></span><br></pre></td></tr></table></figure>

<h2 id="方法四、-attrs-listeners"><a href="#方法四、-attrs-listeners" class="headerlink" title="方法四、$attrs/$listeners"></a>方法四、<code>$attrs</code>/<code>$listeners</code></h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>多级组件嵌套需要传递数据时，通常使用的方法是通过vuex。但如果仅仅是传递数据，而不做中间处理，使用 vuex 处理，未免有点大材小用。为此Vue2.4 版本提供了另一种方法—-<code>$attrs</code>/<code>$listeners</code></p>
<ul>
<li><code>$attrs</code>：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=”$attrs” 传入内部组件。通常配合 inheritAttrs 选项一起使用。</li>
<li><code>$listeners</code>：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件</li>
</ul>
<p>接下来我们看个跨级通信的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// index.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;浪里行舟&lt;/h2&gt;</span><br><span class="line">    &lt;child-com1</span><br><span class="line">      :foo=&quot;foo&quot;</span><br><span class="line">      :boo=&quot;boo&quot;</span><br><span class="line">      :coo=&quot;coo&quot;</span><br><span class="line">      :doo=&quot;doo&quot;</span><br><span class="line">      title=&quot;前端工匠&quot;</span><br><span class="line">    &gt;&lt;/child-com1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const childCom1 = () =&gt; import(&quot;./childCom1.vue&quot;);</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123; childCom1 &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      foo: &quot;Javascript&quot;,</span><br><span class="line">      boo: &quot;Html&quot;,</span><br><span class="line">      coo: &quot;CSS&quot;,</span><br><span class="line">      doo: &quot;Vue&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// childCom1.vue</span><br><span class="line">&lt;template class=&quot;border&quot;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;foo: &#123;&#123; foo &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;childCom1的$attrs: &#123;&#123; $attrs &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;child-com2 v-bind=&quot;$attrs&quot;&gt;&lt;/child-com2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const childCom2 = () =&gt; import(&quot;./childCom2.vue&quot;);</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    childCom2</span><br><span class="line">  &#125;,</span><br><span class="line">  inheritAttrs: false, // 可以关闭自动挂载到组件根元素上的没有在props声明的属性</span><br><span class="line">  props: &#123;</span><br><span class="line">    foo: String // foo作为props属性绑定</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(this.$attrs); // &#123; &quot;boo&quot;: &quot;Html&quot;, &quot;coo&quot;: &quot;CSS&quot;, &quot;doo&quot;: &quot;Vue&quot;, &quot;title&quot;: &quot;前端工匠&quot; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// childCom2.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;border&quot;&gt;</span><br><span class="line">    &lt;p&gt;boo: &#123;&#123; boo &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;childCom2: &#123;&#123; $attrs &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;child-com3 v-bind=&quot;$attrs&quot;&gt;&lt;/child-com3&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const childCom3 = () =&gt; import(&quot;./childCom3.vue&quot;);</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    childCom3</span><br><span class="line">  &#125;,</span><br><span class="line">  inheritAttrs: false,</span><br><span class="line">  props: &#123;</span><br><span class="line">    boo: String</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(this.$attrs); // &#123; &quot;coo&quot;: &quot;CSS&quot;, &quot;doo&quot;: &quot;Vue&quot;, &quot;title&quot;: &quot;前端工匠&quot; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// childCom3.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;border&quot;&gt;</span><br><span class="line">    &lt;p&gt;childCom3: &#123;&#123; $attrs &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    coo: String,</span><br><span class="line">    title: String</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/v-7.png"></p>
<h2 id="方法五、provide-inject"><a href="#方法五、provide-inject" class="headerlink" title="方法五、provide/inject"></a>方法五、provide/inject</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Vue2.2.0新增API,这对选项需要一起使用，<strong>以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效</strong>。一言而蔽之：祖先组件中通过provider来提供变量，然后在子孙组件中通过inject来注入变量。 <strong>provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系</strong>。</p>
<h3 id="举个例子-1"><a href="#举个例子-1" class="headerlink" title="举个例子"></a>举个例子</h3><p>假设有两个组件： A.vue 和 B.vue，B 是 A 的子组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// A.vue</span><br><span class="line">export default &#123;</span><br><span class="line">  provide: &#123;</span><br><span class="line">    name: &#x27;浪里行舟&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// B.vue</span><br><span class="line">export default &#123;</span><br><span class="line">  inject: [&#x27;name&#x27;],</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    console.log(this.name);  // 浪里行舟</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在 A.vue 里，我们设置了一个 <strong>provide: name</strong>，值为 浪里行舟，它的作用就是将 <strong>name</strong> 这个变量提供给它的所有子组件。而在 B.vue 中，通过 <code>inject</code> 注入了从 A 组件中提供的 <strong>name</strong> 变量，那么在组件 B 中，就可以直接通过 <strong>this.name</strong> 访问这个变量了，它的值也是 浪里行舟。这就是 provide / inject API 最核心的用法。</p>
<p>需要注意的是：<strong>provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的</strong>—-vue官方文档 所以，上面 A.vue 的 name 如果改变了，B.vue 的 this.name 是不会改变的，仍然是 浪里行舟。</p>
<h3 id="provide与inject-怎么实现数据响应式"><a href="#provide与inject-怎么实现数据响应式" class="headerlink" title="provide与inject 怎么实现数据响应式"></a>provide与inject 怎么实现数据响应式</h3><p>一般来说，有两种办法：</p>
<ul>
<li>provide祖先组件的实例，然后在子孙组件中注入依赖，这样就可以在子孙组件中直接修改祖先组件的实例的属性，不过这种方法有个缺点就是这个实例上挂载很多没有必要的东西比如props，methods</li>
<li>使用2.6最新API Vue.observable 优化响应式 provide(推荐)</li>
</ul>
<p>我们来看个例子：孙组件D、E和F获取A组件传递过来的color值，并能实现数据响应式变化，即A组件的color变化后，组件D、E、F会跟着变（核心代码如下：）</p>
<p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/v-8.png"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A 组件 </span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>A 组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;() =&gt; changeColor()&quot;</span>&gt;</span>改变color<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">ChildrenB</span> /&gt;</span></span></span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">ChildrenC</span> /&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">......</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">color</span>: <span class="string">&quot;blue&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// provide() &#123;</span></span><br><span class="line">  <span class="comment">//   return &#123;</span></span><br><span class="line">  <span class="comment">//     theme: &#123;</span></span><br><span class="line">  <span class="comment">//       color: this.color //这种方式绑定的数据并不是可响应的</span></span><br><span class="line">  <span class="comment">//     &#125; // 即A组件的color变化后，组件D、E、F不会跟着变</span></span><br><span class="line">  <span class="comment">//   &#125;;</span></span><br><span class="line">  <span class="comment">// &#125;,</span></span><br><span class="line">  <span class="function"><span class="title">provide</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">theme</span>: <span class="built_in">this</span><span class="comment">//方法一：提供祖先组件的实例</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">changeColor</span>(<span class="params">color</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (color) &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = <span class="built_in">this</span>.color === <span class="string">&quot;blue&quot;</span> ? <span class="string">&quot;red&quot;</span> : <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 方法二:使用2.6最新API Vue.observable 优化响应式 provide</span></span><br><span class="line">  <span class="comment">// provide() &#123;</span></span><br><span class="line">  <span class="comment">//   this.theme = Vue.observable(&#123;</span></span><br><span class="line">  <span class="comment">//     color: &quot;blue&quot;</span></span><br><span class="line">  <span class="comment">//   &#125;);</span></span><br><span class="line">  <span class="comment">//   return &#123;</span></span><br><span class="line">  <span class="comment">//     theme: this.theme</span></span><br><span class="line">  <span class="comment">//   &#125;;</span></span><br><span class="line">  <span class="comment">// &#125;,</span></span><br><span class="line">  <span class="comment">// methods: &#123;</span></span><br><span class="line">  <span class="comment">//   changeColor(color) &#123;</span></span><br><span class="line">  <span class="comment">//     if (color) &#123;</span></span><br><span class="line">  <span class="comment">//       this.theme.color = color;</span></span><br><span class="line">  <span class="comment">//     &#125; else &#123;</span></span><br><span class="line">  <span class="comment">//       this.theme.color = this.theme.color === &quot;blue&quot; ? &quot;red&quot; : &quot;blue&quot;;</span></span><br><span class="line">  <span class="comment">//     &#125;</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// F 组件 </span><br><span class="line">&lt;template functional&gt;</span><br><span class="line">  &lt;div class=&quot;border2&quot;&gt;</span><br><span class="line">    &lt;h3 :style=&quot;&#123; color: injections.theme.color &#125;&quot;&gt;F 组件&lt;/h3&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  inject: &#123;</span><br><span class="line">    theme: &#123;</span><br><span class="line">      //函数式组件取值不一样</span><br><span class="line">      default: () =&gt; (&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>虽说provide 和 inject 主要为高阶插件/组件库提供用例，但如果你能在业务中熟练运用，可以达到事半功倍的效果！</p>
<h2 id="方法六、-parent-children与-ref"><a href="#方法六、-parent-children与-ref" class="headerlink" title="方法六、$parent / $children与 ref"></a>方法六、<code>$parent</code> / <code>$children</code>与 <code>ref</code></h2><ul>
<li><code>ref</code>：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</li>
<li><code>$parent</code> / <code>$children</code>：访问父 / 子实例</li>
</ul>
<p>需要注意的是：这两种都是直接得到组件实例，使用后可以直接调用组件的方法或访问数据。我们先来看个用 <code>ref</code>来访问组件的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// component-a 子组件</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      title: &#x27;Vue.js&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sayHello () &#123;</span><br><span class="line">      window.alert(&#x27;Hello&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;component-a ref=&quot;comA&quot;&gt;&lt;/component-a&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      const comA = this.$refs.comA;</span><br><span class="line">      console.log(comA.title);  // Vue.js</span><br><span class="line">      comA.sayHello();  // 弹窗</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>不过，<strong>这两种方法的弊端是，无法在跨级或兄弟间通信</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// parent.vue</span><br><span class="line">&lt;component-a&gt;&lt;/component-a&gt;</span><br><span class="line">&lt;component-b&gt;&lt;/component-b&gt;</span><br><span class="line">&lt;component-b&gt;&lt;/component-b&gt;</span><br></pre></td></tr></table></figure>

<p>我们想在 component-a 中，访问到引用它的页面中（这里就是 parent.vue）的两个 component-b 组件，那这种情况下，就得配置额外的插件或工具了，比如 Vuex 和 Bus 的解决方案。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>常见使用场景可以分为三类：</p>
<ul>
<li>父子通信：</li>
</ul>
<p>父向子传递数据是通过 props，子向父是通过 events（<code>$emit</code>）；通过父链 / 子链也可以通信（<code>$parent</code> / <code>$children</code>）；ref 也可以访问组件实例；provide / inject API；<code>$attrs/$listeners</code></p>
<ul>
<li>兄弟通信：</li>
</ul>
<p>Bus；Vuex</p>
<ul>
<li>跨级通信：</li>
</ul>
<p>Bus；Vuex；provide / inject API、<code>$attrs/$listeners</code></p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底搞懂CSS层叠上下文、层叠等级、层叠顺序、z-index</title>
    <url>/2021/08/04/z-index/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近，在项目中遇到一个关于CSS中元素<code>z-index</code>属性的问题，具体问题不太好描述，总结起来就是当给元素和父元素色设置<code>position</code>属性和<code>z-index</code>相关属性后，页面上渲染的元素层级结果和我预想的不一样。根据自己之前的理解，也没找到一个合理的解释。我知道，肯定是我对相关属性的细节理解存在问题，所以结合官方文档和在网上各种搜集整理，明白了其中的原因。写下这篇文章，和大家分享有关CSS中<code>层叠上下文</code>、<code>层叠等级</code>、<code>层叠顺序</code>以及<code>z-index</code>相关的一整套技术细节。</p>
<h3 id="一个“片面”的理解"><a href="#一个“片面”的理解" class="headerlink" title="一个“片面”的理解"></a>一个“片面”的理解</h3><p>以往，由于自己使用<code>z-index</code>的频率不大，所以对这个CSS属性存在比较片面的认识。一直认为<code>z-index</code>就是用来描述定义一个元素在屏幕<code>Z轴</code>上的堆叠顺序。<code>z-index</code>值越大在<code>Z轴</code>上就越靠上，也就是离屏幕观察者越近。最后才发现这个认识存在很大的问题：</p>
<ol>
<li>首先，<code>z-index</code>属性值并不是在任何元素上都有效果。它<strong>仅在</strong>定位元素（定义了<code>position</code>属性，且属性值为非<code>static</code>值的元素）上有效果。</li>
<li>判断元素在<code>Z轴</code>上的堆叠顺序，不仅仅是直接比较两个元素的<code>z-index</code>值的大小，这个堆叠顺序实际由元素的<strong>层叠上下文</strong>、<strong>层叠等级</strong>共同决定。</li>
</ol>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/30/165890e473ce9cd3~tplv-t2oaga2asx-image.image" alt="img"></p>
<p>要想完全理解一个东西，首先要明白它是什么，也就是它的定义。我们先看看上面提到的<code>层叠上下文</code>、<code>层叠等级</code>、<code>层叠顺序</code>都是什么？定义又太过抽象，后面会再用一个具象的比喻来让你彻底明白它们到底是什么，有什么联系。</p>
<h3 id="什么是“层叠上下文”"><a href="#什么是“层叠上下文”" class="headerlink" title="什么是“层叠上下文”"></a>什么是“层叠上下文”</h3><p>层叠上下文(stacking context)，是HTML中一个三维的概念。在CSS2.1规范中，每个盒模型的位置是三维的，分别是平面画布上的<code>X轴</code>，<code>Y轴</code>以及表示层叠的<code>Z轴</code>。一般情况下，元素在页面上沿<code>X轴Y轴</code>平铺，我们察觉不到它们在<code>Z轴</code>上的层叠关系。而一旦元素发生堆叠，这时就能发现某个元素可能覆盖了另一个元素或者被另一个元素覆盖。</p>
<p>如果一个元素含有层叠上下文，(也就是说它是层叠上下文元素)，我们可以理解为这个元素在<code>Z轴</code>上就“高人一等”，最终表现就是它离屏幕观察者更近。</p>
<blockquote>
<p><strong>具象的比喻</strong>：你可以把层叠上下文元素理解为理解为<strong>该元素当了官</strong>，而其他非层叠上下文元素则可以理解为普通群众。凡是“当了官的元素”就比普通元素等级要高，也就是说元素在<code>Z轴</code>上更靠上，更靠近观察者。</p>
</blockquote>
<h3 id="什么是“层叠等级”"><a href="#什么是“层叠等级”" class="headerlink" title="什么是“层叠等级”"></a>什么是“层叠等级”</h3><p>那么，层叠等级指的又是什么？层叠等级(stacking level，叫“层叠级别”/“层叠水平”也行)</p>
<ul>
<li>在同一个层叠上下文中，它描述定义的是该层叠上下文中的层叠上下文元素在<code>Z轴</code>上的上下顺序。</li>
<li>在其他普通元素中，它描述定义的是这些普通元素在<code>Z轴</code>上的上下顺序。</li>
</ul>
<p>说到这，可能很多人疑问了，不论在层叠上下文中还是在普通元素中，层叠等级都表示元素在<code>Z轴</code>上的上下顺序，那就直接说它描述定义了所有元素在<code>Z轴</code>上的上下顺序就OK啊！为什么要分开描述？</p>
<p>为了说明原因，先举个栗子：</p>
<blockquote>
<p><strong>具象的比喻</strong>：我们之前说到，处于层叠上下文中的元素，就像是元素当了官，等级自然比普通元素高。再想象一下，假设一个官员A是个省级领导，他下属有一个秘书a-1，家里有一个保姆a-2。另一个官员B是一个县级领导，他下属有一个秘书b-1，家里有一个保姆b-2。a-1和b-1虽然都是秘书，但是你想一个省级领导的秘书和一个县级领导的秘书之间有可比性么？甚至保姆a-2都要比秘书b-1的等级高得多。谁大谁小，谁高谁低一目了然，所以根本没有比较的意义。只有在A下属的a-1、a-2以及B下属的b-1、b-2中相互比较大小高低才有意义。</p>
</blockquote>
<p><strong>再类比回“层叠上下文”和“层叠等级”，就得出一个结论：</strong></p>
<ol>
<li>普通元素的层叠等级优先由其所在的层叠上下文决定。</li>
<li>层叠等级的比较只有在当前层叠上下文元素中才有意义。不同层叠上下文中比较层叠等级是没有意义的。</li>
</ol>
<h3 id="如何产生“层叠上下文”"><a href="#如何产生“层叠上下文”" class="headerlink" title="如何产生“层叠上下文”"></a>如何产生“层叠上下文”</h3><p>前面说了那么多，知道了“层叠上下文”和“层叠等级”，其中还有一个最关键的问题：到底如何产生层叠上下文呢？如何让一个元素变成层叠上下文元素呢？</p>
<p>其实，层叠上下文也基本上是有一些特定的CSS属性创建的，一般有3种方法：</p>
<ol>
<li><code>HTML</code>中的根元素<code>&lt;html&gt;&lt;/html&gt;</code>本身j就具有层叠上下文，称为“根层叠上下文”。</li>
<li>普通元素设置<code>position</code>属性为<strong>非</strong><code>static</code>值并设置<code>z-index</code>属性为具体数值，产生层叠上下文。</li>
<li>CSS3中的新属性也可以产生层叠上下文。</li>
</ol>
<p>至此，终于可以上代码了，我们用代码说话，来验证上面的结论：</p>
<p><strong>栗子1:</strong> <strong>有两个div，p.a、p.b被包裹在一个div里，p.c被包裹在另一个盒子里，只为.a、.b、.c设置<code>position</code>和<code>z-index</code>属性</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-tag">div</span> &#123;  </span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: relative;  </span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100px</span>;  </span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100px</span>;  </span></span><br><span class="line"><span class="css">  &#125;  </span></span><br><span class="line"><span class="css">  <span class="selector-tag">p</span> &#123;  </span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;  </span></span><br><span class="line"><span class="css">    <span class="attribute">font-size</span>: <span class="number">20px</span>;  </span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100px</span>;  </span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100px</span>;  </span></span><br><span class="line"><span class="css">  &#125;  </span></span><br><span class="line"><span class="css">  <span class="selector-class">.a</span> &#123;  </span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: blue;  </span></span><br><span class="line"><span class="css">    <span class="attribute">z-index</span>: <span class="number">1</span>;  </span></span><br><span class="line"><span class="css">  &#125;  </span></span><br><span class="line"><span class="css">  <span class="selector-class">.b</span> &#123;  </span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: green;  </span></span><br><span class="line"><span class="css">    <span class="attribute">z-index</span>: <span class="number">2</span>;  </span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">20px</span>;  </span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>: <span class="number">20px</span>;  </span></span><br><span class="line"><span class="css">  &#125;  </span></span><br><span class="line"><span class="css">  <span class="selector-class">.c</span> &#123;  </span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: red;  </span></span><br><span class="line"><span class="css">    <span class="attribute">z-index</span>: <span class="number">3</span>;  </span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: -<span class="number">20px</span>;  </span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>: <span class="number">40px</span>;  </span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;b&quot;</span>&gt;</span>b<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;c&quot;</span>&gt;</span>c<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/30/165890e9dcadf485~tplv-t2oaga2asx-image.image" alt="img"></p>
<p>因为p.a、p.b、p.c三个的父元素div都没有设置<code>z-index</code>，所以不会产生层叠上下文，所以.a、.b、.c都处于由<code>&lt;html&gt;&lt;/html&gt;</code>标签产生的“根层叠上下文”中，属于同一个层叠上下文，此时谁的<code>z-index</code>值大，谁在上面。</p>
<p><strong>栗子2：</strong> <strong>有两个div，p.a、p.b被包裹在一个div里，p.c被包裹在另一个盒子里，同时为两个div和.a、.b、.c设置<code>position</code>和<code>z-index</code>属性</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">z-index</span>: <span class="number">2</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.box2</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">z-index</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.a</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="css">    <span class="attribute">z-index</span>: <span class="number">100</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.b</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">z-index</span>: <span class="number">200</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.c</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: -<span class="number">20px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">z-index</span>: <span class="number">9999</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;b&quot;</span>&gt;</span>b<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;c&quot;</span>&gt;</span>c<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/30/165890ecb78125b2~tplv-t2oaga2asx-image.image" alt="img"></p>
<p>我们发下，虽然<code>p.c</code>元素的<code>z-index</code>值为9999，远大于<code>p.a</code>和<code>p.b</code>的<code>z-index</code>值，但是由于<code>p.a</code>、<code>p.b</code>的父元素<code>div.box1</code>产生的层叠上下文的<code>z-index</code>的值为2，<code>p.c</code>的父元素<code>div.box2</code>所产生的层叠上下文的<code>z-index</code>值为1，所以<code>p.c</code>永远在<code>p.a</code>和<code>p.b</code>下面。</p>
<p>同时，如果我们只更改<code>p.a</code>和<code>p.b</code>的<code>z-index</code>值，由于这两个元素都在父元素<code>div.box1</code>产生的层叠上下文中，所以，谁的<code>z-index</code>值大，谁在上面。</p>
<h3 id="什么是“层叠顺序”"><a href="#什么是“层叠顺序”" class="headerlink" title="什么是“层叠顺序”"></a>什么是“层叠顺序”</h3><p>说完“层叠上下文”和“层叠等级”，我们再来说说“层叠顺序”。“层叠顺序”(stacking order)表示元素发生层叠时按照特定的顺序规则在<code>Z轴</code>上垂直显示。<strong>由此可见，前面所说的“层叠上下文”和“层叠等级”是一种概念，而这里的“层叠顺序”是一种规则。</strong></p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/30/1658910c5cb364b6~tplv-t2oaga2asx-image.image" alt="img"></p>
<p>在不考虑CSS3的情况下，当元素发生层叠时，层叠顺讯遵循上面途中的规则。 <strong>这里值得注意的是：</strong></p>
<ol>
<li>左上角”层叠上下文<code>background/border</code>“指的是层叠上下文元素的背景和边框。</li>
<li><code>inline/inline-block</code>元素的层叠顺序要高于<code>block</code>(块级)/<code>float</code>(浮动)元素。</li>
<li>单纯考虑层叠顺序，<code>z-index: auto</code>和<code>z-index: 0</code>在同一层级，但这两个属性值本身是有根本区别的。</li>
</ol>
<blockquote>
<p>对于上面第2条，为什么<code>inline/inline-block</code>元素的层叠顺序要高于<code>block</code>(块级)/<code>float</code>(浮动)元素？这个大家可以思考一下！ 其实很简单，像<code>border/background</code>属于装饰元素的属性，浮动和块级元素一般用来页面布局，而网页设计之初最重要的就是文字内容，所以在发生层叠时会优先显示文字内容，保证其不被覆盖。</p>
</blockquote>
<h3 id="你要的“套路”"><a href="#你要的“套路”" class="headerlink" title="你要的“套路”"></a>你要的“套路”</h3><p>上面说了那么多，可能你还是有点懵。这么多概念规则，来点最实际的，有没有一个“套路”当遇到元素层叠时，能很清晰地判断出他们谁在上谁在下呢？答案是——肯定有啊！</p>
<blockquote>
<p>1、首先先看要比较的两个元素是否处于同一个层叠上下文中：    1.1如果是，谁的层叠等级大，谁在上面（怎么判断层叠等级大小呢？——看“层叠顺序”图）。    1.2如果两个元素不在统一层叠上下文中，请先比较他们所处的层叠上下文的层叠等级。 2、当两个元素层叠等级相同、层叠顺序相同时，在DOM结构中后面的元素层叠等级在前面元素之上。</p>
</blockquote>
<h3 id="光说不练假把式"><a href="#光说不练假把式" class="headerlink" title="光说不练假把式"></a>光说不练假把式</h3><p>对于技术学习，代码展示是最直观最易懂的方式之一。话不多说，直接上代码，我们通过以下几个“栗子”，来进一步验证掌握上面的结论。</p>
<p><strong>栗子3：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.box1</span>, <span class="selector-class">.box2</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">    <span class="attribute">z-index</span>: auto;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.child1</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background</span>: <span class="number">#168bf5</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">z-index</span>: <span class="number">2</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.child2</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background</span>: <span class="number">#32c292</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">z-index</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/30/165890f2191f7d05~tplv-t2oaga2asx-image.image" alt="img"></p>
<p><strong>说明：</strong><code>.box1/.box2</code>虽然设置了<code>position: relative</code>，但是<code>z-index: auto</code>的情况下，这两个<code>div</code>还是普通元素，并没有产生层叠上下文。所以，<code>child1/.child2</code>属于<code>&lt;html&gt;&lt;/html&gt;</code>元素的“根层叠上下文”中，此时，<strong>谁的<code>z-index</code>值大，谁在上面</strong>。</p>
<p><strong>栗子4：</strong></p>
<p>对于栗子1中的CSS代码，我们只把<code>.box1/.box2</code>的<code>z-index</code>属性值改为<code>数值0</code>，其余不变。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box1</span>, <span class="selector-class">.box2</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/30/165890f4aabe3939~tplv-t2oaga2asx-image.image" alt="img"></p>
<p><strong>说明：</strong> 此时，我们发现，仅仅修改了<code>.box1/.box2</code>的<code>z-index</code>属性值改为<code>数值0</code>，最终结果完全相反。这时<code>.child2</code>覆盖在了<code>.child1</code>上面。原因是什么呢？很简单：因为设置<code>z-index: 0</code>后，<code>.box1/.box2</code>产生了各自的层叠上下文，这时候要比较<code>.child1/.child2</code>的层叠关系完全由父元素<code>.box1/.box2</code>的层叠关系决定。但是<code>.box1/.box2</code>的<code>z-index</code>值都为<code>0</code>，都是块级元素（所以它们的层叠等级，层叠顺序是相同的），这种情况下，在<code>DOM</code>结构中<strong>后面的覆盖前面的</strong>，所以<code>.child2</code>就在上面。</p>
<h3 id="CSS3中的属性对层叠上下文的影响"><a href="#CSS3中的属性对层叠上下文的影响" class="headerlink" title="CSS3中的属性对层叠上下文的影响"></a>CSS3中的属性对层叠上下文的影响</h3><p>CSS3中出现了很多新属性，其中一些属性对层叠上下文也产生了很大的影响。如下：</p>
<ol>
<li>父元素的display属性值为<code>flex|inline-flex</code>，子元素<code>z-index</code>属性值不为<code>auto</code>的时候，子元素为层叠上下文元素；</li>
<li>元素的<code>opacity</code>属性值不是<code>1</code>；</li>
<li>元素的<code>transform</code>属性值不是<code>none</code>；</li>
<li>元素<code>mix-blend-mode属性值不是</code>normal`；</li>
<li>元素的<code>filter</code>属性值不是<code>none</code>；</li>
<li>元素的<code>isolation</code>属性值是<code>isolate</code>；</li>
<li><code>will-change</code>指定的属性值为上面任意一个；</li>
<li>元素的<code>-webkit-overflow-scrolling</code>属性值设置为<code>touch</code>。</li>
</ol>
<p>CSS3中，元素属性满足以上条件之一，就会产生层叠上下文。我们用第1条来做一个简单的解释说明。</p>
<p><strong>栗子5：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  <span class="selector-class">.box</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#168bf5</span>;</span><br><span class="line">    <span class="comment">/* 虽然设置了z-index，但是没有设置position，z-index无效，.parent还是普通元素，没有产生层叠上下文 */</span></span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#32d19c</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;parent&quot;&gt;</span><br><span class="line">      parent</span><br><span class="line">      &lt;<span class="selector-tag">div</span> class=&quot;child&quot;&gt;child&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">  &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">body</span>&gt;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/30/165890f762484a78~tplv-t2oaga2asx-image.image" alt="img"></p>
<p><strong>说明：</strong> 我们发现，<code>.child</code>被<code>.parent</code>覆盖了。按照“套路”来分析一下： 虽然<code>.parent</code>设置了<code>z-index</code>属性值，但是没有设置<code>position</code>属性，<code>z-index</code>无效，所以没有产生层叠上下文，<code>.parent</code>还是普通的块级元素。此时，在层叠顺序规则中，<code>z-index</code>值小于<code>0</code>的<code>.child</code>会被普通的<code>block</code>块级元素<code>.parent</code>覆盖。</p>
<p><strong>栗子6：</strong></p>
<p>对于上面的栗子，我们只修改.box的属性，设置display: flex，其余属性和DOM结构不变。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/30/165890f9438f582c~tplv-t2oaga2asx-image.image" alt="img"></p>
<p><strong>说明：</strong> 当给<code>.box</code>设置<code>display: flex</code>时，<code>.parent</code>就变成层叠上下文元素，根据层叠顺序规则，层叠上下文元素的<code>background/border</code>的层叠等级小于<code>z-index</code>值小于<code>0</code>的元素的层叠等级，所以<code>z-index</code>值为<code>-1</code>的<code>.child</code>在<code>.parent</code>上面。</p>
<h3 id="小测试"><a href="#小测试" class="headerlink" title="小测试"></a>小测试</h3><p>下面的代码，我会把最终页面渲染的结果放在代码之后，有兴趣的“童鞋”可以分析一下，各个元素的层叠等级，最后来确定这些元素哪个在上哪个在下。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background</span>: <span class="number">#168bf5</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">z-index</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.child1</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background</span>: <span class="number">#32d19c</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">z-index</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.child2</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background</span>: <span class="number">#e4c950</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">z-index</span>: -<span class="number">1</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.child2-1</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background</span>: <span class="number">#e45050</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">60px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>: <span class="number">60px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">z-index</span>: <span class="number">9999</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.child2-2</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background</span>: <span class="number">#db68a7</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">top</span>: <span class="number">80px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">left</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">z-index</span>: -<span class="number">9999</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    parent</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child1&quot;</span>&gt;</span>child1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child2&quot;</span>&gt;</span></span><br><span class="line">      child2</span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child2-1&quot;</span>&gt;</span>child2-1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child2-2&quot;</span>&gt;</span>child2-2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/30/165890fc4aa5ba15~tplv-t2oaga2asx-image.image" alt="img"></p>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题及答案</title>
    <url>/2021/08/04/interview/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文面试的内容包含：HTML + CSS + JS + ES6 + Webpack + Vue + React + Node + HTTPS + 数据结构与算法 + Git 。</p>
<blockquote>
<p>复习前端面试的知识，是为了巩固前端的基础知识，最重要的还是平时的积累！</p>
</blockquote>
<p><code>注意</code>：文章的题与题之间用下划线分隔开，<strong>答案仅供参考</strong>。</p>
<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><h4 id="利用多个域名来存储网站资源"><a href="#利用多个域名来存储网站资源" class="headerlink" title="利用多个域名来存储网站资源"></a>利用多个域名来存储网站资源</h4><h5 id="CDN缓存更方便"><a href="#CDN缓存更方便" class="headerlink" title="CDN缓存更方便"></a>CDN缓存更方便</h5><p>CDN：是构建在网络之上的内容发布网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容发布、调度等功能模块，是用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要是内容存储和分布技术。简单来说，<strong>CDN主要用来使用户就近获取资源。</strong></p>
<h5 id="2-突破浏览器并发限制"><a href="#2-突破浏览器并发限制" class="headerlink" title="2. 突破浏览器并发限制"></a>2. 突破浏览器并发限制</h5><p>同一时间针对同一域名下的请求有一定数量限制，超过限制数目的请求会被阻塞。大多数浏览器的并发数量都控制在6以内。有些资源的请求时间很长，因而会阻塞其他资源的请求。因此，对于一些静态资源，如果放到不同的域名下面就能实现与其他资源的并发请求。</p>
<p>因而后来衍生了domain dash来加大并发数，但是过多的域名会使DNS解析负担加重，因此一般控制在2-4个。对于图片资源的加载，利用css sprites技术，结合background的定位在同一张图片中加载多个图片，这也是减少并发数量的一种常用方法</p>
<h5 id="3-Cookieless-节省带宽，尤其是上行带宽-一般比下行要慢。"><a href="#3-Cookieless-节省带宽，尤其是上行带宽-一般比下行要慢。" class="headerlink" title="3. Cookieless, 节省带宽，尤其是上行带宽 一般比下行要慢。"></a>3. Cookieless, 节省带宽，尤其是上行带宽 一般比下行要慢。</h5><p><strong>还有另外两个非常规原因</strong>:</p>
<h5 id="4-对于UGC的内容和主站隔离，防止不必要的安全问题。"><a href="#4-对于UGC的内容和主站隔离，防止不必要的安全问题。" class="headerlink" title="4. 对于UGC的内容和主站隔离，防止不必要的安全问题。"></a>4. 对于UGC的内容和主站隔离，防止不必要的安全问题。</h5><p>正是这个原因要求用户内容的域名必须不是自己主站的子域名，而是一个完全独立的第三方域名。</p>
<h5 id="5-数据做了划分，甚至切到了不同的物理集群，通过子域名来分流比较省事-这个可能被用的不多。"><a href="#5-数据做了划分，甚至切到了不同的物理集群，通过子域名来分流比较省事-这个可能被用的不多。" class="headerlink" title="5. 数据做了划分，甚至切到了不同的物理集群，通过子域名来分流比较省事. 这个可能被用的不多。"></a>5. 数据做了划分，甚至切到了不同的物理集群，通过子域名来分流比较省事. 这个可能被用的不多。</h5><h4 id="为什么利用多个域名来存储网站资源会更有效-？"><a href="#为什么利用多个域名来存储网站资源会更有效-？" class="headerlink" title="为什么利用多个域名来存储网站资源会更有效 ？"></a><strong>为什么利用多个域名来存储网站资源会更有效 ？</strong></h4><ul>
<li>确保用户在不同地区能用最快的速度打开网站，其中某个域名崩溃用户也能通过其他域名访问网站。</li>
<li>CDN 缓存更方便。简单来说，CDN 主要用来使用户就近获取资源。</li>
<li>突破浏览器并发限制。同一时间针对同一域名下的请求有一定数量限制，超过限制数目的请求会被阻塞。大多数浏览器的并发数量都控制在6以内。有些资源的请求时间很长，因而会阻塞其他资源的请求。因此，对于一些静态资源，如果放到不同的域名下面就能实现与其他资源的并发请求。</li>
<li>Cookieless, 节省带宽，尤其是上行带宽 一般比下行要慢。</li>
<li>对于 UGC 的内容和主站隔离，防止不必要的安全问题。</li>
<li>数据做了划分，甚至切到了不同的物理集群，通过子域名来分流比较省事. 这个可能被用的不多。</li>
</ul>
<hr>
<h4 id="window-常用属性与方法有哪些-？"><a href="#window-常用属性与方法有哪些-？" class="headerlink" title="window 常用属性与方法有哪些 ？"></a><strong>window 常用属性与方法有哪些 ？</strong></h4><p>window 对象的常用属性</p>
<ul>
<li>window.self 返回当前窗口的引用</li>
<li>window.parent  返回当前窗体的父窗体对象</li>
<li>window.top 返回当前窗体最顶层的父窗体的引用</li>
<li>window.outerwidth    返回当前窗口的外部宽</li>
<li>window.outerheight 返回当前窗口的外部高</li>
<li>window.innerwidth    返回当前窗口的可显示区域宽</li>
<li>window.innerheight 返回当前窗口的可显示区域高  提示：通过直接在 Chrome 控制台中输入 console.log(window) 可以查看到其所有的被当前浏览器支持的属性及值。</li>
</ul>
<p>window 对象的常用方法</p>
<ul>
<li>window.prompt()  弹出一个输入提示框，若用户点击了“取消”则返回 null</li>
<li>window.alert()  弹出一个警告框</li>
<li>window.confirm() 弹出一个确认框</li>
<li>window.close() 关闭当前浏览器窗口。 有些浏览器对此方法有限制。</li>
<li>window.open(uri, [name], [features]) 打开一个浏览器窗口，显示指定的网页。name 属性值可以是“_blank”、“_self”、“_parent”、“_top”、任意指定的一个窗口名。</li>
<li>window.blur( )  指定当前窗口失去焦点</li>
<li>window.focus( ) 指定当前窗口获得焦点</li>
<li>window.showModalDialog(uri, [dataFromParent]) 打开一个“模态窗口”（打开的子窗口只要不关闭，其父窗口即无法获得焦点；且父子窗口间可以传递数据）</li>
</ul>
<hr>
<h4 id="document-常用属性与方法有哪些-？"><a href="#document-常用属性与方法有哪些-？" class="headerlink" title="document 常用属性与方法有哪些 ？"></a><strong>document 常用属性与方法有哪些 ？</strong></h4><p>document 常见的属性</p>
<ul>
<li>body 提供对 元素的直接访问。对于定义了框架集的文档，该属性引用最外层的 。</li>
<li>cookie 设置或返回与当前文档有关的所有 cookie。</li>
<li>domain 返回当前文档的域名。</li>
<li>lastModified 返回文档被最后修改的日期和时间。</li>
<li>referrer 返回载入当前文档的文档的 URL。</li>
<li>title 返回当前文档的标题。</li>
<li>URL 返回当前文档的 URL。</li>
</ul>
<p>document常见的方法</p>
<ul>
<li>write()：动态向页面写入内容</li>
<li>createElement(Tag)：创建一个 HTML 标签对象</li>
<li>getElementById(ID)：获得指定 id 的对象</li>
<li>getElementsByName(Name)：获得之前 Name 的对象</li>
<li>body.appendChild(oTag)：向 HTML 中插入元素对象</li>
</ul>
<hr>
<h4 id="简述一下-src-与-href-的区别"><a href="#简述一下-src-与-href-的区别" class="headerlink" title="简述一下 src 与 href 的区别"></a><strong>简述一下 src 与 href 的区别</strong></h4><ul>
<li>href 是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。</li>
<li>src 是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；</li>
<li>在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片和 frame 等元素。 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将 js 脚本放在底部而不是头部。</li>
</ul>
<hr>
<h4 id="写一个-div-css-布局，左边图片，右边文字，文字环绕图片，外面容器固定宽度，文字不固定。"><a href="#写一个-div-css-布局，左边图片，右边文字，文字环绕图片，外面容器固定宽度，文字不固定。" class="headerlink" title="写一个 div + css 布局，左边图片，右边文字，文字环绕图片，外面容器固定宽度，文字不固定。"></a><strong>写一个 div + css 布局，左边图片，右边文字，文字环绕图片，外面容器固定宽度，文字不固定。</strong></h4><p>直接就一个 img，它 float：left，加文字加 p 标签就好了。</p>
<hr>
<h4 id="html-中-title-属性和-alt-属性的区别-？"><a href="#html-中-title-属性和-alt-属性的区别-？" class="headerlink" title="html 中 title 属性和 alt 属性的区别 ？"></a><strong>html 中 title 属性和 alt 属性的区别 ？</strong></h4><ol>
<li>alt</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;#&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;alt 信息&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>当图片不输出信息的时候，会显示 alt 信息， 鼠标放上去没有信息。 当图片正常读取，不会出现 alt 信息。</p>
<ol>
<li>title</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;#&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;alt 信息&quot;</span> <span class="attr">title</span>=<span class="string">&quot;title 信息&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>当图片不输出信息的时候，会显示 alt 信息，鼠标放上去会出现 title 信息。 当图片正常输出的时候，不会出现 alt 信息，鼠标放上去会出现 title 信息。</p>
<hr>
<h4 id="讲述你对-reflow-和-repaint-的理解。"><a href="#讲述你对-reflow-和-repaint-的理解。" class="headerlink" title="讲述你对 reflow 和 repaint 的理解。"></a><strong>讲述你对 reflow 和 repaint 的理解。</strong></h4><p>repaint 就是重绘，reflow 就是回流。</p>
<p>严重性： 在性能优先的前提下，性能消耗 reflow 大于 repaint。</p>
<p>体现：repaint 是某个 DOM 元素进行重绘；reflow 是整个页面进行重排，也就是页面所有 DOM 元素渲染。</p>
<p>如何触发： style 变动造成 repaint 和 reflow。</p>
<ol>
<li>不涉及任何 DOM 元素的排版问题的变动为 repaint，例如元素的 color/text-align/text-decoration 等等属性的变动。</li>
<li>除上面所提到的 DOM 元素 style 的修改基本为 reflow。例如元素的任何涉及 长、宽、行高、边框、display 等 style 的修改。</li>
</ol>
<p>常见触发场景</p>
<p>触发 repaint：</p>
<ul>
<li>color 的修改，如 color=#ddd；</li>
<li>text-align 的修改，如 text-align=center；</li>
<li>a:hover 也会造成重绘。</li>
<li>:hover 引起的颜色等不导致页面回流的 style 变动。</li>
</ul>
<p>触发 reflow：</p>
<ul>
<li>width/height/border/margin/padding 的修改，如 width=778px；</li>
<li>动画，:hover 等伪类引起的元素表现改动，display=none 等造成页面回流；</li>
<li>appendChild 等 DOM 元素操作；</li>
<li>font 类 style 的修改；</li>
<li>background 的修改，注意着字面上可能以为是重绘，但是浏览器确实回流了，经过浏览器厂家的优化，部分 background 的修改只触发 repaint，当然 IE 不用考虑；</li>
<li>scroll 页面，这个不可避免；</li>
<li>resize 页面，桌面版本的进行浏览器大小的缩放，移动端的话，还没玩过能拖动程序，resize 程序窗口大小的多窗口操作系统。</li>
<li>读取元素的属性（这个无法理解，但是技术达人是这么说的，那就把它当做定理吧）：读取元素的某些属性（offsetLeft、offsetTop、offsetHeight、offsetWidth、scrollTop/Left/Width/Height、clientTop/Left/Width/Height、getComputedStyle()、currentStyle(in IE))；</li>
</ul>
<p>如何避免： </p>
<ul>
<li>尽可能在 DOM 末梢通过改变 class 来修改元素的 style 属性：尽可能的减少受影响的 DOM 元素。</li>
<li>避免设置多项内联样式：使用常用的 class 的方式进行设置样式，以避免设置样式时访问 DOM 的低效率。</li>
<li>设置动画元素 position 属性为 fixed 或者 absolute：由于当前元素从 DOM 流中独立出来，因此受影响的只有当前元素，元素 repaint。</li>
<li>牺牲平滑度满足性能：动画精度太强，会造成更多次的 repaint/reflow，牺牲精度，能满足性能的损耗，获取性能和平滑度的平衡。</li>
<li>避免使用 table 进行布局：table 的每个元素的大小以及内容的改动，都会导致整个 table 进行重新计算，造成大幅度的 repaint 或者 reflow。改用 div 则可以进行针对性的 repaint 和避免不必要的 reflow。</li>
<li>避免在 CSS 中使用运算式：学习 CSS 的时候就知道，这个应该避免，不应该加深到这一层再去了解，因为这个的后果确实非常严重，一旦存在动画性的 repaint/reflow，那么每一帧动画都会进行计算，性能消耗不容小觑。</li>
</ul>
<p>参考文章：<a href="https://segmentfault.com/a/1190000017329980">你真的了解回流和重绘吗</a></p>
<hr>
<h4 id="Doctype-作用-？标准模式与兼容模式各有什么区别"><a href="#Doctype-作用-？标准模式与兼容模式各有什么区别" class="headerlink" title="Doctype 作用 ？标准模式与兼容模式各有什么区别 ?"></a><strong>Doctype 作用 ？标准模式与兼容模式各有什么区别 ?</strong></h4><ul>
<li>声明位于位于 HTML 文档中的第一行，处于 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE 不存在或格式不正确会导致文档以兼容模式呈现。</li>
<li>标准模式的排版和 JS 运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。</li>
</ul>
<hr>
<h4 id="HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt-？"><a href="#HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt-？" class="headerlink" title="HTML5 为什么只需要写 &lt; !DOCTYPE HTML&gt; ？"></a><strong>HTML5 为什么只需要写 &lt; !DOCTYPE HTML&gt; ？</strong></h4><p>HTML5 不基于 SGML(标准通用标记语言（以下简称“通用标言”)，因此不需要对 DTD 进行引用，但是需要 doctype 来规范浏览器的行为（让浏览器按照它们应该的方式来运行）； 而 HTML4.01 基于 SGML，所以需要对 DTD 进行引用，才能告知浏览器文档所使用的文档类型。</p>
<hr>
<h4 id="行内元素有哪些-？块级元素有哪些-？-空-void-元素有那些-？"><a href="#行内元素有哪些-？块级元素有哪些-？-空-void-元素有那些-？" class="headerlink" title="行内元素有哪些 ？块级元素有哪些 ？ 空(void)元素有那些 ？"></a><strong>行内元素有哪些 ？块级元素有哪些 ？ 空(void)元素有那些 ？</strong></h4><p>CSS 规范规定，每个元素都有 display 属性，确定该元素的类型，每个元素都有默认的 display 值。 如 div 的 display 默认值为 “block”，则为“块级”元素； span 默认 display 属性值为 “inline”，是“行内”元素。</p>
<ul>
<li>行内元素有：a b span img input select strong（强调的语气）</li>
<li>块级元素有：div ul ol li dl dt dd h1 h2 h3 h4 p</li>
<li>常见的空元素： img input link meta br hr ，鲜为人知的是：area base col command embed keygen param source track wbr</li>
</ul>
<hr>
<h4 id="HTML5-有哪些新特性、移除了那些元素-？如何处理-HTML5-新标签的浏览器兼容问题-？如何区分-HTML-和-HTML5-？"><a href="#HTML5-有哪些新特性、移除了那些元素-？如何处理-HTML5-新标签的浏览器兼容问题-？如何区分-HTML-和-HTML5-？" class="headerlink" title="HTML5 有哪些新特性、移除了那些元素 ？如何处理 HTML5 新标签的浏览器兼容问题 ？如何区分 HTML 和 HTML5 ？"></a><strong>HTML5 有哪些新特性、移除了那些元素 ？如何处理 HTML5 新标签的浏览器兼容问题 ？如何区分 HTML 和 HTML5 ？</strong></h4><p>HTML5 现在已经不是 SGML（标准通用标记语言）的子集，主要是关于图像，位置，存储，多任务等功能的增加。</p>
<p>新特性</p>
<ul>
<li>绘画 canvas;</li>
<li>用于媒介回放的 video 和 audio 元素;</li>
<li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;</li>
<li>sessionStorage 的数据在浏览器关闭后自动删除;</li>
<li>语意化更好的内容元素，比如 article、footer、header、nav、section;</li>
<li>表单控件：calendar、date、time、email、url、search;</li>
<li>新的技术：webworker, websocket, Geolocation;</li>
</ul>
<p>移除的元素</p>
<ul>
<li>纯表现的元素：basefont，big，center，font, s，strike，tt，u;</li>
<li>对可用性产生负面影响的元素：frame，frameset，noframes；</li>
</ul>
<p>支持 HTML5 新标签</p>
<ul>
<li>IE8/IE7/IE6 支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式。</li>
<li>当然也可以直接使用成熟的框架、比如 html5shim;</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">&lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="简述一下你对-HTML-语义化的理解-？"><a href="#简述一下你对-HTML-语义化的理解-？" class="headerlink" title="简述一下你对 HTML 语义化的理解 ？"></a><strong>简述一下你对 HTML 语义化的理解 ？</strong></h4><ul>
<li>1、用正确的标签做正确的事情。</li>
<li>2、html 语义化让页面的内容结构化，结构更清晰，</li>
<li>3、便于对浏览器、搜索引擎解析;</li>
<li>4、即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;</li>
<li>5、搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO;</li>
<li>6、使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</li>
</ul>
<hr>
<h4 id="HTML5-的离线储存怎么使用，工作原理能不能解释一下-？"><a href="#HTML5-的离线储存怎么使用，工作原理能不能解释一下-？" class="headerlink" title="HTML5 的离线储存怎么使用，工作原理能不能解释一下 ？"></a><strong>HTML5 的离线储存怎么使用，工作原理能不能解释一下 ？</strong></h4><p>在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。</p>
<p>原理</p>
<p>HTML5 的离线存储是基于一个新建的 .appcache 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</p>
<p>如何使用</p>
<ul>
<li>1、页面头部像下面一样加入一个 manifest 的属性；</li>
<li>2、在 cache.manifest 文件的编写离线存储的资源；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">#v0.11</span><br><span class="line">CACHE:</span><br><span class="line">js/app.js</span><br><span class="line">css/style.css</span><br><span class="line">NETWORK:</span><br><span class="line">resourse/logo.png</span><br><span class="line">FALLBACK:</span><br><span class="line">//offline.html</span><br></pre></td></tr></table></figure>

<ul>
<li>3、在离线状态时，操作 window.applicationCache 进行需求实现。</li>
</ul>
<hr>
<h4 id="浏览器是怎么对-HTML5-的离线储存资源进行管理和加载的呢-？"><a href="#浏览器是怎么对-HTML5-的离线储存资源进行管理和加载的呢-？" class="headerlink" title="浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢 ？"></a><strong>浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢 ？</strong></h4><p>在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。</p>
<p>如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。</p>
<p>离线的情况下，浏览器就直接使用离线存储的资源。</p>
<hr>
<h4 id="请描述一下-cookies，sessionStorage-和-localStorage-的区别-？"><a href="#请描述一下-cookies，sessionStorage-和-localStorage-的区别-？" class="headerlink" title="请描述一下 cookies，sessionStorage 和 localStorage 的区别 ？"></a><strong>请描述一下 cookies，sessionStorage 和 localStorage 的区别 ？</strong></h4><ul>
<li>cookie 是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。</li>
<li>cookie 数据始终在同源的 http 请求中携带（即使不需要），也会在浏览器和服务器间来回传递。</li>
<li>sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。</li>
</ul>
<p>存储大小</p>
<ul>
<li>cookie 数据大小不能超过 4k。</li>
<li>sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。</li>
</ul>
<p>有期时间</p>
<ul>
<li>localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；</li>
<li>sessionStorage 数据在当前浏览器窗口关闭后自动删除。</li>
<li>cookie  设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。</li>
</ul>
<hr>
<h4 id="iframe-内嵌框架有那些缺点-？"><a href="#iframe-内嵌框架有那些缺点-？" class="headerlink" title="iframe 内嵌框架有那些缺点 ？"></a><strong>iframe 内嵌框架有那些缺点 ？</strong></h4><p>内联框架 iframe一般用来包含别的页面，例如 我们可以在我们自己的网站页面加载别人网站的内容，为了更好的效果，可能需要使 iframe 透明效果；</p>
<ul>
<li>iframe 会阻塞主页面的 onload 事件；</li>
<li>搜索引擎的检索程序无法解读这种页面，不利于 SEO 搜索引擎优化（Search Engine Optimization）</li>
<li>iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</li>
</ul>
<p>如果需要使用 iframe，最好是通过 javascript 动态给 iframe 添加 src 属性值，这样可以绕开以上两个问题。</p>
<hr>
<h4 id="Label-的作用是什么？是怎么用的-？"><a href="#Label-的作用是什么？是怎么用的-？" class="headerlink" title="Label 的作用是什么？是怎么用的 ？"></a><strong>Label 的作用是什么？是怎么用的 ？</strong></h4><p>label 标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;Name&quot;</span>&gt;</span>Number:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">“text“</span> <span class="attr">name</span>=<span class="string">&quot;Name&quot;</span>  <span class="attr">id</span>=<span class="string">&quot;Name&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>Date:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;B&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="HTML5-的-form-如何关闭自动完成功能-？"><a href="#HTML5-的-form-如何关闭自动完成功能-？" class="headerlink" title="HTML5 的 form 如何关闭自动完成功能 ？"></a><strong>HTML5 的 form 如何关闭自动完成功能 ？</strong></h4><p>给不想要提示的 form 或某个 input 设置为 autocomplete=off。</p>
<hr>
<h4 id="如何实现浏览器内多个标签页之间的通信-阿里"><a href="#如何实现浏览器内多个标签页之间的通信-阿里" class="headerlink" title="如何实现浏览器内多个标签页之间的通信 ? (阿里)"></a><strong>如何实现浏览器内多个标签页之间的通信 ? (阿里)</strong></h4><ul>
<li>WebSocket、SharedWorker；</li>
<li>也可以调用 localstorge、cookies 等本地存储方式；</li>
<li>localstorge 在另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信； 注意 quirks：Safari 在无痕模式下设置 localstorge 值时会抛出 QuotaExceededError 的异常；</li>
</ul>
<hr>
<h4 id="webSocket-如何兼容低浏览器-？-阿里"><a href="#webSocket-如何兼容低浏览器-？-阿里" class="headerlink" title="webSocket 如何兼容低浏览器 ？(阿里)"></a><strong>webSocket 如何兼容低浏览器 ？(阿里)</strong></h4><ul>
<li>Adobe Flash Socket 、</li>
<li>ActiveX HTMLFile (IE) 、</li>
<li>基于 multipart 编码发送 XHR 、</li>
<li>基于长轮询的 XHR。</li>
</ul>
<hr>
<h4 id="页面可见性（Page-Visibility-API）-可以有哪些用途-？"><a href="#页面可见性（Page-Visibility-API）-可以有哪些用途-？" class="headerlink" title="页面可见性（Page Visibility API） 可以有哪些用途 ？"></a><strong>页面可见性（Page Visibility API） 可以有哪些用途 ？</strong></h4><ul>
<li>通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;</li>
<li>在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放；</li>
</ul>
<hr>
<h4 id="网页验证码是干嘛的，是为了解决什么安全问题。"><a href="#网页验证码是干嘛的，是为了解决什么安全问题。" class="headerlink" title="网页验证码是干嘛的，是为了解决什么安全问题。"></a><strong>网页验证码是干嘛的，是为了解决什么安全问题。</strong></h4><ul>
<li>区分用户是计算机还是人的公共全自动程序；</li>
<li>可以防止恶意破解密码、刷票、论坛灌水；</li>
<li>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。</li>
</ul>
<hr>
<h4 id="title-与-h1-的区别、b-与-strong-的区别、i-与-em-的区别-？"><a href="#title-与-h1-的区别、b-与-strong-的区别、i-与-em-的区别-？" class="headerlink" title="title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别 ？"></a><strong>title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别 ？</strong></h4><ul>
<li>title 属性没有明确意义只表示是个标题，H1 则表示层次明确的标题，对页面信息的抓取也有很大的影响；</li>
<li>strong 是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：<code>strong 会重读，而 b 是展示强调内容</code>。</li>
<li>i 内容展示为斜体，em 表示强调的文本；</li>
<li>Physical Style Elements – 自然样式标签：b, i, u, s, pre</li>
<li>Semantic Style Elements – 语义样式标签：strong, em, ins, del, code</li>
<li>应该准确使用语义样式标签, 但不能滥用, 如果不能确定时，首选使用自然样式标签。</li>
</ul>
<hr>
<h4 id="谈谈以前端的角度出发，做好-SEO-，需要考虑什么-？"><a href="#谈谈以前端的角度出发，做好-SEO-，需要考虑什么-？" class="headerlink" title="谈谈以前端的角度出发，做好 SEO ，需要考虑什么 ？"></a><strong>谈谈以前端的角度出发，做好 SEO ，需要考虑什么 ？</strong></h4><ul>
<li>了解搜索引擎如何抓取网页和如何索引网页。 你需要知道一些搜索引擎的基本工作原理，各个搜索引擎之间的区别，搜索机器人（SE robot 或叫 web cra何进行工作，搜索引擎如何对搜索结果进行排序等等。</li>
<li>Meta 标签优化 主要包括主题（Title)，网站描述(Description)，和关键词（Keywords）。还有一些其它的隐藏文字比如 Au 者），Category（目录），Language（编码语种）等。</li>
<li>如何选取关键词并在网页中放置关键词。 搜索就得用关键词。关键词分析和选择是 SEO 最重要的工作之一。首先要给网站确定主关键词（一般在 5 个上后针对这些关键词进行优化，包括关键词密度（Density），相关度（Relavancy），突出性（Prominency）等等。</li>
<li>了解主要的搜索引擎。 虽然搜索引擎有很多，但是对网站流量起决定作用的就那么几个。比如英文的主要有 Google，Yahoo，Bing 等有百度，搜狗，有道等。 不同的搜索引擎对页面的抓取和索引、排序的规则都不一样。 还要了解各搜索门户和搜索的关系，比如 AOL 网页搜索用的是 Google 的搜索技术，MSN 用的是 Bing 的技术。</li>
<li>主要的互联网目录。 Open Directory 自身不是搜索引擎，而是一个大型的网站目录，他和搜索引擎的主要区别是网站内容的收集方目录是人工编辑的，主要收录网站主页；搜索引擎是自动收集的，除了主页外还抓取大量的内容页面。</li>
<li>按点击付费的搜索引擎。 搜索引擎也需要生存，随着互联网商务的越来越成熟，收费的搜索引擎也开始大行其道。最典型的有 Overture 当然也包括 Google 的广告项目 Google Adwords。越来越多的人通过搜索引擎的点击广告来定位商业网站，这里面化和排名的学问，你得学会用最少的广告投入获得最多的点击。</li>
<li>搜索引擎登录。 网站做完了以后，别躺在那里等着客人从天而降。要让别人找到你，最简单的办法就是将网站提交（submit）擎。如果你的是商业网站，主要的搜索引擎和目录都会要求你付费来获得收录（比如 Yahoo 要 299 美元），但是好消少到目前为止）最大的搜索引擎 Google 目前还是免费，而且它主宰着 60％ 以上的搜索市场。</li>
<li>链接交换和链接广泛度（Link Popularity）。 网页内容都是以超文本（Hypertext）的方式来互相链接的，网站之间也是如此。除了搜索引擎以外，人们也不同网站之间的链接来 Surfing（“冲浪”）。其它网站到你的网站的链接越多，你也就会获得更多的访问量。更重你的网站的外部链接数越多，会被搜索引擎认为它的重要性越大，从而给你更高的排名。</li>
<li>标签的合理使用。</li>
</ul>
<hr>
<h4 id="前端页面有哪三层构成，分别是什么？作用是什么？"><a href="#前端页面有哪三层构成，分别是什么？作用是什么？" class="headerlink" title="前端页面有哪三层构成，分别是什么？作用是什么？"></a><strong>前端页面有哪三层构成，分别是什么？作用是什么？</strong></h4><p>网页分成三个层次，即：结构层、表示层、行为层。</p>
<ul>
<li>网页的结构层（structurallayer）由 HTML 或 XHTML 之类的标记语言负责创建。 标签，也就是那些出现在尖括号里的单词，对网页内容的语义含义做出这些标签不包含任何关于如何显示有关内容的信息。例如，P 标签表达了这样一种语义：“这是一个文本段。”</li>
<li>网页的表示层（presentationlayer）由 CSS 负责创建。CSS 对“如何显示有关内容”的问题做出了回答。</li>
<li>网页的行为层（behaviorlayer）负责回答 “内容应该如何对事件做出反应” 这一问题。 这是 Javascript 语言和 DOM 主宰的领域。</li>
</ul>
<hr>
<h4 id="有这么一段-HTML，请挑毛病"><a href="#有这么一段-HTML，请挑毛病" class="headerlink" title="有这么一段 HTML，请挑毛病"></a><strong>有这么一段 HTML，请挑毛病</strong></h4><p>哥写的不是HTML，是寂寞。&lt; br&gt;&lt; br&gt; 我说：&lt; br&gt;不要迷恋哥，哥只是一个传说</p>
<p>答案：缺少 p 标记的结束标记。</p>
<hr>
<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><h4 id="盒子模型的理解"><a href="#盒子模型的理解" class="headerlink" title="盒子模型的理解 ?"></a><strong>盒子模型的理解 ?</strong></h4><ul>
<li>标准模式和混杂模式（IE）。</li>
<li>在标准模式下浏览器按照规范呈现页面；</li>
<li>在混杂模式下，页面以一种比较宽松的向后兼容的方式显示。</li>
<li>混杂模式通常模拟老式浏览器的行为以防止老站点无法工作。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/i-1.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/i-2.png"></p>
<p>CSS 盒子模型具有内容 (content)、填充 (padding)、边框 (border)、边界 (margin)这些属性。</p>
<p>我们所说的 width，height 指的是内容 (content) 的宽高。</p>
<p>一个盒子模型的中：</p>
<ul>
<li>宽度 = width+ pdding(宽) + border(宽)。</li>
<li>高度 = height + padding(高) + border(高)。</li>
</ul>
<hr>
<p><strong>如何在页面上实现一个圆形的可点击区域 ？</strong></p>
<ul>
<li>1、map+area 或者 svg</li>
<li>2、border-radius</li>
<li>3、纯 js 实现，需要求一个点在不在圆上简单算法、获取鼠标坐标等等</li>
</ul>
<hr>
<h4 id="实现不使用-border-画出-1px-高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。"><a href="#实现不使用-border-画出-1px-高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。" class="headerlink" title="实现不使用 border 画出 1px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。"></a><strong>实现不使用 border 画出 1px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div style=&quot;height:1px;overflow:hidden;background:red&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="CSS-中哪些属性可以同父元素继承"><a href="#CSS-中哪些属性可以同父元素继承" class="headerlink" title="CSS 中哪些属性可以同父元素继承 ?"></a><strong>CSS 中哪些属性可以同父元素继承 ?</strong></h4><p>继承：(X)HTML 元素可以从其父元素那里继承部分 CSS 属性，即使当前元素并没有定义该属性，比如： color，font-size。</p>
<hr>
<h4 id="box-sizing-常用的属性有哪些-？分别有什么作用-？"><a href="#box-sizing-常用的属性有哪些-？分别有什么作用-？" class="headerlink" title="box-sizing 常用的属性有哪些 ？分别有什么作用 ？"></a><strong>box-sizing 常用的属性有哪些 ？分别有什么作用 ？</strong></h4><p>常用的属性：box-sizing: content-box border-box inherit;</p>
<p>作用</p>
<p>content-box(默认)：宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框(元素默认效果)。 border-box：元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。</p>
<hr>
<h4 id="页面导入样式时，使用-link-和-import-有什么区别-？"><a href="#页面导入样式时，使用-link-和-import-有什么区别-？" class="headerlink" title="页面导入样式时，使用 link 和 @import 有什么区别 ？"></a><strong>页面导入样式时，使用 link 和 @import 有什么区别 ？</strong></h4><ul>
<li>link 属于 XHTML 标签，除了加载 CSS 外，还能用于定义 RSS(是一种描述和同步网站内容的格式，是使用最广泛的 XML 应用), 定义 rel 连接属性等作用；</li>
<li>而 @import 是 CSS 提供的，只能用于加载 CSS;</li>
<li>页面被加载的时，link 会同时被加载，而 @import 引用的 CSS 会等到页面被加载完再加载;</li>
<li>import 是 CSS2.1 提出的，只在 IE5 以上才能被识别，而 link 是 XHTML 标签，无兼容问题。</li>
<li>总之，link 要优于 @import。</li>
</ul>
<hr>
<h4 id="常见兼容性问题？"><a href="#常见兼容性问题？" class="headerlink" title="常见兼容性问题？"></a><strong>常见兼容性问题？</strong></h4><ul>
<li>浏览器默认的 margin 和 padding 不同。解决方案是加一个全局的 *{margin: 0; padding: 0;} 来统一。</li>
<li>IE下 event 对象有 event.x，event.y 属性，而 Firefox 下没有。Firefox 下有 event.pageX，event.PageY 属性，而 IE 下没有。 解决办法：var mx = event.x?event.x:event.pageX;</li>
<li>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决.</li>
<li>超链接访问过后 hover 样式就不出现了，被点击访问过的超链接样式不在具有 hover 和 active 了，解决方法是改变 CSS 属性的排列顺序: L-V-H-A : a:link {} a:visited {} a:hover {} a:active {}</li>
</ul>
<hr>
<h4 id="清除浮动，什么时候需要清除浮动，清除浮动都有哪些方法-？"><a href="#清除浮动，什么时候需要清除浮动，清除浮动都有哪些方法-？" class="headerlink" title="清除浮动，什么时候需要清除浮动，清除浮动都有哪些方法 ？"></a><strong>清除浮动，什么时候需要清除浮动，清除浮动都有哪些方法 ？</strong></h4><p>一个块级元素如果没有设置 height，那么其高度就是由里面的子元素撑开，如果子元素使用浮动，脱离了标准的文档流，那么父元素的高度会将其忽略，如果不清除浮动，父元素会出现高度不够，那样如果设置 border 或者 background 都得不到正确的解析。</p>
<p>正是因为浮动的这种特性，导致本属于普通流中的元素浮动之后，包含框内部由于不存在其他普通流元素了，也就表现出高度为 0（<code>高度塌陷</code>）。在实际布局中，往往这并不是我们所希望的，所以需要闭合浮动元素，使其包含框表现出正常的高度。</p>
<p>清除浮动的方式</p>
<ul>
<li>父级 div 定义 height，原理：父级 div 手动定义 height，就解决了父级 div 无法自动获取到高度的问题。 </li>
<li>结尾处加空 div 标签 clear: both，原理：添加一个空 div，利用 css 提高的 clear: both 清除浮动，让父级 div 能自动获取到高度。</li>
<li>父级 div 定义 overflow: hidden，  原理：必须定义 width 或 zoom: 1，同时不能定义 height，使用 overflow: hidden 时，浏览器会自动检查浮动区域的高度。 </li>
<li>父级 div 也一起浮动 。</li>
<li>父级 div 定义 display: table 。</li>
<li>父级 div 定义 伪类 :after 和 zoom 。</li>
<li>结尾处加 br 标签 clear: both， 原理：父级 div 定义 zoom: 1 来解决 IE 浮动问题，结尾处加 br 标签 clear: both。</li>
</ul>
<p>总结：比较好的是倒数第 2 种方式，简洁方便。</p>
<hr>
<h4 id="如何保持浮层水平垂直居中-？"><a href="#如何保持浮层水平垂直居中-？" class="headerlink" title="如何保持浮层水平垂直居中 ？"></a><strong>如何保持浮层水平垂直居中 ？</strong></h4><p>一、水平居中 </p>
<p>（1）行内元素解决方案</p>
<p>只需要把行内元素包裹在一个属性 display 为 block 的父层元素中，并且把父层元素添加如下属性即可。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）块状元素解决方案  </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="comment">/* 这里可以设置顶端外边距 */</span></span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）多个块状元素解决方案将元素的 display 属性设置为 inline-block，并且把父元素的 text-align 属性设置为 center 即可:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）多个块状元素解决方案</p>
<p>使用 flexbox 布局，只需要把待处理的块状元素的父元素添加属性 display: flex 及 justify-content: center 即可。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二、垂直居中</p>
<p>（1）单行的行内元素解决方案</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#222</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以下代码中，将 a 元素的 height 和 line-height 设置的和父元素一样高度即可实现垂直居中 */</span></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>:<span class="number">200px</span>; </span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#FFF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）多行的行内元素解决方案组合</p>
<p>使用 display: table-cell 和 vertical-align: middle 属性来定义需要居中的元素的父容器元素生成效果，如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#222</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="comment">/* 以下属性垂直居中 */</span></span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）已知高度的块状元素解决方案</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">50px</span>;  <span class="comment">/* margin-top值为自身高度的一半 */</span></span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三、水平垂直居中</p>
<p>（1）已知高度和宽度的元素解决方案 1</p>
<p>这是一种不常见的居中方法，可自适应，比方案 2 更智能，如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">margin</span>:auto;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）已知高度和宽度的元素解决方案 2</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">75px</span>;  <span class="comment">/* 设置margin-left / margin-top 为自身高度的一半 */</span></span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">75px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）未知高度和宽度元素解决方案</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);  <span class="comment">/* 使用 css3 的 transform 来实现 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）使用 flex 布局实现</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="comment">/* 注意这里需要设置高度来查看垂直居中效果 */</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#AAA</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="position-、float-和-display-的取值和各自的意思和用法"><a href="#position-、float-和-display-的取值和各自的意思和用法" class="headerlink" title="position 、float 和 display 的取值和各自的意思和用法"></a><strong>position 、float 和 display 的取值和各自的意思和用法</strong></h4><p>position</p>
<ul>
<li>position 属性取值：static(默认)、relative、absolute、fixed、inherit、sticky。</li>
<li>postision：static；始终处于文档流给予的位置。看起来好像没有用，但它可以快速取消定位，让 top，right，bottom，left 的值失效。在切换的时候可以尝试这个方法。</li>
<li>除了 static 值，在其他三个值的设置下，z-index 才会起作用。确切地说 z-index 只在定位元素上有效。</li>
<li>position：relative 和 absolute 都可以用于定位，区别在于前者的 div 还属于正常的文档流，后者已经是脱离了正常文档流，不占据空间位置，不会将父类撑开。 定位原点 relative 是相对于它在正常流中的默认位置偏移，它原本占据的空间任然保留；absolute 相对于第一个 position 属性值不为 static 的父类。所以设置了 position：absolute，其父类的该属性值要注意，而且 overflow：hidden 也不能乱设置，因为不属于正常文档流，不会占据父类的高度，也就不会有滚动条。</li>
<li>fixed 旧版本 IE 不支持，却是很有用，定位原点相对于浏览器窗口，而且不能变。 常用于 header，footer 或者一些固定的悬浮 div，随滚动条滚动又稳定又流畅，比 JS 好多了。fixed 可以有很多创造性的布局和作用，兼容性是问题。</li>
<li>position：inherit。 规定从父类继承 position 属性的值，所以这个属性也是有继承性的，但需要注意的是 IE8 以及往前的版本都不支持 inherit 属性。</li>
<li>sticky ：设置了sticky 的元素，在屏幕范围（viewport）时该元素的位置并不受到定位影响（设置是 top、left 等属性无效），当该元素的位置将要移出偏移范围时，定位又会变成 fixed，根据设置的 left、top 等属性成固定位置的效果。</li>
</ul>
<p>float</p>
<ul>
<li>float：left (或 right)，向左（或右）浮动，直到它的边缘碰到包含框或另一个浮动框为止。 且脱离普通的文档流，会被正常文档流内的块框忽略。不占据空间，无法将父类元素撑开。</li>
<li>任何元素都可以浮动，浮动元素会生成一个块级框，不论它本身是何种元素。因此，没有必要为浮动元素设置 display：block。</li>
<li>如果浮动非替换元素，则要指定一个明确的 width，否则它们会尽可能的窄。 什么叫替换元素 ？根据元素本身的特点定义的， (X)HTML中的 img、input、textarea、select、object 都是替换元素，这些元素都没有实际的内容。 (X)HTML 的大多数元素是不可替换元素，他们将内容直接告诉浏览器，将其显示出来。</li>
</ul>
<p>display</p>
<ul>
<li>display 属性取值：none、inline、inline-block、block、table 相关属性值、inherit。</li>
<li>display 属性规定元素应该生成的框的类型。文档内任何元素都是框，块框或行内框。</li>
<li>display：none 和 visiability：hidden 都可以隐藏 div，区别有点像 absolute 和 relative，前者不占据文档的空间，后者还是占据文档的位置。</li>
<li>display：inline 和 block，又叫行内元素和块级元素。 表现出来的区别就是 block 独占一行，在浏览器中通常垂直布局，可以用 margin 来控制块级元素之间的间距（存在 margin 合并的问题，只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。）； 而 inline 以水平方式布局，垂直方向的 margin 和 padding 都是无效的，大小跟内容一样，且无法设置宽高。 inline 就像塑料袋，内容怎么样，就长得怎么样；block 就像盒子，有固定的宽和高。</li>
<li>inline-block 就介于两者之间。</li>
<li>table 相关的属性值可以用来垂直居中，效果一般。</li>
<li>flex</li>
</ul>
<p>定位机制</p>
<p>上面三个属性都属于 CSS 定位属性。CSS 三种基本的定位机制：普通流、浮动、绝对定位。</p>
<hr>
<h4 id="css3-动画效果属性有哪些"><a href="#css3-动画效果属性有哪些" class="headerlink" title="css3 动画效果属性有哪些 ?"></a><strong>css3 动画效果属性有哪些 ?</strong></h4><ul>
<li>animation-name：规定需要绑定到选择器的 keyframe 名称。。</li>
<li>animation-duration：规定完成动画所花费的时间，以秒或毫秒计。</li>
<li>animation-timing-function：规定动画的速度曲线。</li>
<li>animation-delay：规定在动画开始之前的延迟。</li>
<li>animation-iteration-count：规定动画应该播放的次数。</li>
<li>animation-direction：规定是否应该轮流反向播放动画。</li>
</ul>
<hr>
<h4 id="会不会用-ps-扣图，png、jpg、gif-这些图片格式解释一下，分别什么时候用。如何优化图像、图像格式的区别"><a href="#会不会用-ps-扣图，png、jpg、gif-这些图片格式解释一下，分别什么时候用。如何优化图像、图像格式的区别" class="headerlink" title="会不会用 ps 扣图，png、jpg、gif 这些图片格式解释一下，分别什么时候用。如何优化图像、图像格式的区别 ?"></a><strong>会不会用 ps 扣图，png、jpg、gif 这些图片格式解释一下，分别什么时候用。如何优化图像、图像格式的区别 ?</strong></h4><p>JPG 的特性</p>
<ul>
<li>支持摄影图像或写实图像的高级压缩，并且可利用压缩比例控制图像文件大小。</li>
<li>有损压缩会使图像数据质量下降，并且在编辑和重新保存 JPG 格式图像时，这种下降损失会累积。</li>
<li>JPG 不适用于所含颜色很少、具有大块颜色相近的区域或亮度差异十分明显的较简单的图片。</li>
</ul>
<p>PNG 的特性</p>
<ul>
<li>能在保证最不失真的情况下尽可能压缩图像文件的大小。</li>
<li>PNG 用来存储灰度图像时，灰度图像的深度可多到 16 位，存储彩色图像时，彩色图像的深度可多到 48 位，并且还可存储多到 16 位的 α 通道数据。</li>
<li>对于需要高保真的较复杂的图像，PNG 虽然能无损压缩，但图片文件较大，不适合应用在 Web 页面上。</li>
<li>另外还有一个原则就是用于页面结构的基本视觉元素，<strong>如容器的背景、按钮、导航的背景等应该尽量用 PNG 格式进行存储，这样才能更好的保证设计品质</strong>。而其他一些内容元素，<strong>如广告 Banner、商品图片 等对质量要求不是特别苛刻的，则可以用 JPG 去进行存储从而降低文件大小</strong>。</li>
</ul>
<p>GIF格式特点  </p>
<ul>
<li>透明性: Gif 是一种布尔透明类型，既它可以是全透明，也可以是全不透明，但是它并没有半透明（alpha 透明）。 </li>
<li>动画：Gif 这种格式支持动画。 </li>
<li>无损耗性：Gif 是一种无损耗的图像格式，这也意味着你可以对 gif 图片做任何操作也不会使得图像质量产生损耗。 </li>
<li>水平扫描：Gif 是使用了一种叫作 LZW 的算法进行压缩的，当压缩 gif 的过程中，像素是由上到下水平压缩的，这也意味着同等条件下，横向的 gif 图片比竖向的 gif 图片更加小。 例如 500<em>10 的图片比 10</em>500 的图片更加小。 间隔渐进显示：Gif 支持可选择性的间隔渐进显示。 </li>
</ul>
<p>由以上特点看出只有 256 种颜色的 gif 图片不适合作为照片，它适合做对颜色要求不高的图形。</p>
<hr>
<h4 id="我们知道可以以外链的方式引入-CSS-文件，请谈谈外链引入-CSS-有哪些方式，这些方式的性能有区别吗-？"><a href="#我们知道可以以外链的方式引入-CSS-文件，请谈谈外链引入-CSS-有哪些方式，这些方式的性能有区别吗-？" class="headerlink" title="我们知道可以以外链的方式引入 CSS 文件，请谈谈外链引入 CSS 有哪些方式，这些方式的性能有区别吗 ？"></a><strong>我们知道可以以外链的方式引入 CSS 文件，请谈谈外链引入 CSS 有哪些方式，这些方式的性能有区别吗 ？</strong></h4><p>CSS 的引入方式最常用的有三种</p>
<p>第一：外链式</p>
<p>这种方法可以说是现在占统治地位的引入方法。</p>
<p>如同 IE 与浏览器。这也是最能体现 CSS 特点的方法；</p>
<p>最能体现 DIV+CSS 中的内容离的思想，也最易改版维护，代码看起来也是最美观的一种。</p>
<p>第二：内部样式表</p>
<p>这种方法的使用情况要少的多，最长见得就是访问量大的门户网站。或者访问量较大的企业网站的首页。</p>
<p>与第一种方法比起来，优弊端也明显。</p>
<p>优点：速度快，所有的 CSS 控制都是针对本页面标签的，没有多余的 CSS 命令；再者不用外链 CSS 文件。直接在文档中读取样式。</p>
<p>缺点：就是改版麻烦些，单个页面显得臃肿，CSS 不能被其他 HTML 引用造成代码量相对较多，维护也麻烦些采用这种方法的公司大多有钱，对他们来说用户量是关键，他们不缺人进行复杂的维护工作。</p>
<p>第三：行内样式</p>
<p>认为 HTML 里不能出现 CSS 命令。其实有时候没有什么大不了。比如通用性差，效果特殊，使用 CSS 命令较少，并且不常改动的地方，使用这种方法反而是很好的选择。</p>
<p>第四、@import 引入方式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line"><span class="keyword">@import</span> url(my.css);</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="CSS-Sprite-是什么，谈谈这个技术的优缺点。"><a href="#CSS-Sprite-是什么，谈谈这个技术的优缺点。" class="headerlink" title="CSS Sprite 是什么，谈谈这个技术的优缺点。"></a><strong>CSS Sprite 是什么，谈谈这个技术的优缺点。</strong></h4><p>加速的关键，不是降低重量，而是减少个数。传统切图讲究精细，图片规格越小越好，重量越小越好，其实规格大小无计算机统一都按 byte 计算。客户端每显示一张图片都会向服务器发送请求。所以，图片越多请求次数越多，造成延迟的可越大。</p>
<ul>
<li>利用 CSS Sprites 能很好地减少了网页的 http 请求，从而大大的提高了页面的性能，这也是CSS Sprites 的优点，也是其被广泛传播和应用的主要原因；</li>
<li>CSS Sprites 能减少图片的字节，曾经比较过多次 3 张图片合并成 1 张图片的字节总是小于这 3 张图片的和。</li>
<li>解决了网页设计师在图片命名上的困扰，只需对一张集合的图片上命名就可以了，不需要对每一个小元素名，从而提高了网页的制作效率。</li>
<li>更换风格方便，只需要在一张或少张图片上修改图片的颜色或样式，整个网页的风格就可以改变。维护起方便。</li>
</ul>
<p>诚然 CSS Sprites 是如此的强大，但是也存在一些不可忽视的缺点，如下：</p>
<ul>
<li>在图片合并的时候，你要把多张图片有序的合理的合并成一张图片，还要留好足够的空间，防止板块内不不必要的背景；这些还好，最痛苦的是在宽屏，高分辨率的屏幕下的自适应页面，你的图片如果不够宽，很容背景断裂；</li>
<li>CSS Sprites 在开发的时候比较麻烦，你要通过 photoshop 或其他工具测量计算每一个背景单元的精确位是针线活，没什么难度，但是很繁琐；</li>
<li>CSS Sprites 在维护的时候比较麻烦，如果页面背景有少许改动，一般就要改这张合并的图片，无需改的好不要动，这样避免改动更多的 css，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字加了，还要改动 css。</li>
</ul>
<p>CSS Sprites 非常值得学习和应用，特别是页面有一堆 ico（图标）。总之很多时候大家要权衡一下再决定是不是应用 CSS Sprites。</p>
<hr>
<h4 id="以-CSS3-标准定义一个-webkit-内核浏览器识别的圆角（尺寸随意）"><a href="#以-CSS3-标准定义一个-webkit-内核浏览器识别的圆角（尺寸随意）" class="headerlink" title="以 CSS3 标准定义一个 webkit 内核浏览器识别的圆角（尺寸随意）"></a><strong>以 CSS3 标准定义一个 webkit 内核浏览器识别的圆角（尺寸随意）</strong></h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">-moz-<span class="attribute">border-radius</span>: <span class="number">10px</span>; </span><br><span class="line">-webkit-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line"> <span class="attribute">border-radius</span>: <span class="number">10px</span>;。</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>优先级算法如何计算？内联和 important 哪个优先级高 ？</strong></p>
<ul>
<li>优先级就近原则，样式定义最近者为准</li>
<li>载入样式以最后载入的定位为准</li>
<li>优先级为 !important &gt; [ id &gt; class &gt; tag ]</li>
<li>!mportant 比内联优先级高</li>
</ul>
<hr>
<h4 id="css-的基本语句构成是-？"><a href="#css-的基本语句构成是-？" class="headerlink" title="css 的基本语句构成是 ？"></a><strong>css 的基本语句构成是 ？</strong></h4><p>回答：选择器、属性和属性值。</p>
<hr>
<h4 id="如果让你来制作一个访问量很高的大型网站，你会如何来管理所有-CSS-文件、JS-与图片？"><a href="#如果让你来制作一个访问量很高的大型网站，你会如何来管理所有-CSS-文件、JS-与图片？" class="headerlink" title="如果让你来制作一个访问量很高的大型网站，你会如何来管理所有 CSS 文件、JS 与图片？"></a><strong>如果让你来制作一个访问量很高的大型网站，你会如何来管理所有 CSS 文件、JS 与图片？</strong></h4><p>回答：涉及到人手、分工、同步；</p>
<ul>
<li>先期团队必须确定好全局样式（globe.css），编码模式 (utf-8) 等</li>
<li>编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；</li>
<li>标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；</li>
<li>页面进行标注（例如页面模块开始和结束）；</li>
<li>CSS 跟 HTML 分文件夹并行存放，命名都得统一（例如 style.css）</li>
<li>JS 分文件夹存放，命名以该 JS 功能为准</li>
<li>图片采用整合的 png8 格式文件使用，尽量整合在一起使用，方便将来的管理。</li>
</ul>
<hr>
<h4 id="CSS-选择符有哪些-？哪些属性可以继承-？优先级算法如何计算-？新增伪类有那些-？"><a href="#CSS-选择符有哪些-？哪些属性可以继承-？优先级算法如何计算-？新增伪类有那些-？" class="headerlink" title="CSS 选择符有哪些 ？哪些属性可以继承 ？优先级算法如何计算 ？新增伪类有那些 ？"></a><strong>CSS 选择符有哪些 ？哪些属性可以继承 ？优先级算法如何计算 ？新增伪类有那些 ？</strong></h4><p>CSS 选择符</p>
<ol>
<li>id选择器（ # myid）</li>
<li>类选择器（.myclassname）</li>
<li>标签选择器（div, h1, p）</li>
<li>相邻选择器（h1 + p）</li>
<li>子选择器（ul &gt; li）</li>
<li>后代选择器（li a）</li>
<li>通配符选择器（ * ）</li>
<li>属性选择器（a[rel = “external”]）</li>
<li>伪类选择器（a: hover, li: nth - child）</li>
</ol>
<p>可继承的样式</p>
<p>font-size，font-family，color，ul，li，dl，dd，dt；</p>
<p>不可继承的样式</p>
<p>border padding margin width height 事实上，宽度也不是继承的，而是如果你不指定宽度，那么它就是 100%。由于你子 DIV 并没有指定宽度，那它就是 100%，也就是与父 DIV 同宽，但这与继承无关，高度自然也没有继承一说。</p>
<p>优先级算法</p>
<p>优先级就近原则，同权重情况下样式定义最近者为准; 载入样式以最后载入的定位为准; 优先级为: !important &gt; id &gt; class &gt; tag , important 比 内联优先级高</p>
<hr>
<h4 id="CSS3-新增伪类举例"><a href="#CSS3-新增伪类举例" class="headerlink" title="CSS3 新增伪类举例"></a><strong>CSS3 新增伪类举例</strong></h4><ul>
<li>:root 选择文档的根元素，等同于 html 元素</li>
<li>:empty 选择没有子元素的元素</li>
<li>:target 选取当前活动的目标元素</li>
<li>:not(selector) 选择除 selector 元素以外的元素</li>
<li>:enabled 选择可用的表单元素</li>
<li>:disabled 选择禁用的表单元素</li>
<li>:checked 选择被选中的表单元素</li>
<li>:after 选择器在被选元素的内容后面插入内容</li>
<li>:before 选择器在被选元素的内容前面插入内容</li>
<li>:nth-child(n) 匹配父元素下指定子元素，在所有子元素中排序第 n</li>
<li>:nth-last-child(n) 匹配父元素下指定子元素，在所有子元素中排序第 n，从后向前数</li>
<li>:nth-child(odd) 奇数</li>
<li>:nth-child(even) 偶数</li>
<li>:nth-child(3n+1)</li>
<li>:first-child</li>
<li>:last-child</li>
<li>:only-child</li>
<li>:nth-of-type(n) 匹配父元素下指定子元素，在同类子元素中排序第 n</li>
<li>:nth-last-of-type(n) 匹配父元素下指定子元素，在同类子元素中排序第 n，从后向前数</li>
<li>:nth-of-type(odd)</li>
<li>:nth-of-type(even)</li>
<li>:nth-of-type(3n+1)</li>
<li>:first-of-type</li>
<li>:last-of-type</li>
<li>:only-of-type</li>
<li>::selection 选择被用户选取的元素部分</li>
<li>:first-line 选择元素中的第一行</li>
<li>:first-letter 选择元素中的第一个字符</li>
</ul>
<hr>
<h4 id="CSS3-有哪些新特性"><a href="#CSS3-有哪些新特性" class="headerlink" title="CSS3 有哪些新特性 ?"></a><strong>CSS3 有哪些新特性 ?</strong></h4><ul>
<li>CSS3 实现圆角（border-radius:8px）</li>
<li>阴影（box-shadow:10px）</li>
<li>对文字加特效（text-shadow）</li>
<li>线性渐变（gradient）</li>
<li>旋转、缩放、定位、倾斜</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">9deg</span>) <span class="built_in">scale</span>(<span class="number">0.85</span>,<span class="number">0.90</span>) <span class="built_in">translate</span>(<span class="number">0px</span>,-<span class="number">30px</span>) <span class="built_in">skew</span>(-<span class="number">9deg</span>,<span class="number">0deg</span>); </span><br></pre></td></tr></table></figure>

<ul>
<li>增加了更多的 CSS 选择器</li>
<li>多背景 rgba</li>
</ul>
<hr>
<h4 id="一个满屏-品字布局-如何设计-？"><a href="#一个满屏-品字布局-如何设计-？" class="headerlink" title="一个满屏 品字布局 如何设计 ？"></a><strong>一个满屏 品字布局 如何设计 ？</strong></h4><p>第一种方式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>满屏品字布局<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        *&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">html</span>,<span class="selector-tag">body</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100%</span>;<span class="comment">/*此设置非常关键，因为默认的 body，HTML 高度为 0，所以后面设置的 div 的高度无法用百分比显示*/</span></span></span><br><span class="line"><span class="css">        &#125;       </span></span><br><span class="line"><span class="css">        <span class="selector-class">.header</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>:<span class="number">50%</span>; <span class="comment">/*此步结合 html,body 高度为 100%，解决元素相对窗口的定位问题*/</span></span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">50%</span>;     </span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: <span class="number">#ccc</span>;           </span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>:<span class="number">0</span> auto;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.main</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: <span class="number">#ddd</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.main</span> <span class="selector-class">.left</span>,<span class="selector-class">.main</span> <span class="selector-class">.right</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;<span class="comment">/*采用 float 方式，对元素进行左右定位*/</span></span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>:<span class="number">50%</span>;<span class="comment">/*此步解决元素相对窗口的定位问题*/</span></span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>:<span class="number">100%</span>;<span class="comment">/*此步解决元素相对窗口的定位问题*/</span></span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: yellow;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.main</span> <span class="selector-class">.right</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: green;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果如下： </p>
<p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/i-3.png"></p>
<hr>
<h4 id="为什么要初始化-CSS-样式"><a href="#为什么要初始化-CSS-样式" class="headerlink" title="为什么要初始化 CSS 样式 ?"></a><strong>为什么要初始化 CSS 样式 ?</strong></h4><p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对 CSS 初始化往往会出现浏览器之间的页面显示差异。 初始化样式会对 SEO 有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。</p>
<p>初始化 CSS 样式例子</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>; </span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="请解释一下CSS3-的-Flexbox（弹性盒布局模型），以及适用场景-？"><a href="#请解释一下CSS3-的-Flexbox（弹性盒布局模型），以及适用场景-？" class="headerlink" title="请解释一下CSS3 的 Flexbox（弹性盒布局模型），以及适用场景 ？"></a><strong>请解释一下CSS3 的 Flexbox（弹性盒布局模型），以及适用场景 ？</strong></h4><p><a href="https://yx-dimples.vercel.app/2021/08/04/CSS-Flex/">https://yx-dimples.vercel.app/2021/08/04/CSS-Flex/</a></p>
<p>任何一个容器都可以指定为 Flex 布局，行内元素也可以使用 Flex 布局。</p>
<p>注意：设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。</p>
<hr>
<h4 id="flex-布局最常用的是什么场景-？"><a href="#flex-布局最常用的是什么场景-？" class="headerlink" title="flex 布局最常用的是什么场景 ？"></a><strong>flex 布局最常用的是什么场景 ？</strong></h4><p>一般实现垂直居中是一件很麻烦的事，但 flex 布局轻松解决。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.demo</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;            </span><br><span class="line">  <span class="attribute">justify-content</span>: center;                    </span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="用纯-CSS-创建一个三角形的原理是什么？"><a href="#用纯-CSS-创建一个三角形的原理是什么？" class="headerlink" title="用纯 CSS 创建一个三角形的原理是什么？"></a><strong>用纯 CSS 创建一个三角形的原理是什么？</strong></h4><p>把上、左、右三条边隐藏掉（颜色设为 transparent）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#demo</span> &#123;</span><br><span class="line"> <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"> <span class="attribute">border-width</span>: <span class="number">20px</span>;</span><br><span class="line"> <span class="attribute">border-style</span>: solid;</span><br><span class="line"> <span class="attribute">border-color</span>: transparent transparent red transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="absolute-的-containing-block-容器块-计算方式跟正常流有什么不同-？"><a href="#absolute-的-containing-block-容器块-计算方式跟正常流有什么不同-？" class="headerlink" title="absolute 的 containing block(容器块) 计算方式跟正常流有什么不同 ？"></a><strong>absolute 的 containing block(容器块) 计算方式跟正常流有什么不同 ？</strong></h4><p>无论属于哪种，都要先找到其祖先元素中最近的 position 值不为 static 的元素，然后再判断：</p>
<ul>
<li>若此元素为 inline 元素，则 containing block 为能够包含这个元素生成的第一个和最后一个 inline box 的 padding box (除 margin, border 外的区域) 的最小矩形；</li>
<li>否则，则由这个祖先元素的 padding box 构成。</li>
<li>如果都找不到，则为 initial containing block。</li>
</ul>
<p>补充：</p>
<ol>
<li>static / relative：简单说就是它的父元素的内容框（即去掉 padding 的部分）</li>
<li>absolute: 向上找最近的定位为 absolute / relative 的元素</li>
<li>fixed: 它的 containing block 一律为根元素(html / body)，根元素也是 initialcontaining block  </li>
</ol>
<hr>
<h4 id="对-BFC-规范-块级格式化上下文：blockformatting-context-的理解-？"><a href="#对-BFC-规范-块级格式化上下文：blockformatting-context-的理解-？" class="headerlink" title="对 BFC 规范(块级格式化上下文：blockformatting context)的理解 ？"></a><strong>对 BFC 规范(块级格式化上下文：blockformatting context)的理解 ？</strong></h4><p>W3C CSS 2.1 规范中的一个概念，它是一个独立容器，决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。</p>
<ul>
<li>一个页面是由很多个 Box 组成的，元素的类型和 display 属性，决定了这个 Box 的类型。</li>
<li>不同类型的 Box，会参与不同的 Formatting Context（决定如何渲染文档的容器），因此 Box 内的元素会以不同的方式渲染，也就是说 BFC 内部的元素和外部的元素不会互相影响。</li>
</ul>
<hr>
<h4 id="用-position-absolute-跟用-float-有什么区别吗-？"><a href="#用-position-absolute-跟用-float-有什么区别吗-？" class="headerlink" title="用 position: absolute 跟用 float 有什么区别吗 ？"></a><strong>用 position: absolute 跟用 float 有什么区别吗 ？</strong></h4><ul>
<li>都是脱离标准流，只是 position: absolute 定位用的时候，位置可以给的更精确(想放哪就放哪)，而 float 用的更简洁，向右，左，两个方向浮动，用起来就一句代码。</li>
<li>还有就是 position: absolute 不管在哪个标签里，都可以定位到任意位置，毕竟 top，left，bottom，right 都可以给正值或负值；</li>
<li>float 只是向左或向右浮动，不如 position: absolute 灵活，浮动后再想改变位置就要加各种 margin，padding 之类的通过间距的改变来改变位置，我自身觉得这样的话用起来不方便，也不太好。</li>
<li>但在菜单栏，或者一些图标的横向排列时，用起来特别方便，一个 float 就解决了，而且每个元素之间不会有任何间距(所以可以用 float 消除元素间的距离)；</li>
</ul>
<hr>
<h4 id="canvas-与-svg-的区别-？"><a href="#canvas-与-svg-的区别-？" class="headerlink" title="canvas 与 svg 的区别 ？"></a><strong>canvas 与 svg 的区别 ？</strong></h4><ul>
<li>Canvas 是基于像素的即时模式图形系统，最适合较小的表面或较大数量的对象，Canvas 不支持鼠标键盘等事件。</li>
<li>SVG 是基于形状的保留模式图形系统，更加适合较大的表面或较小数量的对象。</li>
<li>Canvas 和 SVG 在修改方式上还存在着不同。绘制 Canvas 对象后，不能使用脚本和 CSS 对它进行修改。因为 SVG 对象是文档对象模型的一部分，所以可以随时使用脚本和 CSS 修改它们。</li>
</ul>
<p>现在对两种技术做对比归纳如下：</p>
<p>Canvas</p>
<ol>
<li>依赖分辨率</li>
<li>不支持事件处理器</li>
<li>弱的文本渲染能力</li>
<li>能够以 .png 或 .jpg 格式保存结果图像</li>
<li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li>
</ol>
<p>SVG</p>
<ol>
<li>不依赖分辨率</li>
<li>支持事件处理器</li>
<li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li>
<li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li>
<li>不适合游戏应用</li>
</ol>
<hr>
<h4 id="svg-与-canvas-的区别-？"><a href="#svg-与-canvas-的区别-？" class="headerlink" title="svg 与 canvas 的区别 ？"></a><strong>svg 与 canvas 的区别 ？</strong></h4><ul>
<li>svg 绘制出来的每一个图形的元素都是独立的 DOM 节点，能够方便的绑定事件或用来修改，而 canvas 输出的是一整幅画布；</li>
<li>svg 输出的图形是矢量图形，后期可以修改参数来自由放大缩小，不会是真和锯齿。而 canvas 输出标量画布，就像一张图片一样，放大会失真或者锯齿。</li>
</ul>
<hr>
<h4 id="何时应当时用-padding-和-margin-？"><a href="#何时应当时用-padding-和-margin-？" class="headerlink" title="何时应当时用 padding 和 margin ？"></a><strong>何时应当时用 padding 和 margin ？</strong></h4><p>何时应当使用 margin</p>
<ul>
<li>需要在 border 外侧添加空白时。</li>
<li>空白处不需要背景（色）时。</li>
<li>上下相连的两个盒子之间的空白，需要相互抵消时。 如 15px + 20px 的 margin，将得到 20px 的空白。</li>
</ul>
<p>何时应当使用 padding</p>
<ul>
<li>需要在 border 内测添加空白时。</li>
<li>空白处需要背景（色）时。</li>
<li>上下相连的两个盒子之间的空白，希望等于两者之和时。 如 15px + 20px 的 padding，将得到 35px 的空白。</li>
</ul>
<p>个人认为：<code>margin 是用来隔开元素与元素的间距；padding 是用来隔开元素与内容的间隔，让内容（文字）与（包裹）元素之间有一段 呼吸距离</code>。</p>
<hr>
<h4 id="文字在超出长度时，如何实现用省略号代替-超长长度的文字在省略显示后，如何在鼠标悬停时，以悬浮框的形式显示出全部信息"><a href="#文字在超出长度时，如何实现用省略号代替-超长长度的文字在省略显示后，如何在鼠标悬停时，以悬浮框的形式显示出全部信息" class="headerlink" title="文字在超出长度时，如何实现用省略号代替 ? 超长长度的文字在省略显示后，如何在鼠标悬停时，以悬浮框的形式显示出全部信息 ?"></a><strong>文字在超出长度时，如何实现用省略号代替 ? 超长长度的文字在省略显示后，如何在鼠标悬停时，以悬浮框的形式显示出全部信息 ?</strong></h4><p>注意：设置 width，overflow: hidden, white-space: nowrap (规定段落中的文本不进行换行), text-overflow: ellipsis，四个属性缺一不可。这种写法在所有的浏览器中都能正常显示。</p>
<hr>
<h4 id="CSS-里的-visibility-属性有个-collapse-属性值-？在不同浏览器下有什么区别-？"><a href="#CSS-里的-visibility-属性有个-collapse-属性值-？在不同浏览器下有什么区别-？" class="headerlink" title="CSS 里的 visibility 属性有个 collapse 属性值 ？在不同浏览器下有什么区别 ？"></a><strong>CSS 里的 visibility 属性有个 collapse 属性值 ？在不同浏览器下有什么区别 ？</strong></h4><p>collapse</p>
<ul>
<li>当在表格元素中使用时，此值可删除一行或一列，但是它不会影响表格的布局，被行或列占据的空间会留给其他内容使用。</li>
<li>如果此值被用在其他的元素上，会呈现为 hidden。</li>
<li>当一个元素的 visibility 属性被设置成 collapse 值后，对于一般的元素，它的表现跟 hidden 是一样的。</li>
<li>chrome中，使用 collapse 值和使用 hidden 没有区别。</li>
<li>firefox，opera 和 IE，使用 collapse 值和使用 display：none 没有什么区别。</li>
</ul>
<hr>
<h4 id="position-跟-display、overflow、float-这些特性相互叠加后会怎么样-？"><a href="#position-跟-display、overflow、float-这些特性相互叠加后会怎么样-？" class="headerlink" title="position 跟 display、overflow、float 这些特性相互叠加后会怎么样 ？"></a><strong>position 跟 display、overflow、float 这些特性相互叠加后会怎么样 ？</strong></h4><ul>
<li>display 属性规定元素应该生成的框的类型；</li>
<li>position 属性规定元素的定位类型；</li>
<li>float 属性是一种布局方式，定义元素在哪个方向浮动。</li>
<li>类似于优先级机制：position：absolute / fixed 优先级最高，有他们在时，float 不起作用，display 值需要调整。float 或者 absolute 定位的元素，只能是块元素或表格。</li>
</ul>
<hr>
<h4 id="对-BFC-规范-块级格式化上下文：block-formatting-context-的理解-？"><a href="#对-BFC-规范-块级格式化上下文：block-formatting-context-的理解-？" class="headerlink" title="对 BFC 规范(块级格式化上下文：block formatting context) 的理解 ？"></a><strong>对 BFC 规范(块级格式化上下文：block formatting context) 的理解 ？</strong></h4><p>BFC 规定了内部的 Block Box 如何布局。</p>
<p>定位方案：</p>
<ul>
<li>内部的 Box 会在垂直方向上一个接一个放置。</li>
<li>Box 垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠。</li>
<li>每个元素的 margin box 的左边，与包含块 border box 的左边相接触。</li>
<li>BFC 的区域不会与 float box 重叠。</li>
<li>BFC 是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。</li>
</ul>
<p>计算 BFC 的高度时，浮动元素也会参与计算。</p>
<p>满足下列条件之一就可触发 BFC：</p>
<ul>
<li>1、根元素，即 html</li>
<li>2、float 的值不为 none（默认）</li>
<li>3、overflow 的值不为 visible（默认）</li>
<li>4、display 的值为 inline-block、table-cell、table-caption</li>
<li>5、position 的值为 absolute 或 fixed</li>
</ul>
<hr>
<h4 id="浏览器是怎样解析-CSS-选择器的-？"><a href="#浏览器是怎样解析-CSS-选择器的-？" class="headerlink" title="浏览器是怎样解析 CSS 选择器的 ？"></a><strong>浏览器是怎样解析 CSS 选择器的 ？</strong></h4><ul>
<li>CSS 选择器的解析是从右向左解析的。</li>
<li>若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。</li>
<li>若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。</li>
<li>两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。</li>
<li>而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。</li>
<li>在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。</li>
</ul>
<hr>
<h4 id="元素竖向的百分比设定是相对于容器的高度吗-？"><a href="#元素竖向的百分比设定是相对于容器的高度吗-？" class="headerlink" title="元素竖向的百分比设定是相对于容器的高度吗 ？"></a><strong>元素竖向的百分比设定是相对于容器的高度吗 ？</strong></h4><p>当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的。</p>
<hr>
<h4 id="全屏滚动的原理是什么-？用到了-CSS-的哪些属性-？"><a href="#全屏滚动的原理是什么-？用到了-CSS-的哪些属性-？" class="headerlink" title="全屏滚动的原理是什么 ？用到了 CSS 的哪些属性 ？"></a><strong>全屏滚动的原理是什么 ？用到了 CSS 的哪些属性 ？</strong></h4><p>原理</p>
<ul>
<li>有点类似于轮播，整体的元素一直排列下去，假设有 5 个需要展示的全屏页面，那么高度是 500%，只是展示 100%，剩下的可以通过 transform 进行 y 轴定位，也可以通过 margin-top 实现。</li>
<li>overflow：hidden；transition：all 1000ms ease；</li>
</ul>
<hr>
<h4 id="什么是响应式设计-？响应式设计的基本原理是什么-？如何兼容低版本的-IE-？"><a href="#什么是响应式设计-？响应式设计的基本原理是什么-？如何兼容低版本的-IE-？" class="headerlink" title="什么是响应式设计 ？响应式设计的基本原理是什么 ？如何兼容低版本的 IE ？"></a><strong>什么是响应式设计 ？响应式设计的基本原理是什么 ？如何兼容低版本的 IE ？</strong></h4><ul>
<li>响应式网站设计( Responsive Web design ) 是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。</li>
<li>基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。</li>
<li>页面头部必须有 meta 声明的 viewport。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;” width=&quot;device-width&quot; initial-scale=&quot;1&quot; maximum-scale=&quot;1&quot; user-scalable=&quot;no&quot;/&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="视差滚动效果-？"><a href="#视差滚动效果-？" class="headerlink" title="视差滚动效果 ？"></a><strong>视差滚动效果 ？</strong></h4><p>视差滚动（Parallax Scrolling）通过在网页向下滚动的时候，<code>控制背景的移动速度比前景的移动速度慢</code>来创建出令人惊叹的 3D 效果。</p>
<ul>
<li>CSS3 实现。 优点：开发时间短、性能和开发效率比较好，缺点是不能兼容到低版本的浏览器</li>
<li>jQuery 实现。 通过控制不同层滚动速度，计算每一层的时间，控制滚动效果。优点：能兼容到各个版本的，效果可控性好。缺点：开发起来对制作者要求高。</li>
<li>插件实现方式。 例如：parallax-scrolling，兼容性十分好。</li>
</ul>
<hr>
<h4 id="before-和-after-中双冒号和单冒号有什么区别-？解释一下这-2-个伪元素的作用"><a href="#before-和-after-中双冒号和单冒号有什么区别-？解释一下这-2-个伪元素的作用" class="headerlink" title="::before 和 :after 中双冒号和单冒号有什么区别 ？解释一下这 2 个伪元素的作用"></a><strong>::before 和 :after 中双冒号和单冒号有什么区别 ？解释一下这 2 个伪元素的作用</strong></h4><ul>
<li>单冒号 (:) 用于 CSS3 伪类，双冒号 (::) 用于 CSS3 伪元素。</li>
<li>::before 就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于 dom 之中，只存在在页面之中。</li>
</ul>
<p>:before 和 :after 这两个伪元素，是在 CSS2.1 里新出现的。 起初，伪元素的前缀使用的是单冒号语法，但随着 Web 的进化，在 CSS3 的规范里，伪元素的语法被修改成使用双冒号，成为 ::before、 ::after 。</p>
<hr>
<h4 id="怎么让-Chrome-支持小于-12px-的文字-？"><a href="#怎么让-Chrome-支持小于-12px-的文字-？" class="headerlink" title="怎么让 Chrome 支持小于 12px 的文字 ？"></a><strong>怎么让 Chrome 支持小于 12px 的文字 ？</strong></h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">10px</span>;</span><br><span class="line">  -webkit-<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.8</span>);  // <span class="number">0.8</span> 是缩放比例</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<hr>
<h4 id="让页面里的字体变清晰，变细用-CSS-怎么做-？"><a href="#让页面里的字体变清晰，变细用-CSS-怎么做-？" class="headerlink" title="让页面里的字体变清晰，变细用 CSS 怎么做 ？"></a><strong>让页面里的字体变清晰，变细用 CSS 怎么做 ？</strong></h4><p>-webkit-font-smoothing 在 window 系统下没有起作用，但是在 IOS 设备上起作用 -webkit-font-smoothing：antialiased 是最佳的，灰度平滑。</p>
<hr>
<h4 id="如果需要手动写动画，你认为最小时间间隔是多久，为什么-？"><a href="#如果需要手动写动画，你认为最小时间间隔是多久，为什么-？" class="headerlink" title="如果需要手动写动画，你认为最小时间间隔是多久，为什么 ？"></a><strong>如果需要手动写动画，你认为最小时间间隔是多久，为什么 ？</strong></h4><p>多数显示器默认频率是 60Hz，即 1 秒刷新 60 次，所以理论上最小间隔为：1/60＊1000ms ＝ 16.7ms。</p>
<hr>
<h4 id="有一个高度自适应的-div，里面有两个-div，一个高度-100px，如何让另一个填满剩下的高度-？"><a href="#有一个高度自适应的-div，里面有两个-div，一个高度-100px，如何让另一个填满剩下的高度-？" class="headerlink" title="有一个高度自适应的 div，里面有两个 div，一个高度 100px，如何让另一个填满剩下的高度 ？"></a><strong>有一个高度自适应的 div，里面有两个 div，一个高度 100px，如何让另一个填满剩下的高度 ？</strong></h4><ul>
<li>外层 div 使用 position：relative；</li>
<li>高度要求自适应的 div 使用 position: absolute; top: 100px; bottom: 0; left: 0</li>
</ul>
<hr>
<h4 id="style-标签写在-body-后与-body-前有什么区别？"><a href="#style-标签写在-body-后与-body-前有什么区别？" class="headerlink" title="style 标签写在 body 后与 body 前有什么区别？"></a><strong>style 标签写在 body 后与 body 前有什么区别？</strong></h4><p>页面加载自上而下，当然是先加载样式。</p>
<p>写在 body 标签后，由于浏览器以逐行方式对 HTML 文档进行解析，当解析到写在尾部的样式表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在 windows 的 IE 下可能会出现 FOUC 现象（即样式失效导致的页面闪烁问题）</p>
<hr>
<h4 id="阐述一下CSS-Sprites"><a href="#阐述一下CSS-Sprites" class="headerlink" title="阐述一下CSS Sprites"></a><strong>阐述一下CSS Sprites</strong></h4><p>将一个页面涉及到的所有图片都包含到一张大图中去，然后利用 CSS 的 background-image，background-repeat，background-position 的组合进行背景定位。</p>
<p>利用 CSS Sprites 能很好地减少网页的 http 请求，从而大大的提高页面的性能； CSS Sprites 能减少图片的字节。</p>
<hr>
<h4 id="用-css-实现左侧宽度自适应，右侧固定宽度-？"><a href="#用-css-实现左侧宽度自适应，右侧固定宽度-？" class="headerlink" title="用 css 实现左侧宽度自适应，右侧固定宽度 ？"></a><strong>用 css 实现左侧宽度自适应，右侧固定宽度 ？</strong></h4><p>1、标准浏览器的方法</p>
<p>当然，以不折腾人为标准的 w3c 标准早就为我们提供了制作这种自适应宽度的标准方法。</p>
<ul>
<li>把 container 设为 display: table 并指定宽度 100%；</li>
<li>然后把 main + sidebar 设为 display: table-cell;</li>
<li>然后只给 sidebar 指定一个宽度，那么 main 的宽度就变成自适应了。</li>
</ul>
<p>代码很少，而且不会有额外标签。不过这是 IE7 及以下都无效的方法。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/i-4.png"></p>
<p>2、固定区域浮动，自适应区域不设置宽度但设置 margin</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    *zoom: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">320px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#666</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，sidebar 让它浮动，并设置了一个宽度；而 main 没有设置宽度。</p>
<p>大家要注意 html 中必须使用 div 标签，不要妄图使用什么 p 标签来达到目的。因为 div 有个默认属性，即如果不设置宽度，那它会自动填满它的父标签的宽度。这里的 main 就是例子。</p>
<p>当然我们不能让它填满了，填满了它就不能和 sidebar 保持同一行了。我们给它设置一个 margin。由于 sidebar 在右边，所以我们设置 main 的 margin-right 值，值比 sidebar 的宽度大一点点——以便区分它们的范围，例子中是 320。</p>
<p>假设 main 的默认宽度是 100%，那么它设置了 margin 后，它的宽度就变成了 100% - 320，此时 main 发现自己的宽度可以与 sidebar 挤在同一行了，于是它就上来了。 而宽度 100% 是相对于它的父标签来的，如果我们改变了它父标签的宽度，那 main 的宽度也就会变——比如我们把浏览器窗口缩小，那 container 的宽度就会变小，而 main 的宽度也就变小，但它的实际宽度 100% - 320 始终是不会变的。</p>
<p>这个方法看起来很完美，只要我们记得清除浮动(这里我用了最简单的方法)，那 footer 也不会错位。而且无论 main 和 sidebar 谁更长，都不会对布局造成影响。</p>
<p>但实际上这个方法有个很老火的限制——html 中 sidebar 必须在 main 之前！ 但我需要 sidebar 在 main 之后！因为我的 main 里面才是网页的主要内容，我不想主要内容反而排在次要内容后面。 但如果 sidebar 在 main 之后，那上面的一切都会化为泡影。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/i-5.png"></p>
<p>3、固定区域使用定位，自适应区域不设置宽度，但设置 margin</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">320px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#666</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/i-6.png"></p>
<p>咦，好像不对，footer 怎么还是在那儿呢？怎么没有自动往下走呢？footer 说——我不给绝对主义者让位！ 其实这与 footer 无关，而是因为 container 对 sidebar 的无视造成的——你再长，我还是没感觉。 看来这种定位方式只能满足 sidebar 自己，但对它的兄弟们却毫无益处。</p>
<p>4、左边浮动，右边 overflow: hidden;</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;<span class="attribute">margin</span>:<span class="number">0</span>; <span class="attribute">padding</span>: <span class="number">0</span>;&#125;</span><br><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span>&#123;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">100%</span>;<span class="comment">/*高度百分百显示*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#eee</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法，我利用的是创建一个新的 BFC（块级格式化上下文）来防止文字环绕的原理来实现的。</p>
<p>BFC 就是一个相对独立的布局环境，它内部元素的布局不受外面布局的影响。 它可以通过以下任何一种方式来创建： </p>
<ul>
<li>float 的值不为 none </li>
<li>position 的值不为 static 或者 relative </li>
<li>display 的值为 table-cell , table-caption , inline-block , flex , 或者 inline-flex 中的其中一个 </li>
<li>overflow 的值不为 visible</li>
</ul>
<p>关于 BFC，在 w3c 里是这样描述的：在 BFC 中，每个盒子的左外边框紧挨着 包含块 的 左边框 （从右到左的格式化时，则为右边框紧挨）。 即使在浮动里也是这样的（尽管一个包含块的边框会因为浮动而萎缩），除非这个包含块的内部创建了一个新的 BFC。 这样，当我们给右侧的元素单独创建一个 BFC 时，它将不会紧贴在包含块的左边框，而是紧贴在左元素的右边框。</p>
<hr>
<h4 id="问：浮动的原理和工作方式，会产生什么影响呢，要怎么处理-？"><a href="#问：浮动的原理和工作方式，会产生什么影响呢，要怎么处理-？" class="headerlink" title="问：浮动的原理和工作方式，会产生什么影响呢，要怎么处理 ？"></a><strong>问：浮动的原理和工作方式，会产生什么影响呢，要怎么处理 ？</strong></h4><p>工作方式：浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。</p>
<p>影响</p>
<ul>
<li>浮动会导致父元素无法被撑开，影响与父元素同级的元素。</li>
<li>与该浮动元素同级的非浮动元素，如果是块级元素，会移动到该元素下方，而块级元素内部的行内元素会环绕浮动元素；而如果是内联元素则会环绕该浮动元素。</li>
<li>与该元素同级的浮动元素，对于同一方向的浮动元素(同级)，两个元素将会跟在碰到的浮动元素后；而对于不同方向的浮动元素，在宽度足够时，将分别浮动向不同方向，在宽度不同是将导致一方换行(换行与 HTML 书写顺序有关，后边的将会浮动到下一行)。</li>
<li>浮动元素将被视作为块元素。</li>
<li>而浮动元素对于其父元素之外的元素，如果是非浮动元素，则相当于忽视该浮动元素，如果是浮动元素，则相当于同级的浮动元素。</li>
<li>而常用的清除浮动的方法，则如使用空标签，overflow，伪元素等。</li>
</ul>
<p>在使用基于浮动设计的 CSS 框架时，自会提供清除的方法，个人并不习惯使用浮动进行布局。</p>
<hr>
<h4 id="对-CSS-Grid-布局的使用"><a href="#对-CSS-Grid-布局的使用" class="headerlink" title="对 CSS Grid 布局的使用"></a><strong>对 CSS Grid 布局的使用</strong></h4><p><a href="https://yx-dimples.vercel.app/2021/08/04/CSS-Grid/">https://yx-dimples.vercel.app/2021/08/04/CSS-Grid/</a></p>
<hr>
<h4 id="rem、em、px、vh-与-vw-的区别-？"><a href="#rem、em、px、vh-与-vw-的区别-？" class="headerlink" title="rem、em、px、vh 与 vw 的区别 ？"></a><strong>rem、em、px、vh 与 vw 的区别 ？</strong></h4><p>一、 rem 的特点</p>
<ol>
<li>rem 的大小是根据 <code>html</code> 根目录下的字体大小进行计算的。</li>
<li>当我们改变根目录下的字体大小的时候，下面字体都改变。</li>
<li>rem 不仅可以设置字体的大小，也可以设置元素宽、高等属性。</li>
<li>rem 是 CSS3 新增的一个相对单位（root em，根em），这个单位与 em 区别在于使用 rem 为元素设定字体大小时，仍然是相对大小，但相对的只是 HTML 根元素。</li>
</ol>
<p>这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。 目前，除了 IE8 及更早版本外，所有浏览器均已支持 rem。 对于不支持它的浏览器，应对方法也很简单，就是多写一个绝对单位的声明。这些浏览器会忽略用 rem 设定的字体大小。</p>
<p>二、px 特点</p>
<ol>
<li>px 像素（Pixel）。相对长度单位。像素 px 是相对于显示器屏幕分辨率而言的。</li>
</ol>
<p>三、em 特点 </p>
<ol>
<li>em 的值并不是固定的；</li>
<li>em 会继承父级元素的字体大小。</li>
<li>em 是相对长度单位。当前对行内文本的字体尺寸未被人为设置，相对于当前对象内文本的字体尺寸。如则相对于浏览器的默认字体尺寸。</li>
<li>任意浏览器的默认字体高都是 16px。</li>
</ol>
<p>所有未经调整的浏览器一般都符合: 1em = 16px。那么 12px = 0.75em，10px = 0.625em。 为了简化 font-size 的换算，需要在 css 中的 body 选择器中声明 Fontsize = 62.5%，这就使 em 值变为 16px*62.5%=10px, 这样 12px = 1.2em, 10px = 1em, 也就是说只需要将你的原来的 px 数值除以 10，然后换上 em 作为单位就行了。</p>
<p>四、vh 与 vw</p>
<p>视口</p>
<ul>
<li>在桌面端，指的是浏览器的可视区域；</li>
<li>在移动端，它涉及 3个 视口：Layout Viewport（布局视口），Visual Viewport（视觉视口），Ideal Viewport（理想视口）。</li>
<li>视口单位中的 “视口”，桌面端指的是浏览器的可视区域；移动端指的就是 Viewport 中的 Layout Viewport。</li>
</ul>
<p>vh / vw 与 %</p>
<table>
<thead>
<tr>
<th>单位</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>vw</td>
<td>1vw = 视口宽度的 1%</td>
</tr>
<tr>
<td>vh</td>
<td>1vh = 视口高度的 1%</td>
</tr>
<tr>
<td>vmin</td>
<td>选取 vw 和 vh 中最小的那个</td>
</tr>
<tr>
<td>vmax</td>
<td>选取 vw 和 vh 中最大的那个</td>
</tr>
</tbody></table>
<p>比如：浏览器视口尺寸为 370px，那么 1vw = 370px * 1% = 6.5px (浏览器会四舍五入向下取 7)</p>
<p>vh / vw 与 % 区别</p>
<table>
<thead>
<tr>
<th>单位</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>%</td>
<td>元素的祖先元素</td>
</tr>
<tr>
<td>vh / vw</td>
<td>视口的尺寸</td>
</tr>
</tbody></table>
<p>不过由于 vw 和 vh 是 css3 才支持的长度单位，所以在不支持 css3 的浏览器中是无效的。</p>
<hr>
<h4 id="什么叫优雅降级和渐进增强-？"><a href="#什么叫优雅降级和渐进增强-？" class="headerlink" title="什么叫优雅降级和渐进增强 ？"></a><strong>什么叫优雅降级和渐进增强 ？</strong></h4><ul>
<li>渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</li>
<li>优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</li>
</ul>
<p>区别</p>
<ul>
<li>优雅降级是从复杂的现状开始，并试图减少用户体验的供给；</li>
<li>渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要；</li>
<li>降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。</li>
</ul>
<hr>
<p><strong>width 和 height 的百分比是相对谁讲的 ？margin 和 padding 呢？</strong></p>
<ul>
<li>width 是相对于直接父元素的 width</li>
<li>height 是相对于直接父元素的 height</li>
<li>padding 是相对于直接父元素的 width</li>
<li>margin 是相对于直接父元素的 margin</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    <span class="selector-id">#wrapper</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">800px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.parent</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: yellow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.son</span> &#123;</span><br><span class="line">        <span class="comment">/* 90*40 */</span></span><br><span class="line">        <span class="attribute">width</span>: <span class="number">30%</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">10%</span>;</span><br><span class="line">        <span class="comment">/* 30 30 */</span></span><br><span class="line">        <span class="attribute">padding-left</span>: <span class="number">10%</span>;</span><br><span class="line">        <span class="attribute">margin-left</span>: <span class="number">10%</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: green;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> id=&quot;wrapper&quot;&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;parent&quot;&gt;</span><br><span class="line">        &lt;<span class="selector-tag">div</span> class=&quot;son&quot;&gt;</span><br><span class="line">        &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>

<p>相关文章：</p>
<p><a href="https://yx-dimples.vercel.app/2021/08/04/transform%EF%BC%8Ctransition%EF%BC%8Canimation%EF%BC%8Ckeyframes/">https://yx-dimples.vercel.app/2021/08/04/transform%EF%BC%8Ctransition%EF%BC%8Canimation%EF%BC%8Ckeyframes/</a></p>
<p><a href="https://yx-dimples.vercel.app/2021/08/04/width%E3%80%81height%E3%80%81margin%E3%80%81padding/">https://yx-dimples.vercel.app/2021/08/04/width%E3%80%81height%E3%80%81margin%E3%80%81padding/</a></p>
<p><a href="https://yx-dimples.vercel.app/2021/08/04/z-index/">https://yx-dimples.vercel.app/2021/08/04/z-index/</a></p>
<hr>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><h4 id="常见的浏览器内核有哪些-？"><a href="#常见的浏览器内核有哪些-？" class="headerlink" title="常见的浏览器内核有哪些 ？"></a><strong>常见的浏览器内核有哪些 ？</strong></h4><ul>
<li>Trident 内核：IE, 360，搜狗浏览器 MaxThon、TT、The World,等。[又称 MSHTML]</li>
<li>Gecko 内核：火狐，FF，MozillaSuite / SeaMonkey 等</li>
<li>Presto 内核：Opera7 及以上。[Opera 内核原为：Presto，现为：Blink]</li>
<li>Webkit 内核：Safari，Chrome 等。 [ Chrome 的：Blink（WebKit 的分支）]</li>
</ul>
<hr>
<h4 id="try-catch-无法捕获-promise-reject-的问题"><a href="#try-catch-无法捕获-promise-reject-的问题" class="headerlink" title="try/catch 无法捕获 promise.reject 的问题"></a><strong>try/catch 无法捕获 promise.reject 的问题</strong></h4><p>try..catch 结构，它只能是同步的，无法用于异步代码模式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行<code>f2()</code>，无法通过try/catch捕获promise.reject，控制台抛出<code>Uncaught (in promise)</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>为什么改成await/async后，执行<code>f()</code>就能在catch中捕获到错误了，并不会抛出<code>Uncaught (in promise)</code></li>
</ul>
<hr>
<h4 id="error-事件的事件处理程序"><a href="#error-事件的事件处理程序" class="headerlink" title="error 事件的事件处理程序"></a><strong>error 事件的事件处理程序</strong></h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers/onerror">https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers/onerror</a></p>
<hr>
<h4 id="一个简易版的-Function-prototype-bind-实现"><a href="#一个简易版的-Function-prototype-bind-实现" class="headerlink" title="一个简易版的 Function.prototype.bind 实现"></a><strong>一个简易版的 Function.prototype.bind 实现</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.apply(context, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;前端架构师&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;.bind(obj);</span><br><span class="line">func();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>前言：ECMAscript5中的bind()是ES6中箭头函数绑定this的基础。它是的实现原理是怎样的呢？</p>
</blockquote>
<h4 id="回顾bind的用法"><a href="#回顾bind的用法" class="headerlink" title="回顾bind的用法"></a><strong>回顾bind的用法</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nick = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;nick&#x27;</span>	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length !== <span class="number">0</span>)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> <span class="built_in">arguments</span>)&#123;</span><br><span class="line">	    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[key]);	</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>①、绑定this</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nickSayName = sayName.bind(nick);</span><br><span class="line">nickSayName();</span><br></pre></td></tr></table></figure>

<p>  输出结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/i-7.png"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nickSayName = sayName.bind(nick);</span><br><span class="line">nickSayName(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>  输出结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/i-8.png"></p>
<p>③、预传参 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nickSayName = sayName.bind(nick,<span class="number">1</span>,<span class="number">2</span>);    <span class="comment">//预传参</span></span><br><span class="line">nickSayName(<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>  输出结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/i-9.png"></p>
<h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a><strong>实现原理</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.newBind = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> that = <span class="built_in">this</span>,	<span class="comment">//这个this是原函数对象</span></span><br><span class="line">	  context = [].shift.call( <span class="built_in">arguments</span> ),  <span class="comment">//第一个参数，需要绑定的this的对象</span></span><br><span class="line">          args = [].slice.call( <span class="built_in">arguments</span> );     <span class="comment">//将剩下的参数转换成数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> that.apply( context, [].concat.call( args, [].slice.call( <span class="built_in">arguments</span> )));</span><br><span class="line">	<span class="comment">//这里的args是预先传的参数</span></span><br><span class="line">	<span class="comment">//arguments是真正运行时传的参数</span></span><br><span class="line">	<span class="comment">//合并args跟arguments</span></span><br><span class="line">    &#125;		  	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> nickSayName = sayName.newBind(nick,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">nickSayName(<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/i-10.png"></p>
<hr>
<h4 id="call、apply、bind"><a href="#call、apply、bind" class="headerlink" title="call、apply、bind"></a><strong>call、apply、bind</strong></h4><ol>
<li>怎么利用 call、apply 来求一个数组中最大或者最小值 ?</li>
<li>如何利用 call、apply 来做继承 ?</li>
<li>apply、call、bind 的区别和主要应用场景 ?</li>
</ol>
<ul>
<li>call 跟 apply 的用法几乎一样，唯一的不同就是传递的参数不同，call 只能一个参数一个参数的传入。</li>
<li>apply 则只支持传入一个数组，哪怕是一个参数也要是数组形式。最终调用函数时候这个数组会拆成一个个参数分别传入。</li>
<li>至于 bind 方法，他是直接改变这个函数的 this 指向并且返回一个新的函数，之后再次调用这个函数的时候 this 都是指向 bind 绑定的第一个参数。</li>
<li>bind 传参方式跟 call 方法一致。</li>
</ul>
<p>适用场景：</p>
<p>求一个数组中最大或者最小值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果一个数组我们已知里面全都是数字，想要知道最大的那个数，由于 Array 没有 max 方法，Math 对象上有</span></span><br><span class="line"><span class="comment">// 我们可以根据 apply 传递参数的特性将这个数组当成参数传入</span></span><br><span class="line"><span class="comment">// 最终 Math.max 函数调用的时候会将 apply 的数组里面的参数一个一个传入，恰好符合 Math.max 的参数传递方式</span></span><br><span class="line"><span class="comment">// 这样变相的实现了数组的 max 方法。min 方法也同理</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">const</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr)</span><br><span class="line"><span class="built_in">console</span>.log(max)    <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>参数都会排在之后</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果你想将某个函数绑定新的`this`指向并且固定先传入几个变量可以在绑定的时候就传入，之后调用新函数传入的参数都会排在之后</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">...args</span>) </span>&#123; <span class="built_in">console</span>.log(args) &#125;</span><br><span class="line"><span class="keyword">const</span> newFn = test.bind(obj, <span class="string">&#x27;静态参数1&#x27;</span>, <span class="string">&#x27;静态参数2&#x27;</span>)</span><br><span class="line">newFn(<span class="string">&#x27;动态参数3&#x27;</span>, <span class="string">&#x27;动态参数4&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>利用 call 和 apply 做继承</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  Animal.call(<span class="built_in">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Animal.call(this) 的意思就是使用 this 对象代替 Animal 对象，那么</span></span><br><span class="line"><span class="comment">// Cat 中不就有 Animal 的所有属性和方法了吗，Cat 对象就能够直接调用 Animal 的方法以及属性了</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat(<span class="string">&quot;TONY&quot;</span>);</span><br><span class="line">cat.showName(); <span class="comment">//TONY</span></span><br></pre></td></tr></table></figure>

<p>将伪数组转化为数组（含有 length 属性的对象，dom 节点, 函数的参数 arguments）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// case1: dom节点：</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;div1&quot;</span>&gt;<span class="number">1</span>&lt;/div&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div1&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div1&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(div); <span class="comment">// HTMLCollection(3) [div.div1, div.div1, div.div1] 里面包含length属性</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.prototype.slice.call(div);</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// 数组 [div.div1, div.div1, div.div1]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//case2：fn 内的 arguments</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn10</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn10(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// case3: 含有 length 属性的对象</span></span><br><span class="line"><span class="keyword">let</span> obj4 = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">&#x27;thomas&#x27;</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="number">13</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">3</span> <span class="comment">// 一定要有length属性</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.slice.call(obj4)); <span class="comment">// [1, &quot;thomas&quot;, 13]</span></span><br></pre></td></tr></table></figure>

<p>判断变量类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> str1 = <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;thomas&#x27;</span> &#125;;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn1(arr1)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断类型的方式，这个最常用语判断 array 和 object ，null( 因为 typeof null 等于 object )</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(arr1)); <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(str1)); <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(obj1)); <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>)); <span class="comment">// [object Null]</span></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li>当我们使用一个函数需要改变 this 指向的时候才会用到 <code>call</code> <code>apply</code> <code>bind</code></li>
<li>如果你要传递的参数不多，则可以使用 fn.call(thisObj, arg1, arg2 …)</li>
<li>如果你要传递的参数很多，则可以用数组将参数整理好调用 fn.apply(thisObj, [arg1, arg2 …])</li>
<li>如果你想生成一个新的函数长期绑定某个函数给某个对象使用，则可以使用 const newFn = fn.bind(thisObj); newFn(arg1, arg2…)</li>
</ol>
<p>参考文章：</p>
<ul>
<li><a href="https://www.jianshu.com/p/bbeadae6127e">call、apply、bind 的区别</a></li>
<li><a href="https://segmentfault.com/a/1190000012772040">聊一聊 call、apply、bind 的区别</a></li>
</ul>
<hr>
<h4 id="理解-js-继承的-6-种方式"><a href="#理解-js-继承的-6-种方式" class="headerlink" title="理解 js 继承的 6 种方式"></a>理解 js 继承的 6 种方式</h4><p>想要继承，就必须要提供个父类（继承谁，提供继承的属性）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123; <span class="comment">//给构造函数添加了参数</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.sum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.age = <span class="number">10</span>; <span class="comment">//给构造函数添加了原型属性</span></span><br></pre></td></tr></table></figure>

<h5 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原型链继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Per</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;ker&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Per.prototype = <span class="keyword">new</span> Person(); <span class="comment">//主要</span></span><br><span class="line"><span class="keyword">var</span> per1 = <span class="keyword">new</span> Per();</span><br><span class="line"><span class="built_in">console</span>.log(per1.age); <span class="comment">//10</span></span><br><span class="line"><span class="comment">// instanceof 判断元素是否在另一个元素的原型链上</span></span><br><span class="line"><span class="comment">// per1 继承了Person的属性，返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(per1 <span class="keyword">instanceof</span> Person);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>重点：让新实例的原型等于父类的实例。</p>
<p>特点：1、实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新实例不会继承父类实例的属性！）</p>
<p>缺点：1、新实例无法向父类构造函数传参。</p>
<p>　　　2、继承单一。</p>
<p>　　    3、所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！）</p>
<h5 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//借用构造函数继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Con</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	Person.call(<span class="built_in">this</span>,<span class="string">&quot;jer&quot;</span>);<span class="comment">//重点</span></span><br><span class="line">    <span class="built_in">this</span>.age = <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> con1 = <span class="keyword">new</span> Con();</span><br><span class="line">consoLe.log(con1.name);<span class="comment">//&quot;jer&quot;</span></span><br><span class="line">consoLe.log(con1.age); <span class="comment">//12</span></span><br><span class="line">consoLe.log(con1 <span class="keyword">instanceof</span> Person);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>重点：用.call()和.apply()将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制））</p>
<p>特点：1、只继承了父类构造函数的属性，没有继承父类原型的属性。</p>
<p>　　    2、解决了原型链继承缺点1、2、3。</p>
<p>　　    3、可以继承多个构造函数属性（call多个）。</p>
<p>　　　4、在子实例中可向父实例传参。</p>
<p>缺点：1、只能继承父类构造函数的属性。</p>
<p>　　　2、无法实现构造函数的复用。（每次用每次都要重新调用）</p>
<p>​           3、每个新实例都有父类构造函数的副本，臃肿。</p>
<h5 id="组合继承（组合原型链继承和借用构造函数继承）（常用）"><a href="#组合继承（组合原型链继承和借用构造函数继承）（常用）" class="headerlink" title="组合继承（组合原型链继承和借用构造函数继承）（常用）"></a>组合继承（组合原型链继承和借用构造函数继承）（常用）</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//组合原型链和构造函数继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	Person.call(<span class="built_in">this</span>,name);<span class="comment">//借用构造函数模式</span></span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> Person();<span class="comment">//原型链继承</span></span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> SubType(<span class="string">&quot;gar&quot;</span>);</span><br><span class="line">consoLe.log(sub.name);<span class="comment">//&quot;gar&quot;继承了构造函数属性consoLe.log(sub.age);//10继承了父类原型的属性</span></span><br></pre></td></tr></table></figure>

<p>重点：<strong>结合了两种模式的优点，传参和复用</strong></p>
<p>特点：1、可以继承父类原型上的属性，可以传参，可复用。</p>
<p>　　    2、每个新实例引入的构造函数属性是私有的。</p>
<p>缺点：调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。</p>
<h5 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先封装一个函数容器，用来输出对象和承载继承的原型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">content</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype = obj;<span class="comment">//继承了传入的参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();<span class="comment">//返回函数对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sup = <span class="keyword">new</span> Person();<span class="comment">//拿到父类的实例</span></span><br><span class="line"><span class="keyword">var</span> sup1 = content(sup);</span><br><span class="line"><span class="built_in">console</span>.log(sup1.age );<span class="comment">//10继承了父类函数的属性</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重点：用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。object.create()就是这个原理。</p>
<p>特点：类似于复制一个对象，用函数来包装。</p>
<p>缺点：1、所有实例都会继承原型上的属性。</p>
<p>　　    2、无法实现复用。（新实例属性都是后面添加的）</p>
<h5 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">content</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype = obj;<span class="comment">//继承了传入的参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F&#123;&#125;;<span class="comment">//返回函数对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sup = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">//以上是原型式继承，给原型式继承再套个壳子传递参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subobject</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sub = content(obj);</span><br><span class="line">    sub.name = <span class="string">&quot;gar&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> sub;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sup2 = subobject(sup);</span><br><span class="line"><span class="comment">//这个函数经过声明之后就成了可增添属性的对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> subobject);<span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> sup2);<span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(sup2.name);<span class="comment">//&quot; gar&quot;，返回了个sub对象，继承了sub的属性</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重点：就是给原型式继承外面套了个壳子。</p>
<p>优点：没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象。</p>
<p>缺点：没用到原型，无法复用。</p>
<h5 id="寄生组合式继承（常用"><a href="#寄生组合式继承（常用" class="headerlink" title="寄生组合式继承（常用)"></a>寄生组合式继承（常用)</h5><p>寄生：在函数内返回对象然后调用</p>
<p>组合：1、函数的原型等于另一个实例。2、在函数中用apply或者call引入另一个构造函数，可传参　</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//寄生</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">content</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//content就是F实例的另一种表示法</span></span><br><span class="line"><span class="keyword">var</span> con = content(Person.prototype);</span><br><span class="line"><span class="comment">//con实例(F实例)的原型继承了父类函数的原型</span></span><br><span class="line"><span class="comment">//上述更像是原型链继承，只不过只继承了原型属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//组合</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Person.call(<span class="built_in">this</span>);<span class="comment">//这个继承了父类构造函数的属性</span></span><br><span class="line">&#125;<span class="comment">//解决了组合式俩次调用构造函数属性的缺点</span></span><br><span class="line"><span class="comment">//重点</span></span><br><span class="line">Sub.prototype = con;<span class="comment">//继承了con实例</span></span><br><span class="line">con.constructor = Sub;<span class="comment">//一定要修复实例</span></span><br><span class="line"><span class="keyword">var</span> sub1 = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="comment">//Sub的实例就继承了构造函数属性，父类实例，con的函数属性</span></span><br><span class="line">xconsole.log(sub1.age);<span class="comment">//10 ;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//上述和以下例子的效果是一样的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">F.prototype = Person.prototype;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Person.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">Sub.prototype = <span class="keyword">new</span> F();</span><br><span class="line"><span class="keyword">var</span> sub2 = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="built_in">console</span>.log(sub2.age);</span><br></pre></td></tr></table></figure>

<p>重点：修复了组合继承的问题</p>
<p>继承这些知识点与其说是对象的继承，更像是函数的功能用法，如何用函数做到复用，组合，这些和使用继承的思考是一样的。上述几个继承的方法都可以手动修复他们的缺点，但就是多了这个手动修复就变成了另一种继承模式。</p>
<p>这些继承模式的学习重点是学它们的思想，不然你会在coding书本上的例子的时候，会觉得明明可以直接继承为什么还要搞这么麻烦。就像原型式继承它用函数复制了内部对象的一个副本，这样不仅可以继承内部对象的属性，还能把函数（对象，来源内部对象的返回）随意调用，给它们添加属性，改个参数就可以改变原型对象，而这些新增的属性也不会相互影响。</p>
<hr>
<p><strong>mouseenter 和 mouseover 的区别</strong> </p>
<ul>
<li>不论鼠标指针穿过被选元素或其子元素，都会触发 mouseover 事件，对应 mouseout。</li>
<li>只有在鼠标指针穿过被选元素时，才会触发 mouseenter 事件，对应 mouseleave。</li>
</ul>
<hr>
<h4 id="用正则表达式匹配字符串，以字母开头，后面是数字、字符串或者下划线，长度为-9-20"><a href="#用正则表达式匹配字符串，以字母开头，后面是数字、字符串或者下划线，长度为-9-20" class="headerlink" title="用正则表达式匹配字符串，以字母开头，后面是数字、字符串或者下划线，长度为 9 - 20"></a><strong>用正则表达式匹配字符串，以字母开头，后面是数字、字符串或者下划线，长度为 9 - 20</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;^[a-zA-Z][a-zA-Z0-9_]&#123;8,19&#125;$&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="js-字符串两边截取空白的-trim-的原型方法的实现"><a href="#js-字符串两边截取空白的-trim-的原型方法的实现" class="headerlink" title="js 字符串两边截取空白的 trim 的原型方法的实现"></a><strong>js 字符串两边截取空白的 trim 的原型方法的实现</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除左右两端的空格</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trim</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> str.replace(<span class="regexp">/(^\s*)|(\s*$)/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除左边的空格 /(^\s*)/g</span></span><br><span class="line"><span class="comment">// 删除右边的空格 /(\s*$)/g</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="介绍一下你对浏览器内核的理解"><a href="#介绍一下你对浏览器内核的理解" class="headerlink" title="介绍一下你对浏览器内核的理解 ?"></a><strong>介绍一下你对浏览器内核的理解 ?</strong></h4><p>内核主要分成两部分：渲染引擎(layout engineer 或 Rendering Engine) 和 JS 引擎。</p>
<p>渲染引擎</p>
<p>负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。 浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。 所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</p>
<p>JS 引擎</p>
<p>解析和执行 javascript 来实现网页的动态效果。</p>
<p>最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</p>
<hr>
<h4 id="哪些常见操作会造成内存泄漏-？"><a href="#哪些常见操作会造成内存泄漏-？" class="headerlink" title="哪些常见操作会造成内存泄漏 ？"></a><strong>哪些常见操作会造成内存泄漏 ？</strong></h4><p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。</p>
<p>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。</p>
<ul>
<li>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。</li>
<li>闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）。</li>
</ul>
<hr>
<h4 id="线程与进程的区别-？"><a href="#线程与进程的区别-？" class="headerlink" title="线程与进程的区别 ？"></a><strong>线程与进程的区别 ？</strong></h4><ul>
<li>一个程序至少有一个进程，一个进程至少有一个线程。</li>
<li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li>
<li>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</li>
</ul>
<p>线程在执行过程中与进程还是有区别的。</p>
<ul>
<li>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li>
<li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。 但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</li>
</ul>
<hr>
<h4 id="eval-函数有什么用-？"><a href="#eval-函数有什么用-？" class="headerlink" title="eval() 函数有什么用 ？"></a><strong>eval() 函数有什么用 ？</strong></h4><p>eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。</p>
<hr>
<h4 id="实现一个方法，使得：add-2-5-和-add-2-5-的结果都为-7"><a href="#实现一个方法，使得：add-2-5-和-add-2-5-的结果都为-7" class="headerlink" title="实现一个方法，使得：add(2, 5) 和 add(2)(5) 的结果都为 7"></a><strong>实现一个方法，使得：add(2, 5) 和 add(2)(5) 的结果都为 7</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x, r</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x + r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>)(<span class="number">5</span>));  <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>,<span class="number">5</span>));  <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="alert-1-amp-amp-2-和-alert-1-0-的结果是-？"><a href="#alert-1-amp-amp-2-和-alert-1-0-的结果是-？" class="headerlink" title="alert(1 &amp;&amp; 2) 和 alert(1 || 0) 的结果是 ？"></a><strong>alert(1 &amp;&amp; 2) 和 alert(1 || 0) 的结果是 ？</strong></h4><p>alert(1 &amp;&amp;2 ) 的结果是 2</p>
<ul>
<li>只要 “&amp;&amp;” 前面是 false，无论 “&amp;&amp;” 后面是 true 还是 false，结果都将返 “&amp;&amp;” 前面的值;</li>
<li>只要 “&amp;&amp;” 前面是 true，无论 “&amp;&amp;” 后面是 true 还是 false，结果都将返 “&amp;&amp;” 后面的值;</li>
</ul>
<p>alert(0 || 1) 的结果是 1</p>
<ul>
<li>只要 “||” 前面为 false，不管 “||” 后面是 true 还是 false，都返回 “||” 后面的值。</li>
<li>只要 “||” 前面为 true，不管 “||” 后面是 true 还是 false，都返回 “||” 前面的值。</li>
</ul>
<blockquote>
<p>只要记住 0 与 任何数都是 0，其他反推。</p>
</blockquote>
<hr>
<h4 id="下面的输出结果是-？"><a href="#下面的输出结果是-？" class="headerlink" title="下面的输出结果是 ？"></a><strong>下面的输出结果是 ？</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> out = <span class="number">25</span>,</span><br><span class="line">   inner = &#123;</span><br><span class="line">        <span class="attr">out</span>: <span class="number">20</span>,</span><br><span class="line">        <span class="attr">func</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> out = <span class="number">30</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="built_in">console</span>.log((inner.func, inner.func)());</span><br><span class="line"><span class="built_in">console</span>.log(inner.func());</span><br><span class="line"><span class="built_in">console</span>.log((inner.func)());</span><br><span class="line"><span class="built_in">console</span>.log((inner.func = inner.func)());</span><br></pre></td></tr></table></figure>

<p>结果：25，20，20，25</p>
<p>代码解析：这道题的考点分两个</p>
<ol>
<li>作用域</li>
<li>运算符（赋值预算，逗号运算）</li>
</ol>
<p>先看第一个输出：25，因为 ( inner.func, inner.func ) 是进行逗号运算符，逗号运算符就是运算前面的 ”,“ 返回最后一个，举个栗子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>, j = <span class="number">1</span>, k = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log((i++, j++, k)) <span class="comment">// 返回的是 k 的值 2 ，如果写成 k++ 的话  这里返回的就是 3</span></span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(j); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(k); <span class="comment">// 2   </span></span><br></pre></td></tr></table></figure>

<p>回到原题 ( inner.func, inner.func ) 就是返回 inner.func ，而 inner.func 只是一个匿名函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> out = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而且这个匿名函数是属于 window 的，则变成了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> out = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.out;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>此刻的 this =&gt; window</p>
<p>所以 out 是 25。</p>
<p>第二和第三个 console.log 的作用域都是 inner，也就是他们执行的其实是 inner.func(); inner 作用域中是有 out 变量的，所以结果是 20。</p>
<p>第四个 console.log 考查的是一个等号运算 inner.func = inner.func ，其实返回的是运算的结果， 举个栗子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>, b = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a = b) <span class="comment">// 输出的是 3</span></span><br></pre></td></tr></table></figure>

<p>所以 inner.func = inner.func 返回的也是一个匿名函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> out = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此刻，道理就和第一个 console.log 一样了，输出的结果是 25。</p>
<hr>
<h4 id="下面程序输出的结果是-？"><a href="#下面程序输出的结果是-？" class="headerlink" title="下面程序输出的结果是 ？"></a><strong>下面程序输出的结果是 ？</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> <span class="built_in">window</span>)) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">alert(a);</span><br></pre></td></tr></table></figure>

<p>代码解析：如果 window 不包含属性 a，就声明一个变量 a，然后赋值为 1。</p>
<p>你可能认为 alert 出来的结果是 1，然后实际结果是 “undefined”。</p>
<p>要了解为什么，需要知道 JavaScript 里的 3 个概念。</p>
<p>首先，在 es6 之前，所有的全局变量都是 window 的属性，语句 var a = 1; 等价于 window.a = 1; 你可以用如下方式来检测全局变量是否声明：”变量名称” in window。</p>
<p>第二，所有的变量声明都在范围作用域的顶部，看一下相似的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(<span class="string">&quot;b&quot;</span> <span class="keyword">in</span> <span class="built_in">window</span>);</span><br><span class="line"><span class="keyword">var</span> b;</span><br></pre></td></tr></table></figure>

<p>此时，尽管声明是在 alert 之后，alert 弹出的依然是 true，这是因为 JavaScript 引擎首先会扫描所有的变量声明，然后将这些变量声明移动到顶部，最终的代码效果是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">alert(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> <span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>

<p>这样看起来就很容易解释为什么 alert 结果是 true 了。</p>
<p>第三，你需要理解该题目的意思是，变量声明被提前了，但变量赋值没有，因为这行代码包括了变量声明和变量赋值。</p>
<p>你可以将语句拆分为如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;    <span class="comment">//声明</span></span><br><span class="line">a = <span class="number">1</span>;    <span class="comment">//初始化赋值</span></span><br></pre></td></tr></table></figure>

<p>当变量声明和赋值在一起用的时候，JavaScript 引擎会自动将它分为两部以便将变量声明提前， 不将赋值的步骤提前，是因为他有可能影响代码执行出不可预期的结果。</p>
<p>所以，知道了这些概念以后，重新回头看一下题目的代码，其实就等价于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">if</span> (!(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> <span class="built_in">window</span>)) &#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">alert(a);</span><br></pre></td></tr></table></figure>

<p>这样，题目的意思就非常清楚了：首先声明 a，然后判断 a 是否在存在，如果不存在就赋值为1，很明显 a 永远在 window 里存在，这个赋值语句永远不会执行，所以结果是 undefined。</p>
<p>提前这个词语显得有点迷惑了，你可以理解为：预编译。</p>
<hr>
<h4 id="下面程序输出的结果是-？-1"><a href="#下面程序输出的结果是-？-1" class="headerlink" title="下面程序输出的结果是 ？"></a><strong>下面程序输出的结果是 ？</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  x &amp;&amp; a(--x);</span><br><span class="line">&#125;;</span><br><span class="line">alert(a);</span><br></pre></td></tr></table></figure>

<p>这个题目看起来比实际复杂，alert 的结果是 1。</p>
<p>这里依然有 3 个重要的概念需要我们知道。</p>
<ul>
<li>首先，第一个是 <code>变量声明在进入执行上下文就完成了</code>；</li>
<li>第二个概念就是<code>函数声明也是提前的，所有的函数声明都在执行代码之前都已经完成了声明，和变量声明一样</code>。</li>
</ul>
<p>澄清一下，函数声明是如下这样的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span>(<span class="params">arg1, arg2</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下不是函数，而是函数表达式，相当于变量赋值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> functionName = <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>)</span>&#123;</span><br><span class="line">       <span class="comment">//函数体</span></span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

<p>澄清一下，函数表达式没有提前，就相当于平时的变量赋值。</p>
<ul>
<li>第三需要知道的是，<code>函数声明会覆盖变量声明，但不会覆盖变量赋值</code>。</li>
</ul>
<p>为了解释这个，我们来看一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">value</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> value;</span><br><span class="line">alert(<span class="keyword">typeof</span> value);    <span class="comment">//&quot;function&quot;</span></span><br></pre></td></tr></table></figure>

<p>尽管变量声明在下面定义，但是变量 value 依然是 function，也就是说这种情况下，函数声明的优先级高于变量声明的优先级，但如果该变量 value 赋值了，那结果就完全不一样了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">value</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line">alert(<span class="keyword">typeof</span> value);    <span class="comment">//&quot;number&quot;</span></span><br></pre></td></tr></table></figure>

<p>该 value 赋值以后，变量赋值初始化就覆盖了函数声明。</p>
<p>重新回到题目，这个函数其实是一个有名函数表达式，函数表达式不像函数声明一样可以覆盖变量声明，但你可以注意到，变量 b 是包含了该函数表达式，而该函数表达式的名字是 a。</p>
<p>不同的浏览器对 a 这个名词处理有点不一样，在 IE 里，会将 a 认为函数声明，所以它被变量初始化覆盖了，就是说如果调用 a(–x) 的话就会出错，而其它浏览器在允许在函数内部调用 a(–x)，因为这时候 a 在函数外面依然是数字。 基本上，IE 里调用 b(2) 的时候会出错，但其它浏览器则返回 undefined。</p>
<p>理解上述内容之后，该题目换成一个更准确和更容易理解的代码应该像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>,</span><br><span class="line">    b = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">      x &amp;&amp; b(--x);</span><br><span class="line">    &#125;;</span><br><span class="line">alert(a);</span><br></pre></td></tr></table></figure>

<p>这样的话，就很清晰地知道为什么 alert 的总是 1 了。</p>
<hr>
<h4 id="下面程序输出的结果是-？-2"><a href="#下面程序输出的结果是-？-2" class="headerlink" title="下面程序输出的结果是 ？"></a><strong>下面程序输出的结果是 ？</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">alert(a);</span><br></pre></td></tr></table></figure>

<p>alert 的值是下面的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个题目比较简单：即函数声明和变量声明的关系和影响，遇到同名的函数声明，不会重新定义。</p>
<hr>
<h4 id="下面程序输出的结果是-？-3"><a href="#下面程序输出的结果是-？-3" class="headerlink" title="下面程序输出的结果是 ？"></a><strong>下面程序输出的结果是 ？</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">x, y, a</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">arguments</span>[<span class="number">2</span>] = <span class="number">10</span>;</span><br><span class="line">        alert(a);</span><br><span class="line">&#125;</span><br><span class="line">b(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>结果为 10。</p>
<p>活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。</p>
<hr>
<h4 id="三道判断输出的题都是经典的题"><a href="#三道判断输出的题都是经典的题" class="headerlink" title="三道判断输出的题都是经典的题"></a><strong>三道判断输出的题都是经典的题</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">b();</span><br></pre></td></tr></table></figure>

<p>明显输出是 3，因为里面修改了 a 这个全局变量，那个 function a(){} 是用来干扰的，虽然函数声明会提升，就被 a 给覆盖掉了，这是我的理解。</p>
<p>不记得具体的，就类似如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> baz = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> bazz =&#123;</span><br><span class="line">  <span class="attr">baz</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">getbaz</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.baz</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(bazz.getbaz())</span><br><span class="line"><span class="keyword">var</span> g = bazz.getbaz;</span><br><span class="line"><span class="built_in">console</span>.log(g()) ;</span><br></pre></td></tr></table></figure>

<p>第一个输出是 2，第二个输出是 3。</p>
<p>这题考察的就是 this 的指向，函数作为对象本身属性调用的时候，this 指向对象，作为普通函数调用的时候，就指向全局了。</p>
<p>还有下面的题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">  arr[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">3</span>]();</span><br></pre></td></tr></table></figure>

<p>典型的闭包，弹出 5 。</p>
<hr>
<h4 id="解释清楚-null-和-undefined"><a href="#解释清楚-null-和-undefined" class="headerlink" title="解释清楚 null 和 undefined"></a><strong>解释清楚 null 和 undefined</strong></h4><p>null 用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。 null 表示”没有对象”，即该处不应该有值。 null 典型用法是： </p>
<ul>
<li>作为函数的参数，表示该函数的参数不是对象。 </li>
<li>作为对象原型链的终点。</li>
</ul>
<p>当声明的变量还未被初始化时，变量的默认值为 undefined。 undefined 表示”缺少值”，就是此处应该有一个值，但是还没有定义。 </p>
<ul>
<li>变量被声明了，但没有赋值时，就等于 undefined。 </li>
<li>调用函数时，应该提供的参数没有提供，该参数等于 undefined。 </li>
<li>对象没有赋值的属性，该属性的值为 undefined。 </li>
<li>函数没有返回值时，默认返回 undefined。</li>
</ul>
<p>未定义的值和定义未赋值的为 undefined，null 是一种特殊的 object，NaN 是一种特殊的 number。</p>
<hr>
<h4 id="讲一下-1-和-Number-1-的区别"><a href="#讲一下-1-和-Number-1-的区别" class="headerlink" title="讲一下 1 和 Number(1) 的区别"></a><strong>讲一下 1 和 Number(1) 的区别</strong></h4><ul>
<li>1 是一个原始定义好的 number 类型；</li>
<li>Number(1) 是一个函数类型，是我们自己声明的一个函数（方法）。</li>
</ul>
<hr>
<h4 id="讲一下-prototype-是什么东西，原型链的理解，什么时候用-prototype-？"><a href="#讲一下-prototype-是什么东西，原型链的理解，什么时候用-prototype-？" class="headerlink" title="讲一下 prototype 是什么东西，原型链的理解，什么时候用 prototype ？"></a><strong>讲一下 prototype 是什么东西，原型链的理解，什么时候用 prototype ？</strong></h4><p>prototype 是函数对象上面预设的对象属性。</p>
<hr>
<h4 id="实现-add-1-2-3-6"><a href="#实现-add-1-2-3-6" class="headerlink" title="实现 add(1)(2)(3) = 6"></a><strong>实现 add(1)(2)(3) = 6</strong></h4><p>这题考察的是柯里化,做这题之前呢,我们得知道柯里化的概念:</p>
<p>柯里化就是把接收多个参数的函数变换成接收一个单一参数(最初函数的第一个参数)的函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> curry = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span> </span><br><span class="line">            args.length &lt; fn.length </span><br><span class="line">            <span class="comment">// 参数长度不足时,重新柯里化函数,等待接受新参数</span></span><br><span class="line">            ? <span class="function">(<span class="params">...<span class="built_in">arguments</span></span>) =&gt;</span> curry(fn, ...args, ...arguments)</span><br><span class="line">            <span class="comment">// 函数长度满足时,执行函数</span></span><br><span class="line">             : fn(...args);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumFn</span>(<span class="params">a, b, c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sum = curry(sumFn);</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">//6</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="script-标签的-defer-和-async"><a href="#script-标签的-defer-和-async" class="headerlink" title="script 标签的 defer 和 async"></a><strong>script 标签的 defer 和 async</strong></h4><ul>
<li>一个普通的 <code>&lt;script&gt;</code> 标签的加载和解析都是同步的，会阻塞 DOM 的渲染，这也就是我们经常会把 <code>&lt;script&gt;</code> 写在 <code>&lt;body&gt;</code>底部的原因之一，为了防止加载资源而导致的长时间的白屏。</li>
<li>另一个原因是 js 可能会进行 DOM 操作，所以要在 DOM 全部渲染完后再执行。</li>
</ul>
<p>defer</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果 script 标签设置了该属性，则浏览器会异步的下载该文件并且不会影响到后续 DOM 的渲染；</span><br><span class="line">如果有多个设置了 defer 的 script 标签存在，则会按照顺序执行所有的 script；</span><br><span class="line">defer 脚本会在文档渲染完毕后，DOMContentLoaded 事件调用前执行。</span><br></pre></td></tr></table></figure>

<p>async</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async 的设置，会使得 script 脚本异步的加载并在允许的情况下执行 async 的执行，</span><br><span class="line">并不会按着 script 在页面中的顺序来执行，而是谁先加载完谁执行。</span><br></pre></td></tr></table></figure>

<ul>
<li>概括来讲，就是这两个属性都会使 script 标签异步加载，然而执行的时机是不一样的。</li>
<li>也就是说 async 是乱序的，而 defer 是顺序执行，这也就决定了async 比较适用于百度分析或者谷歌分析这类不依赖其他脚本的库。</li>
</ul>
<p>推荐的应用场景</p>
<p>defer</p>
<p>如果你的脚本代码依赖于页面中的 DOM 元素（文档是否解析完毕），或者被其他脚本文件依赖。</p>
<p>例：</p>
<ul>
<li>评论框</li>
<li>代码语法高亮</li>
<li>polyfill.js</li>
</ul>
<p>async</p>
<p>如果你的脚本并不关心页面中的 DOM 元素（文档是否解析完毕），并且也不会产生其他脚本需要的数据。</p>
<p>例：百度统计</p>
<p>如果不太能确定的话，用 defer 总是会比 async 稳定。。。</p>
<p>参考：<a href="https://www.cnblogs.com/jiasm/p/7683930.html">浅谈 script 标签中的 async 和 defer</a></p>
<hr>
<h4 id="函数里的-this-什么含义，什么情况下，怎么用-？"><a href="#函数里的-this-什么含义，什么情况下，怎么用-？" class="headerlink" title="函数里的 this 什么含义，什么情况下，怎么用 ？"></a><strong>函数里的 this 什么含义，什么情况下，怎么用 ？</strong></h4><ul>
<li>this 是 Javascript 语言的一个关键字。</li>
<li>它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。</li>
<li>随着函数使用场合的不同，this 的值会发生变化。</li>
<li>但是有一个总的原则，那就是 <code>this 指的是，调用函数的那个对象</code>。</li>
</ul>
<p>情况一：纯粹的函数调用 </p>
<p>这是函数的最通常用法，<code>属于全局性调用，因此 this 就代表全局对象 window</code>。  　　</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;    　　　</span><br><span class="line">  <span class="built_in">this</span>.x = <span class="number">1</span>;    　　　　</span><br><span class="line">  alert(<span class="built_in">this</span>.x);    　　</span><br><span class="line">&#125;    　　</span><br><span class="line">test(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>为了证明 this 就是全局对象，我对代码做一些改变：  　　</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;    　　</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;    　　　　</span><br><span class="line">  alert(<span class="built_in">this</span>.x);    　　</span><br><span class="line">&#125;    　　</span><br><span class="line">test(); <span class="comment">// 1    </span></span><br></pre></td></tr></table></figure>

<p>运行结果还是 1。</p>
<p>再变一下：  　　</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;    　　</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;    　　　　</span><br><span class="line">  <span class="built_in">this</span>.x = <span class="number">0</span>;    　　</span><br><span class="line">&#125;    　　</span><br><span class="line">test();</span><br><span class="line">alert(x); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>情况二：作为对象方法的调用  </p>
<p><code>函数还可以作为某个对象的方法调用，这时 this 就指这个上级对象</code>。  　　</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;    　　　　</span><br><span class="line">  alert(<span class="built_in">this</span>.x);    　　</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>    　　</span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;    　　</span><br><span class="line">o.x = <span class="number">1</span>;    　　</span><br><span class="line">o.m = test;    　　</span><br><span class="line">o.m(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>情况三： 作为构造函数调用  </p>
<p>所谓构造函数，就是通过这个函数生成一个新对象（object）。这时的 this 就指这个新对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>)</span>&#123;    　　　　</span><br><span class="line">  <span class="built_in">this</span>.x = <span class="number">1</span>;    　　</span><br><span class="line">&#125;    　　</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> Test();</span><br><span class="line">alert(o.x); <span class="comment">// 1    </span></span><br></pre></td></tr></table></figure>

<p>运行结果为 1。为了表明这时 this 不是全局对象，对代码做一些改变：  　　</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;    　　</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>)</span>&#123;    　　　　</span><br><span class="line">  <span class="built_in">this</span>.x = <span class="number">1</span>;    　　</span><br><span class="line">&#125;    　　</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> Test();    　　</span><br><span class="line">alert(x); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>运行结果为 2，表明全局变量 x 的值没变。</p>
<p>情况四： apply 调用  </p>
<p>apply() 是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this 指的就是这第一个参数。  　　</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;    　　</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;    　　　　</span><br><span class="line">  alert(<span class="built_in">this</span>.x);    　　</span><br><span class="line">&#125;    　　</span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;    　　</span><br><span class="line">o.x = <span class="number">1</span>;    　　</span><br><span class="line">o.m = test;    　　</span><br><span class="line">o.m.apply(); <span class="comment">// 0    </span></span><br></pre></td></tr></table></figure>

<p>apply() 的参数为空时，默认调用全局对象。因此，这时的运行结果为 0，证明 this 指的是全局对象。   如果把最后一行代码修改为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">o.m.apply(o); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>运行结果就变成了 1，证明了这时 this 代表的是对象 o。</p>
<hr>
<h4 id="apply-和-call-什么含义，什么区别-？什么时候用-？"><a href="#apply-和-call-什么含义，什么区别-？什么时候用-？" class="headerlink" title="apply 和 call  什么含义，什么区别 ？什么时候用 ？"></a><strong>apply 和 call  什么含义，什么区别 ？什么时候用 ？</strong></h4><p>call，apply 都属于 Function.prototype 的一个方法，它是 JavaScript 引擎内在实现的，因为属于 Function.prototype，所以每个 Function 对象实例(就是每个方法)都有 call，apply 属性。</p>
<p>既然作为方法的属性，那它们的使用就当然是针对方法的了，这两个方法是容易混淆的，因为它们的作用一样，只是使用方式不同。</p>
<p>语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo.call(<span class="built_in">this</span>, arg1, arg2, arg3) == foo.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>) == <span class="built_in">this</span>.foo(arg1, arg2, arg3);</span><br></pre></td></tr></table></figure>

<ul>
<li>相同点：两个方法产生的作用是完全一样的。</li>
<li>不同点：方法传递的参数不同。</li>
</ul>
<p>每个函数对象会有一些方法可以去修改函数执行时里面的 this，比较常见得到就是 call 和 apply，通过 call 和 apply 可以重新定义函数的执行环境，即 this 的指向。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">c, d</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a + <span class="built_in">this</span>.b + c + d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">3</span> &#125;;</span><br><span class="line">add.call(o, <span class="number">5</span>, <span class="number">7</span>);    <span class="comment">//1+3+5+7=16</span></span><br><span class="line"><span class="comment">//传参的时候是扁平的把每个参数传进去</span></span><br><span class="line"></span><br><span class="line">add.apply(o, [<span class="number">10</span>, <span class="number">20</span>]);   <span class="comment">//1+3+10+20=34</span></span><br><span class="line"><span class="comment">//传参的时候是把参数作为一个数组传进去</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//什么时候使用 call 或者 apply</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">this</span>));</span><br><span class="line">  <span class="comment">// 用来调用一些无法直接调用的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.call(<span class="number">7</span>); <span class="comment">// &quot;[object Number]&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="异步过程的构成要素有哪些？和异步过程是怎样的-？"><a href="#异步过程的构成要素有哪些？和异步过程是怎样的-？" class="headerlink" title="异步过程的构成要素有哪些？和异步过程是怎样的 ？"></a><strong>异步过程的构成要素有哪些？和异步过程是怎样的 ？</strong></h4><p>总结一下，一个异步过程通常是这样的：</p>
<ul>
<li>主线程发起一个异步请求，相应的工作线程接收请求并告知主线程已收到(异步函数返回)；</li>
<li>主线程可以继续执行后面的代码，同时工作线程执行异步任务；</li>
<li>工作线程完成工作后，通知主线程；</li>
<li>主线程收到通知后，执行一定的动作(调用回调函数)。</li>
</ul>
<ol>
<li>异步函数通常具有以下的形式：A(args…, callbackFn)。</li>
<li>它可以叫做异步过程的发起函数，或者叫做异步任务注册函数。</li>
<li>args 和 callbackFn 是这个函数的参数。</li>
</ol>
<p>所以，从主线程的角度看，一个异步过程包括下面两个要素：</p>
<ul>
<li>发起函数(或叫注册函数) A。</li>
<li>回调函数 callbackFn。</li>
</ul>
<p>它们都是在主线程上调用的，其中注册函数用来发起异步过程，回调函数用来处理结果。</p>
<p>举个具体的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(fn, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>其中的 setTimeout 就是异步过程的发起函数，fn 是回调函数。</p>
<p>注意：前面说的形式 A(args…, callbackFn) 只是一种抽象的表示，并不代表回调函数一定要作为发起函数的参数。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange = xxx; <span class="comment">// 添加回调函数</span></span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>, url);</span><br><span class="line">xhr.send(); <span class="comment">// 发起函数</span></span><br></pre></td></tr></table></figure>

<p>发起函数和回调函数就是分离的。</p>
<hr>
<h4 id="说说消息队列和事件循环"><a href="#说说消息队列和事件循环" class="headerlink" title="说说消息队列和事件循环"></a><strong>说说消息队列和事件循环</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/i-11.png"></p>
<ul>
<li>主线程在执行完当前循环中的所有代码后，就会到消息队列取出这条消息(也就是 message 函数)，并执行它。</li>
<li>完成了工作线程对主线程的通知，回调函数也就得到了执行。</li>
<li>如果一开始主线程就没有提供回调函数，AJAX 线程在收到 HTTP 响应后，也就没必要通知主线程，从而也没必要往消息队列放消息。</li>
</ul>
<blockquote>
<p>异步过程的回调函数，一定不在当前的这一轮事件循环中执行。</p>
</blockquote>
<hr>
<h4 id="session-与-cookie-的区别"><a href="#session-与-cookie-的区别" class="headerlink" title="session 与 cookie 的区别"></a><strong>session 与 cookie 的区别</strong></h4><ul>
<li>session 保存在服务器，客户端不知道其中的信息；</li>
<li>cookie 保存在客户端，服务器能够知道其中的信息。 </li>
<li>session 中保存的是对象，cookie 中保存的是字符串。  </li>
<li>session 不能区分路径，同一个用户在访问一个网站期间，所有的 session 在任何一个地方都可以访问到。</li>
<li>而 cookie 中如果设置了路径参数，那么同一个网站中不同路径下的 cookie 互相是访问不到的。  </li>
</ul>
<hr>
<h4 id="cookies-是干嘛的，服务器和浏览器之间的-cookies-是怎么传的，httponly-的-cookies-和可读写的-cookie-有什么区别，有无长度限制"><a href="#cookies-是干嘛的，服务器和浏览器之间的-cookies-是怎么传的，httponly-的-cookies-和可读写的-cookie-有什么区别，有无长度限制" class="headerlink" title="cookies 是干嘛的，服务器和浏览器之间的 cookies 是怎么传的，httponly 的 cookies 和可读写的 cookie 有什么区别，有无长度限制 ?"></a><strong>cookies 是干嘛的，服务器和浏览器之间的 cookies 是怎么传的，httponly 的 cookies 和可读写的 cookie 有什么区别，有无长度限制 ?</strong></h4><ul>
<li>cookies 是一些存储在用户电脑上的小文件。</li>
<li>它是被设计用来保存一些站点的用户数据，这样能够让服务器为这样的用户定制内容，后者页面代码能够获取到 cookie 值然后发送给服务器。</li>
<li>比如 cookie 中存储了所在地理位置，以后每次进入地图就默认定位到改地点即可。</li>
</ul>
<hr>
<h4 id="请描述一下-cookies，sessionStorage-和-localStorage-的区别"><a href="#请描述一下-cookies，sessionStorage-和-localStorage-的区别" class="headerlink" title="请描述一下 cookies，sessionStorage 和 localStorage 的区别"></a><strong>请描述一下 cookies，sessionStorage 和 localStorage 的区别</strong></h4><p>共同点</p>
<ul>
<li>都是保存在浏览器端，且同源的。</li>
</ul>
<p>区别</p>
<ul>
<li>cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递。</li>
<li>而 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。</li>
<li>cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下。</li>
<li>存储大小限制也不同，cookie 数据不能超过 4k，同时因为每次 http 请求都会携带 cookie，所以 cookie 只适合保存很小的数据，如会话标识。</li>
<li>sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。</li>
<li>数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie 只在设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。</li>
<li>作用域不同，sessionStorage 在不同的浏览器窗口中<code>不共享</code>，即使是同一个页面；cookie 和 localStorage 在所有同源窗口中都是共享的。</li>
</ul>
<hr>
<h4 id="从敲入-URL-到渲染完成的整个过程，包括-DOM-构建的过程，说的约详细越好"><a href="#从敲入-URL-到渲染完成的整个过程，包括-DOM-构建的过程，说的约详细越好" class="headerlink" title="从敲入 URL 到渲染完成的整个过程，包括 DOM 构建的过程，说的约详细越好"></a><strong>从敲入 URL 到渲染完成的整个过程，包括 DOM 构建的过程，说的约详细越好</strong></h4><ul>
<li>用户输入 url 地址，浏览器根据域名寻找 IP 地址</li>
<li>浏览器向服务器发送 http 请求，如果服务器段返回以 301 之类的重定向，浏览器根据相应头中的 location 再次发送请求</li>
<li>服务器端接受请求，处理请求生成 html 代码，返回给浏览器，这时的 html 页面代码可能是经过压缩的</li>
<li>浏览器接收服务器响应结果，如果有压缩则首先进行解压处理，紧接着就是页面解析渲染</li>
<li>解析渲染该过程主要分为以下步骤：解析 HTML、构建 DOM 树、DOM 树与 CSS 样式进行附着构造呈现树</li>
<li>布局</li>
<li>绘制</li>
</ul>
<p>详情：<a href="https://juejin.im/post/5b9ba9c15188255c8320fe27">面试题之从敲入 URL 到浏览器渲染完成</a></p>
<hr>
<h4 id="是否了解公钥加密和私钥加密。如何确保表单提交里的密码字段不被泄露。"><a href="#是否了解公钥加密和私钥加密。如何确保表单提交里的密码字段不被泄露。" class="headerlink" title="是否了解公钥加密和私钥加密。如何确保表单提交里的密码字段不被泄露。"></a><strong>是否了解公钥加密和私钥加密。如何确保表单提交里的密码字段不被泄露。</strong></h4><p>公钥用于对数据进行加密，私钥用于对数据进行解密。</p>
<p>很直观的理解：公钥就是公开的密钥，其公开了大家才能用它来加密数据。私钥是私有的密钥，谁有这个密钥才能够解密密文。</p>
<p>解决方案 1:</p>
<p>form 在提交的过程中，对密码字段是不进行加密而是以明码的形式进行数据传输的。 如果要对数据进行加密，你可以自己写一个脚本对内容进行编码后传输，只是这个安全性也并不高。</p>
<p>解决方案 2:</p>
<p>如果想对数据进行加密，你可以使用 HTTPS 安全传输协议，这个协议是由系统进行密码加密处理的，在数据传输中是绝对不会被拦截获取的，只是 HTTPS 的架设会相对麻烦点。一些大型网站的登录、银行的在线网关等都是走这条路。</p>
<hr>
<h4 id="验证码是干嘛的，是为了解决什么安全问题。"><a href="#验证码是干嘛的，是为了解决什么安全问题。" class="headerlink" title="验证码是干嘛的，是为了解决什么安全问题。"></a><strong>验证码是干嘛的，是为了解决什么安全问题。</strong></h4><p>所谓验证码，就是将一串随机产生的数字或符号，生成一幅图片， 图片里加上一些干扰象素（防止OCR），由用户肉眼识别其中的验证码信息，输入表单提交网站验证，验证成功后才能使用某项功能。</p>
<ul>
<li>验证码一般是防止批量注册的，人眼看起来都费劲，何况是机器。</li>
<li>像百度贴吧未登录发贴要输入验证码大概是防止大规模匿名回帖的发生。</li>
<li>目前，不少网站为了防止用户利用机器人自动注册、登录、灌水，都采用了验证码技术。</li>
</ul>
<hr>
<h4 id="截取字符串-abcdefg-的-efg。"><a href="#截取字符串-abcdefg-的-efg。" class="headerlink" title="截取字符串 abcdefg 的 efg。"></a><strong>截取字符串 abcdefg 的 efg。</strong></h4><p>从第四位开始截取</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(<span class="string">&#x27;abcdefg&#x27;</span>.substring(<span class="number">4</span>));</span><br><span class="line">alert (<span class="string">&#x27;abcdefg&#x27;</span>.slice(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="判断一个字符串中出现次数最多的字符，统计这个次数"><a href="#判断一个字符串中出现次数最多的字符，统计这个次数" class="headerlink" title="判断一个字符串中出现次数最多的字符，统计这个次数"></a><strong>判断一个字符串中出现次数最多的字符，统计这个次数</strong></h4><p>步骤</p>
<ul>
<li>将字符串转化数组 </li>
<li>创建一个对象 </li>
<li>遍历数组，判断对象中是否存在数组中的值，如果存在值 +1，不存在赋值为 1</li>
<li>定义两个变量存储字符值，字符出现的字数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;abaasdffggghhjjkkgfddsssss3444343&#x27;</span>;</span><br><span class="line"><span class="comment">// 1.将字符串转换成数组</span></span><br><span class="line"><span class="keyword">var</span> newArr = str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// 2.创建一个对象</span></span><br><span class="line"><span class="keyword">var</span> json = &#123;&#125;;</span><br><span class="line"><span class="comment">// 3. 所有字母出现的次数，判断对象中是否存在数组中的值，如果存在值 +1，不存在赋值为 1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; newArr.length; i++)&#123;</span><br><span class="line">      <span class="comment">// 类似：json : &#123; ‘a’: 3, ’b’: 1 &#125;</span></span><br><span class="line">      <span class="keyword">if</span>(json[newArr[i]])&#123;</span><br><span class="line">         json[newArr[i]] +=<span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           json[newArr[i]] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4 定义两个变量存储字符值，字符出现的字数</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0</span> ; <span class="comment">//次数</span></span><br><span class="line"><span class="keyword">var</span> element = <span class="string">&quot;&quot;</span>; <span class="comment">//最多的项</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> json)&#123;</span><br><span class="line">   <span class="keyword">if</span>(json[k] &gt; num)&#123;</span><br><span class="line">     num = json[k];</span><br><span class="line">     element = k ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;出现次数：&quot;</span>+num +<span class="string">&quot;最多的字符：&quot;</span>+ element);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="document-write-和-innerHTML-的区别"><a href="#document-write-和-innerHTML-的区别" class="headerlink" title="document.write 和 innerHTML 的区别"></a><strong>document.write 和 innerHTML 的区别</strong></h4><ul>
<li>document.write 是直接写入到页面的内容流，如果在写之前没有调用 document.open, 浏览器会自动调用 open。每次写完关闭之后重新调用该函数，会导致页面被重写。</li>
<li>innerHTML 则是 DOM 页面元素的一个属性，代表该元素的 html 内容。你可以精确到某一个具体的元素来进行更改。如果想修改 document 的内容，则需要修改 document.documentElement.innerElement。</li>
<li>innerHTML 将内容写入某个 DOM 节点，不会导致页面全部重绘。</li>
<li>innerHTML 很多情况下都优于 document.write，其原因在于其允许更精确的控制要刷新页面的那一个部分。</li>
<li>document.write 是重写整个 document, 写入内容是字符串的 html；innerHTML 是 HTMLElement 的属性，是一个元素的内部 html 内容 </li>
</ul>
<hr>
<h4 id="JS-识别不同浏览器信息"><a href="#JS-识别不同浏览器信息" class="headerlink" title="JS 识别不同浏览器信息"></a><strong>JS 识别不同浏览器信息</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myBrowser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> userAgent = navigator.userAgent; <span class="comment">//取得浏览器的userAgent字符串  </span></span><br><span class="line">  <span class="keyword">var</span> isOpera = userAgent.indexOf(<span class="string">&quot;Opera&quot;</span>) &gt; -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (isOpera) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Opera&quot;</span></span><br><span class="line">  &#125;; <span class="comment">//判断是否Opera浏览器  </span></span><br><span class="line">  <span class="keyword">if</span> (userAgent.indexOf(<span class="string">&quot;Firefox&quot;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Firefox&quot;</span>;</span><br><span class="line">  &#125;  <span class="comment">//判断是否Firefox浏览器  </span></span><br><span class="line">  <span class="keyword">if</span> (userAgent.indexOf(<span class="string">&quot;Chrome&quot;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Chrome&quot;</span>;</span><br><span class="line">  &#125;   <span class="comment">//判断是否Google浏览器  </span></span><br><span class="line">  <span class="keyword">if</span> (userAgent.indexOf(<span class="string">&quot;Safari&quot;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Safari&quot;</span>;</span><br><span class="line">  &#125; <span class="comment">//判断是否Safari浏览器  </span></span><br><span class="line">  <span class="keyword">if</span> (userAgent.indexOf(<span class="string">&quot;compatible&quot;</span>) &gt; -<span class="number">1</span> &amp;&amp; userAgent.indexOf(<span class="string">&quot;MSIE&quot;</span>) &gt; -<span class="number">1</span> &amp;&amp; !isOpera) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;IE&quot;</span>;</span><br><span class="line">  &#125;; <span class="comment">//判断是否IE浏览器  </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<hr>
<h4 id="JavaScript-常见的内置对象"><a href="#JavaScript-常见的内置对象" class="headerlink" title="JavaScript 常见的内置对象"></a><strong>JavaScript 常见的内置对象</strong></h4><p>有 Object、Math、String、Array、Number、Function、Boolean、JSON 等，其中 Object 是所有对象的基类，采用了原型继承方式。</p>
<hr>
<h4 id="编写一个方法，求一个字符串的字节长度"><a href="#编写一个方法，求一个字符串的字节长度" class="headerlink" title="编写一个方法，求一个字符串的字节长度"></a><strong>编写一个方法，求一个字符串的字节长度</strong></h4><p>假设：一个英文字符占用一个字节，一个中文字符占用两个字节</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getBytes(str)&#123;</span><br><span class="line">    var len = str.length;</span><br><span class="line">    var bytes = len;</span><br><span class="line">    for(var i = 0; i &lt; len; i++)&#123;</span><br><span class="line">        if (str.charCodeAt(i) &gt; 255)  bytes++;</span><br><span class="line">    &#125;</span><br><span class="line">    return bytes;</span><br><span class="line">&#125;</span><br><span class="line">alert(getBytes(&quot;你好,as&quot;));</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="JS-组成"><a href="#JS-组成" class="headerlink" title="JS 组成"></a><strong>JS 组成</strong></h4><ul>
<li>核心（ECMAScript） 描述了该语言的语法和基本对象</li>
<li>文档对象模型(DOM) 描述了处理网页内容的方法和接口</li>
<li>浏览器对象模型(BOM) 描述了与浏览器进行交互的方法和接口</li>
</ul>
<hr>
<h4 id="new-操作符具体干了什么呢"><a href="#new-操作符具体干了什么呢" class="headerlink" title="new 操作符具体干了什么呢 ?"></a><strong>new 操作符具体干了什么呢 ?</strong></h4><ul>
<li>创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</li>
<li>属性和方法被加入到 this 引用的对象中。</li>
<li>新创建的对象由 this 所引用，并且最后隐式的返回 this 。</li>
</ul>
<hr>
<h4 id="JSON-的了解？"><a href="#JSON-的了解？" class="headerlink" title="JSON 的了解？"></a><strong>JSON 的了解？</strong></h4><ul>
<li>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。</li>
<li>它是基于 JavaScript 的一个子集。</li>
<li>数据格式简单，易于读写，占用带宽小。</li>
<li>格式：采用键值对。例如：{ “age‟: ‟12‟, ”name‟: ‟back‟ }</li>
</ul>
<hr>
<h4 id="你有哪些性能优化的方法-？"><a href="#你有哪些性能优化的方法-？" class="headerlink" title="你有哪些性能优化的方法 ？"></a><strong>你有哪些性能优化的方法 ？</strong></h4><p>web 前端是应用服务器处理之前的部分，前端主要包括：HTML、CSS、javascript、image 等各种资源，针对不同的资源有不同的优化方式。</p>
<p>内容优化</p>
<ul>
<li>减少 HTTP 请求数。这条策略是最重要最有效的，因为一个完整的请求要经过 DNS 寻址，与服务器建立连接，发送数据，等待服务器响应，接收数据这样一个消耗时间成本和资源成本的复杂的过程。 常见方法：合并多个 CSS 文件和 js 文件，利用 CSS Sprites 整合图像，Inline Images (使用 data：URL scheme 在实际的页面嵌入图像数据 )，合理设置 HTTP 缓存等。</li>
<li>减少 DNS 查找</li>
<li>避免重定向</li>
<li>使用 Ajax 缓存</li>
<li>延迟加载组件，预加载组件</li>
<li>减少 DOM 元素数量。页面中存在大量 DOM 元素，会导致 javascript 遍历 DOM 的效率变慢。</li>
<li>最小化 iframe 的数量。iframes 提供了一个简单的方式把一个网站的内容嵌入到另一个网站中。但其创建速度比其他包括 JavaScript 和 CSS 的 DOM 元素的创建慢了 1-2 个数量级。</li>
<li>避免 404。HTTP 请求时间消耗是很大的，因此使用 HTTP 请求来获得一个没有用处的响应（例如 404 没有找到页面）是完全没有必要的，它只会降低用户体验而不会有一点好处。</li>
</ul>
<p>服务器优化</p>
<ul>
<li>使用内容分发网络（CDN）。把网站内容分散到多个、处于不同地域位置的服务器上可以加快下载速度。</li>
<li>GZIP 压缩</li>
<li>设置 ETag：ETags（Entity tags，实体标签）是 web 服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制。</li>
<li>提前刷新缓冲区</li>
<li>对 Ajax 请求使用 GET 方法</li>
<li>避免空的图像 src</li>
</ul>
<p>Cookie 优化</p>
<ul>
<li>减小 Cookie 大小</li>
<li>针对 Web 组件使用域名无关的 Cookie</li>
</ul>
<p>CSS 优化</p>
<ul>
<li>将 CSS 代码放在 HTML 页面的顶部</li>
<li>避免使用 CSS 表达式</li>
<li>使用 &lt; link&gt; 来代替 @import</li>
<li>避免使用 Filters</li>
</ul>
<p>javascript 优化</p>
<ul>
<li>将 JavaScript 脚本放在页面的底部。</li>
<li>将 JavaScript 和 CSS 作为外部文件来引用。 在实际应用中使用外部文件可以提高页面速度，因为 JavaScript 和 CSS 文件都能在浏览器中产生缓存。</li>
<li>缩小 JavaScript 和 CSS</li>
<li>删除重复的脚本</li>
<li>最小化 DOM 的访问。使用 JavaScript 访问 DOM 元素比较慢。</li>
<li>开发智能的事件处理程序</li>
<li>javascript 代码注意：谨慎使用 with，避免使用 eval Function 函数，减少作用域链查找。</li>
</ul>
<p>图像优化</p>
<ul>
<li>优化图片大小</li>
<li>通过 CSS Sprites 优化图片</li>
<li>不要在 HTML 中使用缩放图片</li>
<li>favicon.ico 要小而且可缓存</li>
</ul>
<hr>
<h4 id="JS-格式化数字（每三位加逗号）"><a href="#JS-格式化数字（每三位加逗号）" class="headerlink" title="JS 格式化数字（每三位加逗号）"></a><strong>JS 格式化数字（每三位加逗号）</strong></h4><p>从后往前取。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function toThousands(num) &#123;  </span><br><span class="line">    var num = (num || 0).toString(), result = &#x27;&#x27;;  </span><br><span class="line">    while (num.length &gt; 3) &#123;  </span><br><span class="line">        result = &#x27;,&#x27; + num.slice(-3) + result;  </span><br><span class="line">        num = num.slice(0, num.length - 3);  </span><br><span class="line">    &#125;  </span><br><span class="line">    if (num) &#123; result = num + result; &#125;  </span><br><span class="line">    return result;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<hr>
<h4 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a><strong>合并数组</strong></h4><p>如果你需要合并两个数组的话，可以使用 Array.concat()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var array1 = [1, 2, 3];</span><br><span class="line">var array2 = [4, 5, 6];</span><br><span class="line">console.log(array1.concat(array2)); // [1,2,3,4,5,6];</span><br></pre></td></tr></table></figure>

<p>然而，这个函数并不适用于合并大的数组，因为它需要创建一个新的数组，而这会消耗很多内存。</p>
<p>这时，你可以使用 Array.push.apply(arr1, arr2) 来代替创建新的数组，它可以把第二个数组合并到第一个中，从而较少内存消耗。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var array1 = [1, 2, 3];</span><br><span class="line">var array2 = [4, 5, 6];</span><br><span class="line">console.log(array1.push.apply(array1, array2)); // [1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="把节点列表-NodeList-转换为数组"><a href="#把节点列表-NodeList-转换为数组" class="headerlink" title="把节点列表 (NodeList) 转换为数组"></a><strong>把节点列表 (NodeList) 转换为数组</strong></h4><p>如果你运行 document.querySelectorAll(“p”) 方法，它可能会返回一个 DOM 元素的数组 — 节点列表对象。 但这个对象并不具有数组的全部方法，如 sort()，reduce()， map()，filter()。 为了使用数组的那些方法，你需要把它转换为数组。</p>
<p>只需使用 [].slice.call(elements) 即可实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var elements = document.querySelectorAll(&quot;p&quot;); // NodeList</span><br><span class="line">var arrayElements = [].slice.call(elements); // 现在 NodeList 是一个数组</span><br><span class="line"></span><br><span class="line">var arrayElements = Array.from(elements); // 这是另一种转换 NodeList 到 Array  的方法</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="打乱数组元素的顺序"><a href="#打乱数组元素的顺序" class="headerlink" title="打乱数组元素的顺序"></a><strong>打乱数组元素的顺序</strong></h4><p>不适用 Lodash 等这些库打乱数组元素顺序，你可以使用这个技巧：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var list = [1, 2, 3];</span><br><span class="line">console.log(list.sort(function() &#123; Math.random() - 0.5 &#125;)); // [2, 1, 3]</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="js-的-ready-和-onload-事件的区别"><a href="#js-的-ready-和-onload-事件的区别" class="headerlink" title="js 的 ready 和 onload 事件的区别"></a><strong>js 的 ready 和 onload 事件的区别</strong></h4><ul>
<li>onload 是等 HTML 的所有资源都加载完成后再执行 onload 里面的内容，所有资源包括 DOM 结构、图片、视频 等资源;</li>
<li>ready 是当 DOM 结构加载完成后就可以执行了，相当于 jQuery 中的 $(function(){ js 代码 });</li>
<li>另外，onload 只能有一个，ready 可以有多个。</li>
</ul>
<hr>
<h4 id="js-的两种回收机制"><a href="#js-的两种回收机制" class="headerlink" title="js 的两种回收机制"></a><strong>js 的两种回收机制</strong></h4><p>标记清除（mark and sweep）</p>
<p>从语义上理解就比较好理解了，大概就是当变量进入到某个环境中的时候就把这个变量标记一下，比如标记为“进入环境”，当离开的时候就把这个变量的标记给清除掉，比如是“离开环境”。而在这后面还有标记的变量将被视为准备删除的变量。</p>
<ul>
<li>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（可以使用任何标记方式）。</li>
<li>然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。</li>
<li>而在此之后再被加上的标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。</li>
<li>最后，垃圾收集器完成内存清除工作。销毁那些带标记的值并回收它们所占用的内存空间。</li>
</ul>
<p>这是 javascript 最常见的垃圾回收方式。至于上面有说道的标记，到底该如何标记 ？ 好像是有很多方法，比如特殊位翻转，维护一个列表什么的。</p>
<p>引用计数（reference counting）</p>
<ul>
<li>引用计数的含义是跟踪记录每个值被引用的次数，当声明一个变量并将一个引用类型的值赋给该变量时，这个时候的引用类型的值就会是引用次数 +1 了。如果同一个值又被赋给另外一个变量，则该值的引用次数又 +1。</li>
<li>相反如果包含这个值的引用的变量又取得另外一个值，即被重新赋了值，那么这个值的引用就 -1 。当这个值的引用次数编程 0 时，表示没有用到这个值，这个值也无法访问，因此环境就会收回这个值所占用的内存空间回收。</li>
<li>这样，当垃圾收集器下次再运行时，它就会释放引用次数为 0 的值所占用的内存。</li>
</ul>
<hr>
<h4 id="三张图搞懂-JavaScript-的原型对象与原型链"><a href="#三张图搞懂-JavaScript-的原型对象与原型链" class="headerlink" title="三张图搞懂 JavaScript 的原型对象与原型链"></a>三张图搞懂 JavaScript 的原型对象与原型链</h4><p>对于新人来说，JavaScript 的原型是一个很让人头疼的事情，一来 prototype 容易与 <em><strong>*proto*</strong></em> 混淆，</p>
<p>一、prototype 和 <em><strong>*proto*</strong></em> 的区别</p>
<p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/i-12.png"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a.prototype);  <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__);  <span class="comment">//Object &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b.prototype);  <span class="comment">//b &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b.__proto__);  <span class="comment">//function() &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/i-13.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/i-14.png"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*1、字面量方式*/</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a.__proto__ ：&quot;</span>, a.__proto__);  <span class="comment">// Object &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a.__proto__ === a.constructor.prototype：&quot;</span>, a.__proto__ === a.constructor.prototype); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*2、构造器方式*/</span></span><br><span class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> a2 = <span class="keyword">new</span> A();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a2.__proto__：&quot;</span>, a2.__proto__); <span class="comment">// A &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a2.__proto__ === a2.constructor.prototype：&quot;</span>, a2.__proto__ === a2.constructor.prototype); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*3、Object.create()方式*/</span></span><br><span class="line"><span class="keyword">var</span> a4 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> a3 = <span class="built_in">Object</span>.create(a4);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a3.__proto__：&quot;</span>, a3.__proto__); <span class="comment">// Object &#123;a: 1&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a3.__proto__ === a3.constructor.prototype：&quot;</span>, a3.__proto__ === a3.constructor.prototype); <span class="comment">// false（此处即为图1中的例外情况）</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/i-15.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/i-16.png"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__); <span class="comment">// A &#123;&#125;（即构造器 function A 的原型对象）</span></span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__.__proto__); <span class="comment">// Object &#123;&#125;（即构造器 function Object 的原型对象）</span></span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__.__proto__.__proto__); <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/i-17.png"></p>
<h4 id="闭包的理解-？"><a href="#闭包的理解-？" class="headerlink" title="闭包的理解 ？"></a><strong>闭包的理解 ？</strong></h4><p>一、变量的作用域</p>
<p>要理解闭包，首先必须理解 Javascript 特殊的变量作用域。 变量的作用域无非就是两种：全局变量和局部变量。</p>
<p>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(n);</span><br><span class="line">&#125;</span><br><span class="line">f1(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure>

<p>另一方面，在函数外部自然无法读取函数内的局部变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;　　　　</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line">alert(n); <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p>这里有一个地方需要注意，函数内部声明变量的时候，一定要使用 var 命令。 如果不用的话，你实际上声明了一个全局变量！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  n = <span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line">f1();</span><br><span class="line">alert(n); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure>

<p>二、如何从外部读取局部变量 ？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = f1();</span><br><span class="line">result(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure>

<p>既然 f2 可以读取 f1 中的局部变量，那么只要把 f2 作为返回值，我们不就可以在 f1 外部读取它的内部变量了吗！</p>
<p>三、闭包的概念</p>
<p>上一节代码中的 f2 函数，就是闭包。 我的理解是，<code>闭包就是能够读取其他函数内部变量的函数</code>。</p>
<p>由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成 <code>定义在一个函数内部的函数</code>。 所以，在本质上，<code>闭包就是将函数内部和函数外部连接起来的一座桥梁</code>。</p>
<p>四、闭包的用途</p>
<p>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p>
<p>怎么来理解呢 ？请看下面的代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">  nAdd = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; n += <span class="number">1</span> &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = f1();</span><br><span class="line">result(); <span class="comment">// 999</span></span><br><span class="line">nAdd();</span><br><span class="line">result(); <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure>

<p>在这段代码中，result 实际上就是闭包 f2 函数。它一共运行了两次，第一次的值是 999，第二次的值是 1000。这证明了，函数 f1 中的局部变量 n 一直保存在内存中，并没有在 f1 调用后被自动清除。</p>
<p>为什么会这样呢 ？</p>
<p>原因就在于 f1 是 f2 的父函数，而 f2 被赋给了一个全局变量，这导致 f2 始终在内存中，而 f2 的存在依赖于 f1，因此 f1 也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p>
<p>这段代码中另一个值得注意的地方，就是</p>
<ul>
<li>“nAdd=function(){ n+=1 }” 这一行，首先在 nAdd 前面没有使用 var 关键字，因此 nAdd 是一个全局变量，而不是局部变量。</li>
<li>其次，nAdd 的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以 nAdd 相当于是一个 setter，可以在函数外部对函数内部的局部变量进行操作。</li>
</ul>
<p>五、使用闭包的注意点</p>
<ul>
<li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</li>
<li>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</li>
</ul>
<hr>
<h4 id="闭包面试经典问题"><a href="#闭包面试经典问题" class="headerlink" title="闭包面试经典问题"></a><strong>闭包面试经典问题</strong></h4><p>问题：想每次点击对应目标时弹出对应的数字下标 0~4 ，但实际是无论点击哪个目标都会弹出数字 5。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onMyLoad</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题所在：arr 中的每一项的 onclick 均为一个函数实例(Function 对象)，这个函数实例也产生了一个闭包域，这个闭包域引用了外部闭包域的变量，其 function scope 的 closure 对象有个名为 i 的引用，外部闭包域的私有变量内容发生变化，内部闭包域得到的值自然会发生改变。</p>
<p>解决办法一</p>
<p>解决思路：增加若干个对应的闭包域空间(这里采用的是匿名函数)，专门用来存储原先需要引用的内容(下标)，不过只限于基本类型(基本类型值传递，对象类型引用传递)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明一个匿名函数，若传进来的是基本类型则为值传递，故不会对实参产生影响,</span></span><br><span class="line"><span class="comment">//该函数对象有一个本地私有变量 arg(形参) ，该函数的 function scope 的 closure 对象属性有两个引用，一个是 arr，一个是 i</span></span><br><span class="line"><span class="comment">//尽管引用 i 的值随外部改变 ，但本地私有变量(形参) arg 不会受影响，其值在一开始被调用的时候就决定了</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    arr[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// onclick 函数实例的 function scope 的 closure 对象属性有一个引用 arg,</span></span><br><span class="line">      alert(arg);</span><br><span class="line">      <span class="comment">//只要 外部空间的 arg 不变，这里的引用值当然不会改变</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(i); <span class="comment">//立刻执行该匿名函数，传递下标 i (实参)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决办法二</p>
<p>解决思路：将事件绑定在新增的匿名函数返回的函数上，此时绑定的函数中的 function scope 中的 closure 对象的 引用 arg 是指向将其返回的匿名函数的私有变量 arg</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  arr[i].onclick = (<span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(arg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决办法三</p>
<p>使用 ES6 新语法 let 关键字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> j = i; <span class="comment">// 创建一个块级变量</span></span><br><span class="line">  arr[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="JavaScript-判断一个变量是对象还是数组-？"><a href="#JavaScript-判断一个变量是对象还是数组-？" class="headerlink" title="JavaScript 判断一个变量是对象还是数组 ？"></a><strong>JavaScript 判断一个变量是对象还是数组 ？</strong></h4><p>typeof 都返回 object</p>
<p>在 JavaScript 中所有数据类型严格意义上都是对象，但实际使用中我们还是有类型之分，如果要判断一个变量是数组还是对象使用 typeof 搞不定，因为它全都返回 object。</p>
<p>第一，使用 typeof 加 length 属性</p>
<p>数组有 length 属性，object 没有，而 typeof 数组与对象都返回 object，所以我们可以这么判断</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getDataType = <span class="function"><span class="keyword">function</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> o == <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>( <span class="keyword">typeof</span> o.length == <span class="string">&#x27;number&#x27;</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Array&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Object&#x27;</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;param is no object type&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第二，使用 instanceof</p>
<p>利用 instanceof 判断数据类型是对象还是数组时应该优先判断 array，最后判断 object。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getDataType = <span class="function"><span class="keyword">function</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(o <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Array&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( o <span class="keyword">instanceof</span> <span class="built_in">Object</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Object&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;param is no object type&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="ES5-的继承和-ES6-的继承有什么区别-？"><a href="#ES5-的继承和-ES6-的继承有什么区别-？" class="headerlink" title="ES5 的继承和 ES6 的继承有什么区别 ？"></a><strong>ES5 的继承和 ES6 的继承有什么区别 ？</strong></h4><p>ES5 的继承时通过 prototype 或构造函数机制来实现。</p>
<ul>
<li><code>ES5 的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到 this 上（Parent.apply(this)）</code>。</li>
<li><code>ES6 的继承机制完全不同，实质上是先创建父类的实例对象 this（所以必须先调用父类的 super()方法），然后再用子类的构造函数修改 this</code>。</li>
</ul>
<p>具体的：ES6 通过 class 关键字定义类，里面有构造方法，类之间通过 extends 关键字实现继承。子类必须在 constructor 方法中调用 super 方法，否则新建实例报错。因为子类没有自己的 this 对象，而是继承了父类的 this 对象，然后对其进行加工。如果不调用 super 方法，子类得不到 this 对象。</p>
<p>ps：super 关键字指代父类的实例，即父类的 this 对象。在子类构造函数中，调用 super 后，才可使用 this 关键字，否则报错。</p>
<hr>
<h4 id="JS-中数据类型的判断-typeof，instanceof，constructor，Object-prototype-toString-call-的区别"><a href="#JS-中数据类型的判断-typeof，instanceof，constructor，Object-prototype-toString-call-的区别" class="headerlink" title="JS 中数据类型的判断 typeof，instanceof，constructor，Object.prototype.toString.call() 的区别"></a><strong>JS 中数据类型的判断 typeof，instanceof，constructor，Object.prototype.toString.call() 的区别</strong></h4><h5 id="JS-中数据类型的判断"><a href="#JS-中数据类型的判断" class="headerlink" title="JS 中数据类型的判断"></a><strong>JS 中数据类型的判断</strong></h5><h6 id="typeof关键字"><a href="#typeof关键字" class="headerlink" title="typeof关键字"></a><strong>typeof关键字</strong></h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">2</span>);               <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);            <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">&#x27;str&#x27;</span>);           <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []);              <span class="comment">// object     []数组的数据类型在 typeof 中被解释为 object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);    <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;);              <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);       <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);            <span class="comment">// object     null 的数据类型被 typeof 解释为 object</span></span><br></pre></td></tr></table></figure>


<p>结果如下图显示，空数组 和 null被 typeof 解释为 object 类型，有的人可能会认为 typeof 关键字对数组 和 null 的类型判断是错误的，其实typeof对于数组 和 null 的类型判断是正确的，只不过不够精准而已。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/i-18.png"></p>
<p>其他（数字Number，布尔值Boolean，字符串String，函数Function，对象Object，Undefined）这一些数据类型在typeof 下都被精准的解释，只有数组和null的数据类型不够精准。那么如何才能获取到 数组 和 null 的精准数据类型。这就用到下面这种方法。</p>
<h6 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a><strong>instanceof关键字</strong></h6><p>undefined 和 null 在这里的表现有点异于寻常数据，我们先注释掉</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>);                    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);                <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>);                <span class="comment">// false  </span></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>);                    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>);                   <span class="comment">// true    </span></span><br><span class="line"><span class="comment">// console.log(undefined instanceof Undefined);</span></span><br><span class="line"><span class="comment">// console.log(null instanceof Null);</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/i-19.png"></p>
<p>以上结果显示，直接的字面量值判断数据类型，只有引用数据类型（<code>Array，Function，Object</code>）被精准判断，其他（<code>数值Number，布尔值Boolean，字符串String</code>）字面值不能被<code>instanceof</code>精准判断。我们来看一下 <code>instanceof</code> 在<code>MDN</code>中的解释：<code>instanceof</code> 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。其意思就是判断对象是否是某一数据类型（如Array）的实例，请重点关注一下是判断<span style="color:red">一个对象是否是数据类型的实例</span>。在这里字面量值，2， true ，’str’不是实例，所以判断值为false。眼见为实，看下面的例子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/i-20.png"></p>
<p>字面值被实例化了，他们的判断值变为了 <code>true</code>。</p>
<p>接着，我们看一下 <code>undefined </code>和 <code>null </code>  ,说说为什么这两货比较特殊，实际上按理来说，null的所属类就是Null，undefined就是Undefined，但事实并非如此：控制台输出如下结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/i-21.png"></p>
<p>浏览器认为null，undefined不是构造器。但是在 typeof 中你可能已经发现了，typeof null的结果是object，typeof undefined的结果是undefined ，这是怎么回事呢?</p>
<p>尤其是null，其实这是js发展过程中设计者的重大失误，早期准备更改null的类型为null，由于当时已经有大量网站使用了null，如果更改，将导致很多网站的逻辑出现漏洞问题，就没有更改过来，于是一直遗留到现在。作为学习者，我们只需要记住就好。</p>
<h6 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a><strong>constructor</strong></h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">2</span>).constructor === <span class="built_in">Number</span>);</span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">true</span>).constructor === <span class="built_in">Boolean</span>);</span><br><span class="line"><span class="built_in">console</span>.log((<span class="string">&#x27;str&#x27;</span>).constructor === <span class="built_in">String</span>);</span><br><span class="line"><span class="built_in">console</span>.log(([]).constructor === <span class="built_in">Array</span>);</span><br><span class="line"><span class="built_in">console</span>.log((<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;).constructor === <span class="built_in">Function</span>);</span><br><span class="line"><span class="built_in">console</span>.log((&#123;&#125;).constructor === <span class="built_in">Object</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/i-22.png"></p>
<p>用costructor来判断类型看起来是完美的，然而，如果我创建一个对象，更改它的原型，这种方式也变得不可靠了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Fn.prototype=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f=<span class="keyword">new</span> Fn();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f.constructor===Fn);    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(f.constructor===<span class="built_in">Array</span>); <span class="comment">// true </span></span><br></pre></td></tr></table></figure>
<p>如此轻易的更改了contructor，到这里，你可能会想有没有一种最精准的方式去判断数据类型呢？接下来是终极大绝招，奥特曼也是总是到最紧急的时候才出现，这样才能体现价值所在。</p>
<h6 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a><strong>Object.prototype.toString.call()</strong></h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="literal">true</span>));</span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="string">&#x27;str&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(a.call([]));</span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(a.call(&#123;&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="literal">undefined</span>));</span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="literal">null</span>));</span><br></pre></td></tr></table></figure>
<p>使用 Object 对象的原型方法 toString ，使用 call 进行狸猫换太子，借用Object的 toString  方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/yx-dimples/images/hexo/i-23.png"></p>
<h5 id="JS类型判断—typeof-constructor-instanceof-toString"><a href="#JS类型判断—typeof-constructor-instanceof-toString" class="headerlink" title="JS类型判断—typeof, constructor, instanceof, toString"></a>JS类型判断—typeof, constructor, instanceof, toString</h5><h6 id="JS中的数据类型"><a href="#JS中的数据类型" class="headerlink" title="JS中的数据类型"></a>JS中的数据类型</h6><p>js中,根据存储的方式不同(<em>参见文末连接</em>), 数据可以划分为以下两大类型:</p>
<ul>
<li><p><strong>原始类型</strong></p>
<blockquote>
<p>string, number, boolean, undefined, null, symbol</p>
</blockquote>
</li>
<li><p><strong>引用类型</strong></p>
<blockquote>
<p>Object (Array, Function, RegExp, Date)</p>
</blockquote>
</li>
</ul>
<h6 id="数据类型判断"><a href="#数据类型判断" class="headerlink" title="数据类型判断"></a>数据类型判断</h6><p>判断数据的所属类型此处列举四种方法,并对每种方法使用的范围以及限制进行说明.如果对原型链还不熟悉的同学,请先阅读相关的原型链知识(<em>见文末</em>)</p>
<ol>
<li><p><strong>typeof</strong></p>
<p><code>typeof</code> 一般仅用于判断原始类型(<strong>不包含null</strong>),返回值为该类型的字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">&#x27;str&#x27;</span>);  <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">1</span>);      <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>); <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Symbol</span>()); <span class="comment">// symbol</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>: <code>typeof</code>不能用于判断原始类型中的<code>null</code>以及引用类型<code>object</code>,结果都会返回字符串object(<em><code>Function</code>类型除外,结果会返回function,但在在 IE 6, 7 和 8 上则返回object</em>)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);  <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> alert); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>()); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>()); <span class="comment">// object</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>contructor</strong></p>
<p><code>constructor</code>主要是利用原型上的<code>prototype.constructor</code>指向实例的构造函数来进行判断的</p>
<p>先定义一个构造函数<code>Animal</code>, 并<code>new</code>一个实例<code>dog</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Animal = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;<span class="built_in">this</span>.name = name&#125;;   <span class="comment">// 声明一个构造函数</span></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Animal(<span class="string">&#x27;dog&#x27;</span>); <span class="comment">// 生成实例dog</span></span><br></pre></td></tr></table></figure>

<p>声明<code>Animal</code>函数的同时js会在<code>Animal</code>上挂载一个<code>prototype</code>对象,同时在<code>prototype</code>对象上会自动生成一个<code>constructor</code>属性并指向构造函数<code>Animal</code>,相当于:<br><code>Animal.prototype.constructor === Animal // true</code> ,根据原型链的查找原则, <code>console(dog.prototype) // Animal</code> 所以利用构造函数原型上的<code>constructor</code>属性可以判断当前实例是否为当前构造函数的实例,进而确定数据所属类型:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>.constructor === <span class="built_in">String</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>).constructor === <span class="built_in">Number</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span>.constructor === <span class="built_in">Boolean</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(alert.constructor === <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log([].constructor === <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>().constructor === <span class="built_in">Date</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>:</p>
<ol>
<li><code>null</code>, <code>undefined</code> 是无效的对象，因此是不会有 <code>constructor</code> 存在的，这两种类型的数据需要通过其他方式来判断。</li>
<li>函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object</li>
</ol>
</blockquote>
<p>用 <code>constructor</code> 判断类型的限制过多且不准确,容易出错,少用,或者不用!</p>
</li>
<li><p><strong>instanceof</strong></p>
<p>与 <code>typeof</code> 和 <code>constructor</code> 不同, <code>instanceof</code>一般用于判断引用类型,返回值为布尔值, 例如:</p>
<p><code>[] instanceof Array // true</code></p>
<p><code>instanceof</code> 是通过判断当前实例的原型与构造函数的原型是否为同一对象,进而确定当前数据的类型,这样讲或许不够明了,我们简单实现一下 <code>instanceof</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> self_instanceof = <span class="function"><span class="keyword">function</span> (<span class="params">instance, constructor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> instance_proto = instance.__proto__;</span><br><span class="line">    <span class="keyword">let</span> <span class="title">constructor_proto</span> = <span class="title">constructor</span>.<span class="title">prototype</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到终点返回false</span></span><br><span class="line">       <span class="keyword">if</span> (instance_proto === <span class="literal">null</span>) &#123;<span class="keyword">return</span> <span class="literal">false</span>&#125;;</span><br><span class="line">       <span class="comment">// 找到返回true</span></span><br><span class="line">       <span class="keyword">if</span> (instance_proto === <span class="title">constructor_proto</span>) &#123;<span class="keyword">return</span> <span class="literal">true</span>&#125;;</span><br><span class="line">        <span class="comment">// 当实例与构造函数原型不相同, 沿着原型链继续向上查找</span></span><br><span class="line">        instance_proto = instance_proto.__proto__;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>)   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(self_instanceof([], <span class="built_in">Array</span>))  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当一个页面存在多个<code>iframe</code>时,也就是存在多个全局变量<code>window</code>,<code>instanceof</code>的判断会被来自不同的iframe的数据所干扰,导致不可信</p>
</blockquote>
<p>假设:页面<code>pageA</code> 通过<code>iframe</code>内嵌了页面<code>pageB</code>, 此时<code>pageB</code>传递了一个数组 <code>let arrB = []</code>到页面 <code>pageA</code>, 若在<code>pageA</code>使用<code>instanceof</code>判断数组<code>arrB</code>会出现 <code>arrB instanceof Array // false</code> 主要原因是因为 <code>arrB</code> 是由<code>pageB</code>上的<code>Array</code>构造出来的</p>
<p>要避免这种问题可以使用<code>Es6</code>提供的数组静态方法 <code>Array.isArray</code>, 或者我们即将提到的<code>toString</code>方法进行判断<br><code>Array.isArray(arrB) // true</code></p>
</li>
<li><p><strong>toString</strong></p>
<p><code>toString</code>是<code>Object.prototype</code>上的一个方法, 常用方式为 <code>Object.prototype.toString.call(target)</code><br>返回值是 <code>[object 类型]</code>字符串,该方法基本上能判断所有的数据类型(自定义数据类型除外)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义判断类型函数</span></span><br><span class="line"><span class="keyword">let</span> getType = <span class="function"><span class="params">target</span> =&gt;</span> <span class="built_in">Object</span>.prototype.toString.call(target)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getType(<span class="string">&#x27;&#x27;</span>)); <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(getType(<span class="number">2</span>)); <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">console</span>.log(getType(<span class="literal">true</span>)); <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="built_in">console</span>.log(getType(<span class="literal">undefined</span>)); <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(getType(<span class="literal">null</span>)); <span class="comment">// [object Null]</span></span><br><span class="line"><span class="built_in">console</span>.log(getType(<span class="built_in">Symbol</span>())); <span class="comment">// [object Symbol]</span></span><br><span class="line"><span class="built_in">console</span>.log(getType(&#123;&#125;)); <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(getType([])); <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(getType(alert)); <span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">console</span>.log(getType(<span class="keyword">new</span> <span class="built_in">RegExp</span>())); <span class="comment">// [object RegExp]</span></span><br><span class="line"><span class="built_in">console</span>.log(getType(<span class="keyword">new</span> <span class="built_in">Date</span>())); <span class="comment">// [object Date]</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h5 id="翻转一个字符串"><a href="#翻转一个字符串" class="headerlink" title="翻转一个字符串"></a><strong>翻转一个字符串</strong></h5><p>先将字符串转成一个数组，然后用数组的 reverse() + join() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = &quot;hello word&quot;;</span><br><span class="line">let b = [...str].reverse().join(&quot;&quot;); // drow olleh</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="说说堆和栈的区别-？"><a href="#说说堆和栈的区别-？" class="headerlink" title="说说堆和栈的区别 ？"></a><strong>说说堆和栈的区别 ？</strong></h4><p>一、堆栈空间分配区别 　　</p>
<ul>
<li>栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；　　</li>
<li>堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由 OS 回收，分配方式倒是类似于链表。　　</li>
</ul>
<p>二、堆栈缓存方式区别</p>
<ul>
<li>栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放；　　</li>
<li>堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。　　</li>
</ul>
<p>三、堆栈数据结构区别</p>
<ul>
<li>堆（数据结构）：堆可以被看成是一棵树，如：堆排序；　　</li>
<li>栈（数据结构）：一种先进后出的数据结构。</li>
</ul>
<hr>
<h4 id="js-经典面试知识文章"><a href="#js-经典面试知识文章" class="headerlink" title="js 经典面试知识文章"></a>js 经典面试知识文章</h4><ul>
<li><a href="https://www.cnblogs.com/xiaozhumaopao/p/11066005.html">js 异步执行顺序</a></li>
<li><a href="https://github.com/biaochenxuying/blog/issues/8">JS 是单线程，你了解其运行机制吗 ？</a></li>
<li><a href="https://juejin.im/post/5b8de829f265da43623c4261">7 分钟理解 JS 的节流、防抖及使用场景</a></li>
<li><a href="https://juejin.im/post/5bb091a7e51d450e8477d9ba">JavaScript 常见的六种继承方式</a></li>
<li><a href="https://www.cnblogs.com/humin/p/4556820.html">JS 继承的 6 种实现方式</a></li>
<li><a href="https://juejin.im/post/5c23993de51d457b8c1f4ee1">九种跨域方式实现原理（完整版）</a></li>
<li><a href="https://juejin.im/post/5c446eb1e51d45517624f7db">常见六大Web安全攻防解析</a></li>
<li><a href="https://juejin.im/post/5c658309e51d4542331c442e">一文读懂 HTTP/2 及 HTTP/3 特性</a></li>
<li><a href="https://juejin.im/post/5ca6a109e51d4544e27e3048#heading-0">深入理解 HTTPS 工作原理</a></li>
<li><a href="https://juejin.im/post/5cb33660e51d456e811d2687">JavaScript 中的垃圾回收和内存泄漏</a></li>
<li><a href="https://juejin.im/post/5ca0c0abe51d4553a942c17d">你不知道的浏览器页面渲染机制</a></li>
<li><a href="https://juejin.im/post/59df4f74f265da430f311909">JavaScript设计模式</a></li>
<li><a href="https://segmentfault.com/a/1190000000602050">深入 javascript——构造函数和原型对象</a></li>
<li><a href="https://segmentfault.com/a/1190000018265172">高级函数技巧-函数柯里化</a></li>
<li><a href="https://blog.csdn.net/c__dreamer/article/details/79673725">JavaScript之bind及bind的模拟实现</a></li>
<li><a href="https://blog.csdn.net/aa5305123/article/details/83247041">Http Cookie 机制及 Cookie 的实现原理</a></li>
<li><a href="https://blog.csdn.net/u012129607/article/details/78117483">一个dom,点击事件触发两个事件是同步还是异步</a></li>
<li><a href="https://juejin.im/post/5c038df96fb9a04a0378f600">16种JavaScript设计模式（中）</a></li>
</ul>
<hr>
<h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6 +"></a>ES6 +</h3><h4 id="ES6-函数默认参数和-es5-的实现有什么区别-？es6-中又有什么需要注意的-？"><a href="#ES6-函数默认参数和-es5-的实现有什么区别-？es6-中又有什么需要注意的-？" class="headerlink" title="ES6 函数默认参数和 es5 的实现有什么区别 ？es6 中又有什么需要注意的 ？"></a><strong>ES6 函数默认参数和 es5 的实现有什么区别 ？es6 中又有什么需要注意的 ？</strong></h4><h5 id="ES5设置默认参数"><a href="#ES5设置默认参数" class="headerlink" title="ES5设置默认参数"></a>ES5设置默认参数</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeDefault</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    name = name || <span class="string">&quot;default name&quot;</span>;</span><br><span class="line">    age = age || <span class="number">18</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当参数为<code>0</code>、<code>&#39;&#39;</code>、<code>null</code>、<code>false</code>等时，即使这个值合法，也会被视为一个假值，从而取默认值。这种情况下，使用<code>typeof</code>检查参数类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeDefault</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    name = (<span class="keyword">typeof</span> name !== <span class="string">&quot;undefined&quot;</span>) ? name : <span class="string">&quot;default name&quot;</span>;</span><br><span class="line">    age = (<span class="keyword">typeof</span> age !== <span class="string">&quot;undefined&quot;</span>) ? age : <span class="number">18</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ES6设置默认参数"><a href="#ES6设置默认参数" class="headerlink" title="ES6设置默认参数"></a>ES6设置默认参数</h5><p>如果没有参数传入，则提供一个初始值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeDefault</span> (<span class="params">name, age = <span class="number">18</span></span>) </span>&#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">makeDefault (<span class="string">&#x27;lee&#x27;</span>)</span><br><span class="line">makeDefault (<span class="string">&#x27;lee&#x27;</span>, <span class="literal">undefined</span>)</span><br></pre></td></tr></table></figure>

<p>因此，可以为任意参数指定默认值，且已指定默认值的参数后，可以继续声明无默认值参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeDefault</span> (<span class="params">name, age = <span class="number">18</span>, gerder</span>) </span>&#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">makeDefault (<span class="string">&#x27;lee&#x27;</span>, <span class="literal">undefined</span>, <span class="string">&#x27;male&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="默认参数对arguments对象的影响"><a href="#默认参数对arguments对象的影响" class="headerlink" title="默认参数对arguments对象的影响"></a>默认参数对arguments对象的影响</h5><p><strong>ES5非严格模式</strong></p>
<p>命名参数的变化会同步更新到arguments对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">es5</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name === <span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// true</span></span><br><span class="line">    name = <span class="string">&quot;lee&quot;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(name === <span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line">es5(<span class="string">&quot;xiaoming&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>ES5严格模式和ES6使用默认值时</strong></p>
<p>命名参数与arguments对象分离</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">es6</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name === <span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// true</span></span><br><span class="line">    name = <span class="string">&quot;lee&quot;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(name === <span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line">es6(<span class="string">&quot;xiaoming&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a><strong>ES6 声明变量的六种方法</strong></h4><ul>
<li>ES5 只有两种声明变量的方法：var 和 function 。</li>
<li>ES6 除了添加 let 和 const 命令。</li>
<li>还有两种声明变量的方法：import 命令和 class 命令。</li>
</ul>
<hr>
<h4 id="Promise-的队列与-setTimeout-的队列有何关联-？"><a href="#Promise-的队列与-setTimeout-的队列有何关联-？" class="headerlink" title="Promise 的队列与 setTimeout 的队列有何关联 ？"></a><strong>Promise 的队列与 setTimeout 的队列有何关联 ？</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="number">4</span>) &#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; <span class="number">10000</span> ; i++ )&#123;</span><br><span class="line">        i == <span class="number">9999</span> &amp;&amp; resolve()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>为什么结果是：1, 2, 3, 5, 4；而不是：1, 2, 3, 4, 5 ？</p>
<p>js 里面有宏任务（macrotask）和微任务（microtask）。因为 setTimeout 是属于 macrotask 的，而整个 script 也是属于一个 macrotask，promise.then 回调是 microtask，执行过程大概如下：</p>
<ul>
<li>由于整个 script 也属于一个 macrotask，由于会先执行 macrotask 中的第一个任务，再加上 promise 构造函数因为是同步的，所以会先打印出 1 和 2；</li>
<li>然后继续同步执行末尾的 console.log(3) 打印出 3；</li>
<li>此时 setTimeout 被推进到 macrotask 队列中， promise.then 回调被推进到 microtask 队列中；</li>
<li>由于在第一步中已经执行完了第一个 macrotask ，所以接下来会顺序执行所有的 microtask，也就是 promise.then 的回调函数，从而打印出 5；</li>
<li>microtask 队列中的任务已经执行完毕，继续执行剩下的 macrotask 队列中的任务，也就是 setTimeout，所以打印出 4。</li>
</ul>
<hr>
<h4 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a><strong>防抖与节流</strong></h4><p>节流</p>
<p>throttle 的中心思想在于：在某段时间内，不管你触发了多少次回调，我都只认第一次，并在计时结束时给予响应。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fn 是我们需要包装的事件回调, delay 是时间间隔的阈值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// last 为上一次触发回调的时间</span></span><br><span class="line">  <span class="keyword">let</span> last = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将 throttle 处理结果当作函数返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 保留调用时的 this 上下文</span></span><br><span class="line">      <span class="keyword">let</span> context = <span class="built_in">this</span></span><br><span class="line">      <span class="comment">// 保留调用时传入的参数</span></span><br><span class="line">      <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">      <span class="comment">// 记录本次触发回调的时间</span></span><br><span class="line">      <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值</span></span><br><span class="line">      <span class="keyword">if</span> (now - last &gt;= delay) &#123;</span><br><span class="line">          <span class="comment">// 如果时间间隔大于我们设定的时间间隔阈值，则执行回调</span></span><br><span class="line">          last = now;</span><br><span class="line">          fn.apply(context, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 throttle 来包装 scroll 的回调</span></span><br><span class="line"><span class="keyword">const</span> better_scroll = throttle(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;触发了滚动事件&#x27;</span>), <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, better_scroll)</span><br></pre></td></tr></table></figure>

<p>防抖</p>
<p>防抖的中心思想在于：我会等你到底。在某段时间内，不管你触发了多少次回调，我都只认最后一次。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fn  是我们需要包装的事件回调, delay 是每次推迟执行的等待时间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定时器</span></span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将 debounce 处理结果当作函数返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 保留调用时的 this 上下文</span></span><br><span class="line">    <span class="keyword">let</span> context = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// 保留调用时传入的参数</span></span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次事件被触发时，都去清除之前的旧定时器</span></span><br><span class="line">    <span class="keyword">if</span>(timer) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设立新定时器</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn.apply(context, args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 debounce 来包装 scroll 的回调</span></span><br><span class="line"><span class="keyword">const</span> better_scroll = debounce(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;触发了滚动事件&#x27;</span>), <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, better_scroll)</span><br><span class="line">用 Throttle 来优化 Debounce</span><br></pre></td></tr></table></figure>

<p>思想：在 delay 时间内，我可以为你重新生成定时器；但只要 delay 的时间到了，我必须要给用户一个响应。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fn 是我们需要包装的事件回调, delay 是时间间隔的阈值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// last 为上一次触发回调的时间, timer 是定时器</span></span><br><span class="line">  <span class="keyword">let</span> last = <span class="number">0</span>, timer = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 throttle 处理结果当作函数返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="comment">// 保留调用时的 this 上下文</span></span><br><span class="line">    <span class="keyword">let</span> context = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// 保留调用时传入的参数</span></span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="comment">// 记录本次触发回调的时间</span></span><br><span class="line">    <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值</span></span><br><span class="line">    <span class="keyword">if</span> (now - last &lt; delay) &#123;</span><br><span class="line">        <span class="comment">// 如果时间间隔小于我们设定的时间间隔阈值，则为本次触发操作设立一个新的定时器</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          last = now</span><br><span class="line">          fn.apply(context, args)</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果时间间隔超出了我们设定的时间间隔阈值，那就不等了，无论如何要反馈给用户一次响应</span></span><br><span class="line">        last = now</span><br><span class="line">        fn.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用新的 throttle 包装 scroll 的回调</span></span><br><span class="line"><span class="keyword">const</span> better_scroll = throttle(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;触发了滚动事件&#x27;</span>), <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, better_scroll)</span><br></pre></td></tr></table></figure>

<p>以上答案来自于：<a href="https://juejin.im/book/5b936540f265da0a9624b04b/section/5bb6212be51d451a3f4c3570">事件的节流（throttle）与防抖（debounce）</a></p>
<hr>
<h4 id="ES6-面试知识文章"><a href="#ES6-面试知识文章" class="headerlink" title="ES6+ 面试知识文章"></a>ES6+ 面试知识文章</h4><ul>
<li><a href="https://yx-dimples.vercel.app/2021/08/04/ES6/">那些必会用到的 ES6 精粹</a></li>
<li><a href="https://blog.csdn.net/deng1456694385/article/details/83831931">promise、Generator 函数、async 函数的区别与理解</a></li>
<li><a href="https://yx-dimples.vercel.app/2021/08/04/promise,Generator,async/">Typescript 中的 interface 和 type 到底有什么区别</a></li>
<li><a href="https://github.com/Geek-James/Blog/issues/27">进大厂必会 20 道 JS 原理题</a></li>
<li><a href="https://segmentfault.com/a/1190000016231512">AST 抽象语法树——最基础的 javascript 重点知识，99% 的人根本不了解</a></li>
</ul>
<hr>
<h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><h4 id="说下-webpack-的几大特色"><a href="#说下-webpack-的几大特色" class="headerlink" title="说下 webpack 的几大特色 ?"></a><strong>说下 webpack 的几大特色 ?</strong></h4><ul>
<li>code splitting（可以自动完成）(根据代码的分割并对文件进行分块)</li>
<li>loader 可以处理各种类型的静态文件，并且支持串联操作</li>
<li>webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移</li>
<li>webpack 具有 requireJs 和 browserify 的功能，但仍有很多自己的新特性：</li>
<li>对 CommonJS 、 AMD 、ES6 的语法做了兼容</li>
<li>对 js、css、图片等资源文件都支持打包</li>
<li>串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如：提供对 CoffeeScript、ES6 的支持</li>
<li>有独立的配置文件 webpack.config.js</li>
<li>可以将代码切割成不同的 chunk，实现按需加载，降低了初始化时间</li>
<li>支持 SourceUrls 和 SourceMaps，易于调试</li>
<li>具有强大的 Plugin 接口，大多是内部插件，使用起来比较灵活</li>
<li>webpack 使用异步 IO 并具有多级缓存。这使得 webpack 很快且在增量编译上更加快</li>
</ul>
<hr>
<h4 id="说说对-webpack-的理解，优点、原理、打包的过程"><a href="#说说对-webpack-的理解，优点、原理、打包的过程" class="headerlink" title="说说对 webpack 的理解，优点、原理、打包的过程"></a><strong>说说对 webpack 的理解，优点、原理、打包的过程</strong></h4><p>优点</p>
<ul>
<li>依赖管理：方便引用第三方模块、让模块更容易复用、避免全局注入导致的冲突、避免重复加载或加载不需要的模块。</li>
<li>合并代码：把各个分散的模块集中打包成大文件，减少 HTTP 的请求链接数，配合 UglifyJS 可以减少、优化代码的体积。</li>
<li>各路插件：babel 把 ES6+ 转译成 ES5 ，eslint 可以检查编译期的错误……</li>
</ul>
<p>原理</p>
<p>一切皆为模块，由于 webpack 并不支持除 .js 以外的文件，从而需要使用 loader 转换成 webpack 支持的模块，plugin 用于扩展 webpack 的功能，在 webpack 构建生命周期的过程在合适的时机做了合适的事情。</p>
<p>webpack 从构建到输出文件结果的过程</p>
<ul>
<li>解析配置参数，合并从 shell 传入和 webpack.config.js 文件的配置信息，输出最终的配置信息</li>
<li>注册配置中的插件，好让插件监听 webpack 构建生命周期中的事件节点，做出对应的反应</li>
<li>解析配置文件中 entry 入口文件，并找出每个文件依赖的文件，递归下去</li>
<li>在递归每个文件的过程中，根据文件类型和配置文件中 loader 找出相对应的 loader 对文件进行转换</li>
<li>递归结束之后得到每个文件最终的结果，根据 entry 配置生成代码 chunk</li>
<li>输出所有 chunk 到文件系统</li>
</ul>
<hr>
<ul>
<li><a href="https://www.cnblogs.com/chengxs/p/11022842.html">webpack 系列–浅析 webpack 的原理</a></li>
<li><a href="https://segmentfault.com/a/1190000020353337">一看就懂之 webpack 原理解析与实现一个简单的 webpack</a></li>
</ul>
<hr>
<h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><ul>
<li> <a href="https://yx-dimples.vercel.app/2021/08/04/vue-interview/">8 道高频出现的 Vue 面试题及答案</a></li>
<li><a href="https://yx-dimples.vercel.app/2021/08/04/vue-lifeCycle/">详解 Vue 生命周期</a></li>
<li><a href="https://yx-dimples.vercel.app/2021/08/04/Vue-comm_com/">Vue 组件间通信六种方式</a></li>
<li><a href="https://blog.csdn.net/zhoulu001/article/details/79548350">Vue 组件之间 8 种组件通信方式总结</a></li>
<li><a href="https://yx-dimples.vercel.app/2021/08/04/vue-note/">Vue 学习笔记-实现一个分页组件</a></li>
<li><a href="https://www.jianshu.com/p/b1564296a78b">30 道 Vue 面试题，内含详细讲解（涵盖入门到精通，自测 Vue 掌握程度）</a></li>
</ul>
<h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><p><a href="https://segmentfault.com/a/1190000018604138">必须要会的 50 道 React 面试题</a></p>
<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><h4 id="为什么用-Nodejs，它有哪些优缺点-？"><a href="#为什么用-Nodejs，它有哪些优缺点-？" class="headerlink" title="为什么用 Nodejs，它有哪些优缺点 ？"></a><strong>为什么用 Nodejs，它有哪些优缺点 ？</strong></h4><p>优点</p>
<ul>
<li>事件驱动，通过闭包很容易实现客户端的生命活期。</li>
<li>不用担心多线程，锁，并行计算的问题</li>
<li>V8 引擎速度非常快</li>
<li>对于游戏来说，写一遍游戏逻辑代码，前端后端通用</li>
</ul>
<p>缺点</p>
<ul>
<li>nodejs 更新很快，可能会出现版本兼容</li>
<li>nodejs 还不算成熟，还没有大制作</li>
<li>nodejs 不像其他的服务器，对于不同的链接，不支持进程和线程操作</li>
</ul>
<hr>
<h4 id="什么是错误优先的回调函数-？"><a href="#什么是错误优先的回调函数-？" class="headerlink" title="什么是错误优先的回调函数 ？"></a><strong>什么是错误优先的回调函数 ？</strong></h4><p>错误优先(Error-first)的回调函数（Error-First Callback）用于同时返回错误和数据。 第一个参数返回错误，并且验证它是否出错；其他参数返回数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readFile(filePath, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123; </span><br><span class="line">    <span class="comment">//handle the error</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// use the data object </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="如何避免回调地狱-？"><a href="#如何避免回调地狱-？" class="headerlink" title="如何避免回调地狱 ？"></a><strong>如何避免回调地狱 ？</strong></h4><p>以下方式避免回调地狱</p>
<ul>
<li>模块化：将回调函数转换为独立的函数</li>
<li>使用流程控制库，例如 [aync]</li>
<li>使用 Promise</li>
<li>使用 aync/await</li>
</ul>
<hr>
<h4 id="如何用-Node-监听-80-端口"><a href="#如何用-Node-监听-80-端口" class="headerlink" title="如何用 Node 监听 80 端口 ?"></a><strong>如何用 Node 监听 80 端口 ?</strong></h4><ul>
<li>这题有陷阱！在类 Unix 系统中你不应该去监听 80 端口，因为这需要超级用户权限。因此不推荐让你的应用直接监听这个端口。</li>
<li>目前，如果你一定要让你的应用 80 端口的话，你可以有通过在 Node 应用的前方再添加一层反向代理（例如 nginx）来实现，如下图。否则，建议你直接监听大于 1024 的端口</li>
<li>方向代理指的是以代理服务器来接收 Internet 上的连接请求，然后将请求转发给内部网络上的服务器， 并且将服务器返回的结果发送给客户端。</li>
</ul>
<p><a href="https://camo.githubusercontent.com/e43461af38f4fdf1a0e8bcf19fe8cf16af0a6aea04dabcbfecb1de9588ed70d3/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31323839303831392d366238343633363536323939343139302e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/e43461af38f4fdf1a0e8bcf19fe8cf16af0a6aea04dabcbfecb1de9588ed70d3/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31323839303831392d366238343633363536323939343139302e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="img"></a></p>
<hr>
<h4 id="什么是事件循环-？"><a href="#什么是事件循环-？" class="headerlink" title="什么是事件循环 ？"></a><strong>什么是事件循环 ？</strong></h4><ul>
<li>Node 采用的是单线程的处理机制(所有的 I/O 请求都采用非阻塞的工作方式)，至少从 Node.js 开发者的角度是这样的。而在底层，Node.js 借助 libuv 来作为抽象封装层，从而屏蔽不同操作系统的差异，Node 可以借助 livuv 来实现线程。下图表示 Node 和 libuv 的关系。 <a href="https://camo.githubusercontent.com/7c62cee2e995e7adcb2ab931a29a7da30024de77a1b69364dc253cd7cf4900cf/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31323839303831392d316665393437383764353865373531642e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/7c62cee2e995e7adcb2ab931a29a7da30024de77a1b69364dc253cd7cf4900cf/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31323839303831392d316665393437383764353865373531642e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="img"></a></li>
<li>Libuv 库负责 Node API 的执行。它将不同的任务分配给不同的线程，形成一个事件循环，以异步的方式将任务的执行结果返回给 V8 引擎。可以简单用下面这张图来表示。 <a href="https://camo.githubusercontent.com/24362e4a1ce9859fa9452c3b3b95d97b069ed25ccd041255806c1731225e98b2/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31323839303831392d383135366461666561356530316534362e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://camo.githubusercontent.com/24362e4a1ce9859fa9452c3b3b95d97b069ed25ccd041255806c1731225e98b2/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31323839303831392d383135366461666561356530316534362e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="img"></a></li>
<li>每一个 I/O 都需要一个回调函数 —– 一旦执行完便堆到事件循环上用于执行。</li>
</ul>
<hr>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><h4 id="HTTP-是什么"><a href="#HTTP-是什么" class="headerlink" title="HTTP 是什么?"></a><strong>HTTP 是什么?</strong></h4><ul>
<li>HTTP 是基于 TCP/IP（传输控制协议/因特网互联协议，又名网络通讯协议，是 Internet 最基本的协议）的关于数据如何在万维网中如何通信的协议。</li>
<li>HTTP 的底层是 TCP/IP。</li>
</ul>
<p>所以 GET 和 POST 的底层也是 TCP/IP，也就是说，GET/POST 都是 TCP 链接。 GET 和 POST 能做的事情是一样一样的。你要给 GET 加上 request body，给 POST 带上 url 参数，技术上是完全行的通的。</p>
<ul>
<li>业界不成文的规定是，(大多数) 浏览器通常都会限制 url 长度在 2K 个字节，而(大多数)服务器最多处理 64K 大小的 url。超过的部分，恕不处理。</li>
<li>如果你用 GET 服务，在 request body 偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然 GET 可以带 request body，也不能保证一定能被接收到哦。</li>
<li>GET 和 POST 本质上就是 TCP 链接，并无差别。但是由于 HTTP 的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</li>
</ul>
<hr>
<h4 id="HTTP-中-GET-与-POST-的区别"><a href="#HTTP-中-GET-与-POST-的区别" class="headerlink" title="HTTP 中 GET 与 POST 的区别"></a><strong>HTTP 中 GET 与 POST 的区别</strong></h4><ul>
<li>GET 在浏览器回退时是无害的，而 POST 会再次提交请求。</li>
<li>GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。</li>
<li>GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。</li>
<li>GET 请求只能进行 url 编码，而 POST 支持多种编码方式。</li>
<li>GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。</li>
<li>GET 请求在 URL 中传送的参数是有长度限制的，而 POST 么有。</li>
<li>对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。</li>
<li>GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。</li>
<li>GET 参数通过 URL 传递，POST 放在 Request body 中。</li>
</ul>
<p>GET 和 POST 还有一个重大区别</p>
<p>简单的说：</p>
<ul>
<li>GET 产生一个 TCP 数据包;</li>
<li>POST 产生两个 TCP 数据包。</li>
</ul>
<p>长的说：</p>
<ul>
<li>对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200 (返回数据);</li>
<li>而对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok(返回数据)。</li>
</ul>
<p>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。 而在网络环境差的情况下，两次包的 TCP 在验证数据包完整性上，有非常大的优点。 并不是所有浏览器都会在 POST 中发送两次包，Firefox 就只发送一次。</p>
<hr>
<h4 id="浏览器缓存实现原理"><a href="#浏览器缓存实现原理" class="headerlink" title="浏览器缓存实现原理"></a><strong>浏览器缓存实现原理</strong></h4><p>浏览器缓存将文件保存在客户端，好的缓存策略可以减少对网络带宽的占用，可以提高访问速度，提高用户的体验，还可以减轻服务器的负担。</p>
<p>当一个客户端请求 web 服务器, 请求的内容可以从以下几个地方获取：服务器、浏览器缓存中或缓存服务器中。这取决于服务器端输出的页面信息。页面文件有三种缓存状态。</p>
<ol>
<li>最新的：选择不缓存页面，每次请求时都从服务器获取最新的内容。</li>
<li>未过期的：在给定的时间内缓存，如果用户刷新或页面过期则去服务器请求，否则将读取本地的缓存，这样可以提高浏览速度。</li>
<li>过期的：也就是陈旧的页面，当请求这个页面时，必须进行重新获取。</li>
</ol>
<p>页面的缓存状态是由 http header 决定的，一个浏览器请求信息，一个是服务器响应信息。</p>
<p>主要包括 Pragma: no-cache、Cache-Control、 Expires、 Last-Modified、If-Modified-Since。</p>
<p>其中 Pragma: no-cache 由 HTTP/1.0 规定，Cache-Control 由 HTTP/1.1 规定。</p>
<p>Cache-Control 的主要参数：</p>
<ul>
<li>A、Cache-Control: private/public，Public 响应会被缓存，并且在多用户间共享。 Private 响应只能够作为私有的缓存，不能在用户间共享。</li>
<li>B、Cache-Control: no-cache，不进行缓存。</li>
<li>C、Cache-Control: max-age = x，缓存时间，以秒为单位。</li>
<li>D、Cache-Control: must-revalidate，如果页面是过期的，则去服务器进行获取。</li>
</ul>
<p>Expires：显示的设置页面过期时间。</p>
<p>Last-Modified：请求对象最后一次的修改时间，用来判断缓存是否过期，通常由文件的时间信息产生。</p>
<p>If-Modified-Since：客户端发送请求附带的信息，指浏览器缓存请求对象的最后修改日期，用来和服务器端的 Last-Modified 做比较。</p>
<hr>
<h4 id="说一下-HTTP-协议头字段说上来几个，是否尽可能详细的掌握-HTTP-协议。"><a href="#说一下-HTTP-协议头字段说上来几个，是否尽可能详细的掌握-HTTP-协议。" class="headerlink" title="说一下 HTTP 协议头字段说上来几个，是否尽可能详细的掌握 HTTP 协议。"></a><strong>说一下 HTTP 协议头字段说上来几个，是否尽可能详细的掌握 HTTP 协议。</strong></h4><p>HTTP 协议头字段</p>
<ul>
<li>HTTP 的头域包括 <code>通用头，请求头，响应头和实体头</code> 四个部分。</li>
<li>每个头域由一个域名，冒号（:）和域值三部分组成。</li>
<li>域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。</li>
</ul>
<p>HTTP 协议</p>
<ul>
<li>HTTP 是超文本传输协议的缩写，它用于传送 WWW 方式的数据。</li>
<li>HTTP 协议采用了请求/响应模型。</li>
<li>客户端向服务器发送一个请求，请求头包含请求的方法、URI、协议版本、以及包含请求修饰符、客户 信息和内容的类似于 MIME 的消息结构。</li>
<li>服务器以一个状态行作为响应，相应的内容包括消息协议的版本，成功或者错误编码加上包含服务器信息、实体元信息以及可能的实体内容。</li>
</ul>
<hr>
<h4 id="一次完整的-HTTP-事务是怎样的一个过程-？"><a href="#一次完整的-HTTP-事务是怎样的一个过程-？" class="headerlink" title="一次完整的 HTTP 事务是怎样的一个过程 ？"></a><strong>一次完整的 HTTP 事务是怎样的一个过程 ？</strong></h4><ul>
<li>域名解析</li>
<li>发起 TCP 的 3 次握手</li>
<li>建立 TCP 连接后发起 http 请求</li>
<li>服务器响应 http 请求，浏览器得到 html 代码</li>
<li>浏览器解析 html 代码，并请求 html 代码中的资源（如 js、css、图片等）</li>
<li>浏览器对页面进行渲染呈现给用户</li>
</ul>
<p>详情过程请看：<a href="https://juejin.im/post/5b9ba9c15188255c8320fe27">面试题之从敲入 URL 到浏览器渲染完成</a></p>
<hr>
<h4 id="HTTP-状态码知道哪些-？"><a href="#HTTP-状态码知道哪些-？" class="headerlink" title="HTTP 状态码知道哪些 ？"></a><strong>HTTP 状态码知道哪些 ？</strong></h4><ul>
<li>100 Continue 继续，一般在发送 post 请求时，已发送了 http header 之后服务端将返回此信息，表示确认，之后发送具体参数信息。</li>
<li><code>200</code> OK 正常返回信息 。</li>
<li>201 Created 请求成功并且服务器创建了新的资源 。</li>
<li>202 Accepted 服务器已接受请求，但尚未处理 。</li>
<li>301 Moved Permanently 请求的网页已永久移动到新位置。</li>
<li>302 Found 临时性重定向。</li>
<li>303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。</li>
<li>304 Not Modified 自从上次请求后，请求的网页未修改过。</li>
<li><code>400</code> Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</li>
<li><code>401</code> Unauthorized 请求未授权。</li>
<li><code>403</code> Forbidden 禁止访问。</li>
<li><code>404</code> Not Found 找不到如何与 URI 相匹配的资源。</li>
<li><code>500</code> Internal Server Error 最常见的服务器端错误。</li>
<li><code>503</code> Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</li>
</ul>
<hr>
<h4 id="axios-的特点有哪些-？"><a href="#axios-的特点有哪些-？" class="headerlink" title="axios 的特点有哪些 ？"></a><strong>axios 的特点有哪些 ？</strong></h4><ul>
<li>axios 是一个基于 promise 的 HTTP 库，支持 promise 的所有 API</li>
<li>它可以拦截请求和响应</li>
<li>它可以转换请求数据和响应数据，并对响应回来的内容自动转换为 json 类型的数据</li>
<li>它安全性更高，客户端支持防御 XSRF</li>
</ul>
<hr>
<p>相关文章：</p>
<ul>
<li><a href="https://blog.csdn.net/lzj2504476514/article/details/81454754">TCP 协议和 UDP 协议的特点和区别</a></li>
<li><a href="https://www.cnblogs.com/NightTiger/p/11334314.html">(纯干货)HTTP／1.0／1.1／2.0的区别以及http和https的区别</a></li>
<li><a href="https://www.cnblogs.com/colima/p/7295771.html">http &amp; https &amp; http2.0</a></li>
</ul>
<h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><h4 id="实现两个变量交换值的方法有哪些-？"><a href="#实现两个变量交换值的方法有哪些-？" class="headerlink" title="实现两个变量交换值的方法有哪些 ？"></a><strong>实现两个变量交换值的方法有哪些 ？</strong></h4><p>一、使用临时变量的方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t; </span><br><span class="line">t = a; </span><br><span class="line">a = b; </span><br><span class="line">b = t;</span><br></pre></td></tr></table></figure>

<p>首先把 a 的值存储到临时变量中， 然后 b 赋值给 a， 最后拿出临时变量中的 a 值赋给 b。</p>
<p>二、一次加，两次减</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = a + b; </span><br><span class="line">b = a - b; </span><br><span class="line">a = a - b;</span><br></pre></td></tr></table></figure>

<p>让 a 先变成 a 与 b 的 ‘和’（也可以换成 a 和 b 的差，一样的）， ‘和’ 减去 b ，巧妙的得到了 a 的变量值赋予 b ， 再通过 ‘和’ 减去 a 的值，得到了 b 的值赋予 a 。</p>
<p>三、复用对象 </p>
<p>把 a 先变成了一个对象， 这个对象保存着应该交换后的键值对， 最后赋值搞定。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = &#123; <span class="attr">a</span>: b, <span class="attr">b</span>: a &#125;; </span><br><span class="line">b = a.b; </span><br><span class="line">a = a.a;</span><br></pre></td></tr></table></figure>

<p>四、利用数组</p>
<p>和上面的方法很像，只不过对象换成了数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = [a, b]; </span><br><span class="line">b = a[<span class="number">0</span>]; </span><br><span class="line">a = a[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>五、一行代码</p>
<p>简单粗暴一行代码交换了 a 和 b 的变量值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = [b, b = a][<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>根据运算符优先级，首先执行 b = a ， 此时的 b 直接得到了 a 的变量值 ， 然后一步数组索引让 a 得到了 b 的值（简直不能再厉害）。</p>
<p>六、ES6 的解构赋值语法 </p>
<p>最后我的方案是利用了 ES6 的解构赋值语法， 它允许我们提取数组和对象的值，对变量进行赋值 （旧版本浏览器不能使用ES6语法）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[a, b] = [b, a];</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="原生-js-实现斐波那契数列"><a href="#原生-js-实现斐波那契数列" class="headerlink" title="原生 js 实现斐波那契数列"></a><strong>原生 js 实现斐波那契数列</strong></h4><p>说明： 斐波那契数列，以兔子的繁殖的例子而引入，故又称“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、…； 在数学上，斐波那契数列以如下被以递归的方法定义：F(1)=1, F(2)=1, F(n)=F(n-1)+F(n-2) (n&gt;2，n∈N*)。</p>
<p>一、递归方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span> || n === <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">6</span>));</span><br></pre></td></tr></table></figure>

<p>二、动态规划方法（性能得到优化）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n1 = <span class="number">1</span>,</span><br><span class="line">        n2 = <span class="number">1</span>,</span><br><span class="line">        sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i += <span class="number">1</span>) &#123;</span><br><span class="line">        sum = n1 + n2;</span><br><span class="line">        n1 = n2;    <span class="comment">// 往后移动一位数</span></span><br><span class="line">        n2 = sum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">5</span>));</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="求一个数组的最大差值"><a href="#求一个数组的最大差值" class="headerlink" title="求一个数组的最大差值"></a><strong>求一个数组的最大差值</strong></h4><p>原理：遍历一次数组，找到最大值和最小值，返回差值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getMaxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 定义两个变量，分别存贮最大值和最小值</span></span><br><span class="line">  <span class="keyword">let</span> maxNum = arr[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> minNum = arr[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] &gt; maxNum)&#123;</span><br><span class="line">      maxNum = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] &lt; minNum)&#123;</span><br><span class="line">      minNum = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxNum - minNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>var max = Math.max.apply(null, array)，这样就可以轻易的得到一个数组中最大的一项 注：在调用 apply 的时候第一个参数给了一个 null，这个是因为没有对象去调用这个方法，我们只需要用这个方法帮我们运算，得到返回的结果就行，所以就直接传递了一个 null 过去。</p>
<hr>
<h4 id="实现类似-getElementsByClassName-的功能"><a href="#实现类似-getElementsByClassName-的功能" class="headerlink" title="实现类似 getElementsByClassName 的功能"></a><strong>实现类似 getElementsByClassName 的功能</strong></h4><p>自己实现一个函数，查找某个 DOM 节点下面的包含某个 class 的所有 DOM 节点？不允许使用原生提供的 getElementsByClassName、querySelectorAll 等原生提供 DOM 查找函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queryClassName</span>(<span class="params">node, name</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> starts = <span class="string">&#x27;(^|[ \n\r\t\f])&#x27;</span>,</span><br><span class="line">       ends = <span class="string">&#x27;([ \n\r\t\f]|$)&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> array = [],</span><br><span class="line">        regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(starts + name + ends),</span><br><span class="line">        elements = node.getElementsByTagName(<span class="string">&quot;*&quot;</span>),</span><br><span class="line">        length = elements.length,</span><br><span class="line">        i = <span class="number">0</span>,</span><br><span class="line">        element;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; length) &#123;</span><br><span class="line">        element = elements[i];</span><br><span class="line">        <span class="keyword">if</span> (regex.test(element.className)) &#123;</span><br><span class="line">            array.push(element);</span><br><span class="line">        &#125;</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="随机生成指定长度的字符串"><a href="#随机生成指定长度的字符串" class="headerlink" title="随机生成指定长度的字符串"></a><strong>随机生成指定长度的字符串</strong></h4><p>实现一个算法，随机生成指制定长度的字符串。比如给定 长度 8，输出 4ldkfg9j。</p>
<p>原理：可以手动指定字符库及随机字符长度 n，利用 Math.floor() 和 Math.random() 两个方法实现获取随机字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomString</span>(<span class="params">n</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz9876543210&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> tmp = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      i = <span class="number">0</span>,</span><br><span class="line">      l = str.length;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    tmp += str.charAt(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * l));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = randomString;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="判断一个单词是否是回文-？"><a href="#判断一个单词是否是回文-？" class="headerlink" title="判断一个单词是否是回文 ？"></a><strong>判断一个单词是否是回文 ？</strong></h4><p>回文是指把相同的词汇或句子，在下文中调换位置或颠倒过来，产生首尾回环的情趣，叫做回文，也叫回环。比如 mamam redivider 。</p>
<p>很多人拿到这样的题目非常容易想到用 for 将字符串颠倒字母顺序然后匹配就行了。</p>
<p>其实重要的考察的就是对于 reverse 的实现。</p>
<p>其实我们可以利用现成的函数，将字符串转换成数组，这个思路很重要，我们可以拥有更多的自由度去进行字符串的一些操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkPalindrom</span>(<span class="params">str</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> str == str.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="二分查找算法"><a href="#二分查找算法" class="headerlink" title="二分查找算法"></a><strong>二分查找算法</strong></h4><p>建立在已经排好序的情况下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">arr, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> end = arr.length - <span class="number">1</span>,</span><br><span class="line">        start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">var</span> middle = <span class="built_in">Math</span>.floor((start + end) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[middle] &gt; data) &#123;</span><br><span class="line">            end = middle - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[middle] &lt; data) &#123;</span><br><span class="line">            start = middle + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(binarySearch(arr, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="写一个方法将数组换成前端更易解析的树状结构"><a href="#写一个方法将数组换成前端更易解析的树状结构" class="headerlink" title="写一个方法将数组换成前端更易解析的树状结构"></a><strong>写一个方法将数组换成前端更易解析的树状结构</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTree</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newData = [],</span><br><span class="line">        hash = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hash[data[i].province]) &#123;</span><br><span class="line">            hash[data[i].province] = &#123;</span><br><span class="line">                <span class="string">&#x27;province&#x27;</span>: data[i].province</span><br><span class="line">            &#125;;</span><br><span class="line">            hash[data[i].province][<span class="string">&#x27;city&#x27;</span>] = [&#123;</span><br><span class="line">                <span class="string">&#x27;name&#x27;</span>: data[i].city,</span><br><span class="line">                <span class="string">&#x27;code&#x27;</span>: data[i].code</span><br><span class="line">            &#125;]</span><br><span class="line">            newData.push(hash[data[i].province]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hash[data[i].province].province == data[i].province) &#123;</span><br><span class="line">            hash[data[i].province][<span class="string">&#x27;city&#x27;</span>].push(&#123;</span><br><span class="line">                <span class="string">&#x27;name&#x27;</span>: data[i].city,</span><br><span class="line">                <span class="string">&#x27;code&#x27;</span>: data[i].code</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newData;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> data = [&#123;</span><br><span class="line">    <span class="string">&#x27;province&#x27;</span>: <span class="string">&#x27;浙江&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;温州&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;code&#x27;</span>: <span class="string">&#x27;10010&#x27;</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="string">&#x27;province&#x27;</span>: <span class="string">&#x27;浙江&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;杭州&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;code&#x27;</span>: <span class="string">&#x27;10011&#x27;</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="string">&#x27;province&#x27;</span>: <span class="string">&#x27;安徽&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;合肥&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;code&#x27;</span>: <span class="string">&#x27;10012&#x27;</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="string">&#x27;province&#x27;</span>: <span class="string">&#x27;安徽&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;马鞍山&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;code&#x27;</span>: <span class="string">&#x27;10013&#x27;</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="string">&#x27;province&#x27;</span>: <span class="string">&#x27;浙江&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;宁波&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;code&#x27;</span>: <span class="string">&#x27;10014&#x27;</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(getTree(data));</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a><strong>数组去重</strong></h4><p>一、 使用 ES6 的 Set 去除数组的重复元素</p>
<p>Array.from() 方法可以将 Set 结构转化为数组结构</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span>(<span class="params">array</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array)); </span><br><span class="line">&#125; </span><br><span class="line">dedupe([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure>

<p>二：扩展运算符（…），内部使用 for…of 循环</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> unique = [...new <span class="built_in">Set</span>(arr)];</span><br></pre></td></tr></table></figure>

<p>三：采用对象数组方法去重</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> newArr = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!obj[arr[i]])&#123;</span><br><span class="line">            obj[arr[i]] = <span class="number">1</span>;</span><br><span class="line">            newArr.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a><strong>字符串反转</strong></h4><p>1、split() 字符串转成数组； 2、reverse() 翻转数组； 3、join() 数组转化成字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++)&#123;</span><br><span class="line">        <span class="keyword">return</span> str.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="产生随机数"><a href="#产生随机数" class="headerlink" title="产生随机数"></a><strong>产生随机数</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">random</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">&#x27;123asdasdasrwer&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> l = str.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">       <span class="keyword">return</span> obj += str.charAt(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*l));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="获取地址栏中某个参数的值"><a href="#获取地址栏中某个参数的值" class="headerlink" title="获取地址栏中某个参数的值"></a><strong>获取地址栏中某个参数的值</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUrl</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> url = <span class="built_in">window</span>.location.href();</span><br><span class="line">    <span class="keyword">let</span> Url = url.split(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(Url[<span class="number">0</span>] == url)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> arr = Url[<span class="number">1</span>].split(<span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">       <span class="keyword">let</span> arg = arr[i].split(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        obj[arg[<span class="number">0</span>]] = arg[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> href = getUrl();</span><br><span class="line"><span class="built_in">console</span>.log(href[<span class="string">&#x27;name&#x27;</span>]);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="统计字符中出现次数最多的字母"><a href="#统计字符中出现次数最多的字母" class="headerlink" title="统计字符中出现次数最多的字母"></a><strong>统计字符中出现次数最多的字母</strong></h4><p>原理：这个和数组去重类似，也是利用一个对象 obj，将数组元素作为对象的属性名，如果不存在该属性名，则值赋为 1，如果存在，则值加 1。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findMaxDuplicateChar</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> charObj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 利用String的charAt()方法获取各个字符; charAt() 方法可返回指定位置的字符</span></span><br><span class="line">        <span class="keyword">if</span>(!charObj[str.charAt(i)]) &#123;</span><br><span class="line">            charObj[str.charAt(i)] = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            charObj[str.charAt(i)] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> maxChar = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            maxValue = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> charObj) &#123;</span><br><span class="line">        <span class="comment">// 在obj对象中寻找值最大的那个属性</span></span><br><span class="line">        <span class="keyword">if</span>(charObj[k] &gt;= maxValue) &#123;</span><br><span class="line">            maxChar = k;</span><br><span class="line">            maxValue = charObj[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxChar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="101-个硬币中有-100-真、1-假，真假区别在于重量。请用无砝码天平称两次给出真币重还是假币重的结论"><a href="#101-个硬币中有-100-真、1-假，真假区别在于重量。请用无砝码天平称两次给出真币重还是假币重的结论" class="headerlink" title="101 个硬币中有 100 真、1 假，真假区别在于重量。请用无砝码天平称两次给出真币重还是假币重的结论"></a><strong>101 个硬币中有 100 真、1 假，真假区别在于重量。请用无砝码天平称两次给出真币重还是假币重的结论</strong></h4><p>方法 1</p>
<ul>
<li>第一步：把硬币分为三堆儿（50，50，1），先拿两个 50 放天平比较，如果相等，说明那个单个的就是假的，再随便拿一个真硬币和这个假硬币放天平比较一下就可得到结果。</li>
<li>第二步：如果第一步的两个 50 比较后不相等，此时一端 50 重，一端 50 轻。如果拿轻的一端 50，分成两堆（25，25） 放到天平上，如果这两个 25 相等，则假硬币（重）在重的一端 50 里，否则（不相等）假硬币（轻）在这两个（25，25）里，也就是轻的一端 50 里。</li>
</ul>
<p>方法 2</p>
<ul>
<li>把硬币分为 A B C 三组，满足如下条件：C &gt; A = B，先比较 A 和 B。如果 A 和 B 一样重，则敏感词在 C 中。</li>
<li>从 A+B 中选取和 C 同样数量的真币和 C 比较。</li>
<li>如果 A 和 B 重量不等，说明 C 中全为真币，从 C 中选取和 A 一样数量的真币与 A 比较，再结合之前 A B 比较的结果，即可得知敏感词究竟比真币重还是轻。</li>
</ul>
<hr>
<ul>
<li><a href="https://blog.csdn.net/hhthwx/article/details/79784205">查找两个不同元素最近的父节点</a></li>
</ul>
<hr>
<h3 id="JavaScript-数据结构"><a href="#JavaScript-数据结构" class="headerlink" title="JavaScript 数据结构"></a>JavaScript 数据结构</h3><ul>
<li><a href="https://juejin.im/post/5d187b81e51d4550a629b2c5">JavaScript 数据结构与算法之美 - 线性表（数组、栈、队列、链表）</a></li>
<li><a href="https://juejin.im/post/5d1b07716fb9a07efe2dd644">JavaScript 数据结构与算法之美 - 栈内存与堆内存 、浅拷贝与深拷贝</a></li>
<li><a href="https://juejin.im/post/5d2dd6dc6fb9a07eb67dc34b">JavaScript 数据结构与算法之美 - 非线性表中的树、堆是干嘛用的 ？其数据结构是怎样的 ？</a></li>
</ul>
<h3 id="十大经典排序算法"><a href="#十大经典排序算法" class="headerlink" title="十大经典排序算法"></a>十大经典排序算法</h3><ul>
<li><a href="https://juejin.im/post/5d3ea9a4e51d4561f060cd2d">JavaScript 数据结构与算法之美 - 十大经典排序算法汇总</a></li>
</ul>
<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p><a href="https://segmentfault.com/a/1190000011969554">Git 的 4 个阶段的撤销更改</a></p>
]]></content>
      <tags>
        <tag>css</tag>
        <tag>ES6</tag>
        <tag>面试</tag>
        <tag>vue</tag>
        <tag>html</tag>
        <tag>js</tag>
        <tag>webpack</tag>
        <tag>react</tag>
        <tag>node</tag>
        <tag>https</tag>
        <tag>数据结构与算法</tag>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
